{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CIMPL Project CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and declarative, with tools to produce FHIR Profiles, Implementation Guides, data dictionaries, and other documentation. Table of Contents Installation and Setup - Installing and configuring the CIMPL development environment. CIMPL User Guide - A guide on installing, configuring, and authoring within the CIMPL development environment. CIMPL Tutorials CIMPL HelloWorld Tutorial - a very simple tutorial which creates a FHIR implemenation guide (IG). CIMPL Detailed Tutorial - Walkthrough example of how to author a detailed clinical model using CIMPL 6.0 grammar. CIMPL Reference - A detailed reference of CIMPL data primitives and syntax. The current version of CIMPL Grammar is CIMPL 6.0.","title":"![](img_cimpl/cimpl-logo.png) CIMPL Project"},{"location":"#cimpl-project","text":"CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and declarative, with tools to produce FHIR Profiles, Implementation Guides, data dictionaries, and other documentation.","title":"CIMPL Project"},{"location":"#table-of-contents","text":"Installation and Setup - Installing and configuring the CIMPL development environment. CIMPL User Guide - A guide on installing, configuring, and authoring within the CIMPL development environment. CIMPL Tutorials CIMPL HelloWorld Tutorial - a very simple tutorial which creates a FHIR implemenation guide (IG). CIMPL Detailed Tutorial - Walkthrough example of how to author a detailed clinical model using CIMPL 6.0 grammar. CIMPL Reference - A detailed reference of CIMPL data primitives and syntax. The current version of CIMPL Grammar is CIMPL 6.0.","title":"Table of Contents"},{"location":"about/","text":"About CIMPL CIMPL was created by the MITRE Corporation . CIMPL is open source and for public use.","title":"About CIMPL"},{"location":"about/#about-cimpl","text":"CIMPL was created by the MITRE Corporation . CIMPL is open source and for public use.","title":"About CIMPL"},{"location":"cimpl5Reference/","text":"CIMPL 5.0 Reference Documentation This is a comprehensive guide to CIMPL 5.0 syntax. The latest release is CIMPL 6.0. This documentation is provided for historical purposes. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial . Table of Contents 1. General Overview * 1.1 Whitespace * 1.2 Naming Conventions * 1.3 Ordinality * 1.4 Naming Collisions * 1.5 Versioning * 1.6 Comments 2. File Headers * 2.1 Sample File Header * 2.2 Grammar * 2.3 Namespace Declaration * 2.4 File Description * 2.5 Uses * 2.6 Url Shorthands * 2.7 CodeSystems 3. Data Element File * 3.1 Sample Data Element File * 3.2 Element Name Declaration * 3.3 Concept Code * 3.4 Inheritance * 3.5 Description * 3.6 Fields * 3.6.1 Value * 3.6.2 Primitives * 3.6.3 Field * 3.6.4 Inherited Field * 3.6.5 References * 3.7 Field Constraints * 3.7.1 No Constraint * 3.7.2 Cardinality * 3.7.3 Fixed Value * 3.7.4 Type * 3.7.5 Value Set * 3.7.6 Includes Code * 3.7.7 Includes Type 4. Map File * 4.1 Sample Map File * 4.2 Element Mapping * 4.3 Field Mapping * 4.4 Fix * 4.5 Constrain * 4.6 Slicing * 4.6.1 Declaring a Discriminator * 4.6.2 Moving the Slice Location * 4.6.3 Slice Strategies 5. Value Set File * 5.1 Sample Value Set File * 5.2 Value Set Declaration * 5.3 Value Set Description * 5.4 Code-Value Declaration 6. FHIR Examples File 7. Future Architectural Considerations General Overview CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and declarative, with tools to produce FHIR Profiles, FHIR Implementation Guides, data dictionaries, and other assets. Whitespace Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 5.0 Namespace: shr.core ...is equivalent to this: Grammar: DataElement 5.0 Namespace: shr.core Naming Conventions File names Data Element files: namespace.txt Value Set files: namespace_vs.txt Mapping files: namespace_map.txt Note: any periods in the namespace should be replaced by underscores Namespaces A namespace conventionally is denominated by the authoring organization and the broad category of elements the namespace defines, delineated by a period. For example: Namespace: shr.oncology Note: The organization name is recommended but not required (e.g., Namespace: oncology is also allowed). Elements Elements are conventionally defined in PascalCase . For example: Element: GeologicalLocation Note: Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter. Value Sets Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: It is required that an Value Set name begins with an uppercase letter. Code Sets Within a custom value set, the individual codes are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or other radiation source\" #swimming_pool \"Swimming Pool\" Ordinality CIMPL does not enforce or require ordinality in any of its definitions, i.e. an element defined at the bottom of the file can be used as field on an element defined at the top. There is, however, a requirement for a file's header information to be at the top of the file, before any definitions. See: File Headers for more information Naming Collisions CIMPL does not support duplicate element names within a namespace. However, you are allowed to reuse an element name across different namespaces. In the case that you come across a collision due to an included namespace in Uses , you have to refer to the element by its Fully Qualified Name . Versioning CIMPL follows the Semantic Versioning convention (MAJOR.MINOR.PATCH). MAJOR: A breaking change. This is reserved for drastic grammar overhauls. Does not support backwards compatibility to other major version releases. MINOR: Feature updates. Allows for backwards compatability within the major version. PATCH: Minor updates and bug fixes. Allows for backwards compatability within the major version. CIMPL is currently on major version 5. For a full changelog, see the Release Notes . Comments CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */ File Headers Each CIMPL file contains header information that describes the file type, its scope and inheritance, and its purpose. It also allows developers to create aliases for urls and code systems. Sample File Header Grammar: DataElement 5.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication CodeSystem: LNC = http://loinc.org Grammar The Grammar keyword is used to define the file type and the version of CIMPL used in development/parsing. This is required for all CIMPL files. Keyword Example Grammar Grammar: DataElement 5.0 Grammar Grammar: ValueSet 5.0 Grammar Grammar: Map 5.0 There are three possible options for file type: 1. DataElement 2. ValueSet 3. Mapping The version details the MAJOR and MINOR version the file was written for. The language is backwards compatibile within the MAJOR version number, i.e. DataElement 5.0 files will compile without problems on the 5.9.0 tooling. For more information, see Versioning . Namespace Declaration The Namespace keyword defines the scope of the file and serves as a broad grouping of DataElement , ValueSet and Map files within a domain. Keyword Example Namespace Namespace: shr.environment The namespace can be any number of lowercase period delimited words. Best practice is to follow the naming convention pattern of organization . domain (followed by subdomains if necessary). The tooling will not allow for duplicate namespaces. (Note: While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens) File Description The Description keyword provides the user the ability to define the purpose of the file, within the confines of a project. Keyword Example Description Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" The namespace description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. (NOTE: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.) Uses The Uses keyword provides a list of the namespaces used within the current namespace. Namespace inclusion allows you to use DataElement s and ValueSet s defined in other namespaces. Keyword Example Uses Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication In CIMPL version 5 and below, it is required that you import shr.core and shr.base for the tooling to run. (In the case of name collisions, you will have to indicidate DataElement s by their Fully Qualified Name ). The order of inclusion has no effect. Url Shorthands The Path keyword allows for abbreviations of long urls. Keyword Example Path Path: FHIR = http://hl7.org/fhir/ValueSet This functionality is completely optional, but it is provided to make authoring easier. The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter). CodeSystems The CodeSystem keyword allows for abbrevations of codesystems. In order to use code systems in a DataElement definition or constraint, it is necessary to first define them in the file header (this is largely due to the complexity of codesystems' direct code references). Keyword Example CodeSystem CodeSystem: LNC = http://loinc.org You must define each codesystem you use in separate definitions across multiple lines, e.g. CodeSystem: LNC = http://loinc.org CodeSystem: SCT = http://sct.org The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter) . Data Element File Sample Data Element File Grammar: DataElement 5.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication CodeSystem: LNC = http://loinc.org EntryElement: FinancialSituation Concept: MTH#C0516918 Based on: Panel Description: \"Measures of the ability of the subject to obtain and pay for the necessities of life.\" Value: CodeableConcept is MTH#C0516918 0..1 AnnualIncome 0..* IncomeSource PanelCode is LNC#83335-0 Element Name Declaration The Element keyword allows users to define the name of the element and the lines following the Element keyword comprise the definition of that element. Keyword Example Element Element: Observation EntryElement EntryElement: FinancialSituation Abstract Element Abstract Element: Any Note the spacing discrepancy between EntryElement and Abstract Element . This has no semantic meaning but is inherent to the syntax. These keywords are used to define data elements with three different levels of expression in the target output: * EntryElement is used to define elements that will be used directly by the target output, i.e., data will be entered directly into this item by and end user once it has been mapped. For FHIR exports, these items will be created as 'Primary Profiles' * Element is used to define supporting data elements for EntryElement s. These data elements will be present in the target output as, but they are not the top-level items that are exported. For FHIR exports, these items will be created as 'Supporting Profiles'. * Abstract Element is used to define elements that are used only within the CIMPL mapping to create basic objects that will be leveraged by other data elements. They will not be present in the target mapping. Fully Qualified Names In addition to its declared name, all elements also have a unique identifying Fully Qualified Name ( FQN ). The FQN is a combination of the element's namespace and its declared name (through concatention delimited by a period). For example, the element Observation in the namespace shr.finding has the following FQN: shr.finding.Observation Note: While rare and considered bad practice, naming collisions between elements across multiple namespaces is possible. In the case of a naming collision (such as when a namespace Uses multiple namespaces that define an element with the same declared name), you would have to refer to the specific unique FQN instead of the declared name in element, field, and value definitions. Concept Code The Concept keyword is used to define the concept code for the element. These are numerical codes that identify clinical terms, primitive or defined, organized in hierarchies. Keyword Example Concept Concept: MTH#C0516918 Concept codes for the meaning of the defined structure (SNOMED CT and LOINC codes, as an example). While optional, it is recommended you define the concept of an element. To see how it relates to FHIR output, see StructureDefinition.keyword . Inheritance Provides the parent element from which the properties are inherited. This works similar to class inheritance in object orientated programming. Additionally, mappings are inherited alongside properties. Keyword Example Based on Based on: Panel Multiple inheritance is currently removed from CIMPL support. Selective inheritance is achievable through 'zeroing out' inherited properties. See Cardinality Description The textual description of the element. Keyword Example Description Description: \"Measures of the ability of the...\" The element description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. To see how it relates to FHIR output, see StructureDefinition.description . (NOTE: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.) Fields Value Defines what the element is. You are allowed to declare a value to be either a primitive or a DataElement. Keyword Example Value Value: CodeableConcept Value: string Value is an optional special field on an element that correspond more heavily to what the element is . You are also allowed to constrain the value similar to other fields. On the mapping side, you are able to map the value like any other field. Value defaults to a cardinality of 1..1 , but this can be changed, e.g.: Value: 0..1 Quantity Primitives CIMPL allows users to define fields as the following primitive data types: * boolean * integer * string * decimal * uri * base64Binary * instant * date * dateTime * time * code * oid * id * markdown * unsignedInt * positiveInt * xhtml Field Object properties on the element. Keyword Example 0..1 AnnualIncome In most cases, you refer to an element by its name. In the rare case of a naming collision, you must refer to it by its Fully Qualified Name . Inherited Field Object properties on the element inherited from the parent or other elements. Keyword Example PanelCode is LNC#83335-0 Inherited Value Object value on the element inherited from the parent or other elements. Keyword Example Value Value is MTH#C0516918 The Value keyword can be used identically to an Inherited Field . References In order to refer to an element as a class (i.e. a pointer as opposed to an instance), you can encapsulate the element name using ref() . This is helpful for defining complex objects with child elements that are already defined as parts of existing data elements. Keyword Example ref() 1..1 ref(Role) ref() 0..1 PartOf value is type ref(Organization) ref() Value: ref(Finding) ref() Value: 0..* ref(Observation) The ref(...) syntax should only encapsulate the element name. All other fields should be applied normally to the group. ref() can be used to specify that a reference is either the child element of a data element (e.g., 1..1 ref(Role) ) or the Value of an existing child element (e.g., 0..1 PartOf value is type ref(Organization) ). Field Constraints Fields can be constrained to further specify their acceptable values using cardinalities and keywords, e.g.: * is * is type * from * includes No Constraint Fields can exist without any constraints. They can also be constrained to a data type (or set of data types) without further constraining the possible values within that data type. Keyword Example 0..1 GeopoliticalLocation Value: CodeableConcept or Value: unsignedInt or positiveInt Cardinality Cardinality defines the number of instances should exist for a value. The first digit indicates the minimum quantity, and additionally by setting it to 0 or to 1 , has the effect of making a field optional or required. The second digit expresses the upper bound. To express no upper bound, a * can be used in place of a number. When constraining an inherited field, you can only retain the previous cardinality, or constrain it to be narrower. Note: By constraining it to 0..0, you can remove an inherited field from an element. Keyword Example 0..* LanguageUsed 1..2 GovernmentIssuedID Fixed Value The is keyword limits the field to a specifc value (e.g., a code , a specific string , or a boolean value). Keyword Example is ObservationCode is LNC#82810-3 Note: The is keyword locks the code for all instances of the data element. If you only need to lock the code for one particular mapping, do so using the fix keyword in the mapping file. Type The is type keywords limits the data type of a field to a previously defined element. Keyword Example is type Quantity is type DollarAmount Use case: If we have an abstract element, and we are making a more specific version of that element, we also want to make its fields more specific. For instance, if we have a DataElement Person which has a field Pet , and we making a more specific person DogOwner and we want to further specify its pet. In this case, we could constrain Pet is type Dog . Value Set The from keyword limits the value of a field to be from a specific value set, with different levels of requirement. Keyword Example Binding Strength from Substance from SubstanceOfAbuseVS Required must be Priority must be from http://hl7.org/fhir/ValueSet/request-priority Required should be 1..1 Status should be from http://hl7.org/fhir/ValueSet/event-status Preferred could be CodeableConcept could be from http://hl7.org/fhir/ValueSet/medication-as-needed-reason Example if covered Category from http://hl7.org/fhir/ValueSet/goal-category if covered Extensible The binding strengths correspond to FHIR binding strengths and have the same meaning: * Required: To be conformant, the concept in this element SHALL be from the specified value set * Preferred: Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant. * Example: Instances are not expected or even encouraged to draw from the specified value set. The value set merely provides examples of the types of concepts intended to be included. * Extensible: To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated. If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead. Includes Code For fields that are already defined with a data type of code , the includes keyword expands the allowable entries for that field. Keyword Example includes Category includes LNC#54511-1 \"Behavior\" includes ProblemCategory includes #adverse_reaction The first example above expands Category to include 54511-1 from the LOINC codesystem. Additionally, it is given a brief textual description of \"Behavior\" . The second example above expands the allowable codes in ProblemCategory to include #adverse_reaction . Unlike the first example, the value set does not precede the code, because it has defined on ProblemCategory 's parent using a from statement. Additionally, there is no textual description, as that is optional. Includes Type Specifies the quantity of particular types of objects within the value. Keyword Example includes Foo includes 1..1 PhysicalActivityLevel This is useful in further specifying fields that are analagous to lists. In the above example, the field Foo is required to include 1 PhysicalActivityLevel . To add more inclusions, simply add more includes statements on Foo . For example, a blood pressure panel can include any number of tests, but we assume that at least one of those tests will be systolic pressure and another will be diastolic pressure: Element: VitalSign 1..* BloodPressurePanel includes 1..1 SystolicPressure includes 1..1 DiastolicPressure Note: The collective cardinality of all inclusions must fit within the field, i.e. if you are including 3 distinct elements, then the field must have a maximum cardinality greater than 3 (like * ). Map File By default, new elements will appear as FHIR extensions unless the element is mapped to an existing FHIR element. These mapping allow for simpler slicing and fixed values. Sample Map File Grammar: Map 5.0 Namespace: shr.allergy Target: FHIR_STU_3 Condition maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-condition: RelatedEncounter maps to context Informant maps to asserter Subject maps to subject Entry.CreationTime maps to assertedDate Value maps to code Category maps to category ClinicalStatus maps to clinicalStatus Onset maps to onset[x] Abatement maps to abatement[x] BodySiteOrCode[CodeableConcept] maps to bodySite BodySiteOrCode[BodySite] maps to http://hl7.org/fhir/StructureDefinition/body-structure Severity maps to severity Stage maps to stage Stage.Value maps to stage.summary Evidence maps to evidence Element Mapping Maps a CIMPL element to a target element. Keyword Example maps to FinancialSituation maps to DiagnosticResult: FinancialSituation: In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. If no FHIR mapping is defined for an element and it inherits no mappings from its parents, it defaults to a mapping to the Basic resource . In general, this is not recommended because it has no inherent semantic meaning for implementers. To promote interoperability and reuse, CIMPL modelers are encouraged to find target models that already exist and use constraints or extensions to modify them according to project needs. Field Mapping Maps a CIMPL element field to a target field. Keyword Example maps to MaritalStatus maps to maritalStatus maps to Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity maps to MultipleBirth maps to multipleBirth[x].boolean maps to Value.ActiveFlag maps to active maps to AdverseReaction.AllergenIrritant maps to reaction.substance maps to BodySiteOrCode[CodeableConcept] maps to bodySite In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. With FHIR as the target output, the right-hand side of the map statement can point to any field on a FHIR resource, including: * Fields that are at the root of the resource (e.g., maritalStatus ) * Fields that are child elements of root elements on the resource (e.g., reaction.substance ) * Fields that have a choice of data types (e.g., multipleBirth[x].boolean ) * Fields that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity ) Fix Similar to the is keyword, the fix keyword allows for FHIR fields to be locked to a certain value. It is helpful for locking field values in specific mappings (instead of in the DataElement definition, which would be locked for all potential mappings). Keyword Example fix fix status to #completed Note about syntax: The element being fixed on left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any code or primitive value to be fixed. Constrain The constrain keyword allows users to constrain the cardinality of elements in output files. Keyword Example constrain constrain explanation to 0..1 Note about syntax: The element being fixed on the left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any cardinality . Slicing When fields are allowed to repeat on a target model (e.g., have cardinality with an upper bound greater than 1), it is common practice to specify which CIMPL elements are mapped to instances of that repeated field on the target model. This process is called slicing . For example, the FHIR Task resource allows for an arbitrary number of input fields to be added. To ensure that all each of the input fields is uniquely addressable by a parsing engine, those inputs need to be differentiated by a discriminator . See the FHIR documentation for more detail about slicing and discriminators TODO: Add a slicing example to the sample map file Declaring a Discriminator To perform any slicing, a discriminator needs to be declared, using slice on followed by the discriminator. Keyword Example slice on Laterality maps to qualifier (slice on = coding.code) slice on type TODO CIMPL supports the FHIR processing types for discriminators: | Discriminator | Definition | | ------------- | ---------- | | value | The slices have different values in the nominated element| | exists | The slices are differentiated by the presence or absence of the nominated element| | pattern | The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x]| | type |The slices are differentiated by type of the nominated element to a specifed profile| | profile | The slices are differentiated by conformance of the nominated element to a specifed profile| Moving the Slice Location If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Keyword Example slice at Members.Observation maps to related.target (slice at = related; slice on type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occuring at related.target . Instead, the slice at = related ensures that the slicing is occuring at the related element. Slicing Strategies TODO: What does this do and when should it be used? Keyword Example slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) * TODO: What is the syntax? What are the allowable options? * TODO: find or create a less complex example Value Set File The value set files are used to define custom value sets and codes when existing sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient. Sample Value Set File Grammar: ValueSet 5.0 Namespace: shr.base ValueSet: ValueAbsentReasonVS Description: \"Reasons that a value associated with a test or other finding is missing.\" Includes codes from DAR #missing_refused \"Human source was asked but declined to respond to the question, or an applicable question was left unanswered.\" #missing_noexplanation \"The reason the information is not present is not known.\" #missing_nonesuch \"The answer is missing because nothing of a type of thing is known to exists, e.g., the siblings of an only child. Also use this code to represent a 'none of the above' answer\" #missing_collection \"Missing due to a problem collecting, identifying, or locating the specimen, including patient refusal or unable to provide specimen\" #missing_specimen \"Missing due to a problem with the specimen, e.g. contamination, clotting, improper tube type, improper storage, too small, etc.\" #missing_malfunction \"Missing due to instrument malfunction.\" Value Set Declaration Defines the name of the value set. Keyword Example ValueSet ValueSet: ProposedStatusVS By convention, all value sets should be Pascal case and end with VS . Value Set Description Defines the name of the value set. Keyword Example Description Description: \"The status of a proposal.\" Code-Value Declaration Define the code or value. Keyword Example #proposed \"The proposal has been proposed, but not accepted or rejected.\" CAP#29915 \"None/Negative\" Each value is prefaced by a hash symbol ( # ) and followed by a description enclosed in quotation marks. By convention, each value should use lowercase snake_case formatting . This can either be a new user defined code , or it can be individual codes from separate codesystems, such as the CAP#29915 example, in which 29915 is an existing code within the CAP codesystem. Includes Extends a custom defined ValueSet to include codes from other codesystems. Keyword Example Includes Includes codes from MDR Includes and descending from Includes codes descending from SCT#105590001 Includes and descending from and and not descending from Includes codes descending from SCT#105590001 \"Substance\" and not descending from SCT#410942007 \"Drug or medicament\" You are allowed to include from either a codesystem or a specific code from a codesystem. TODO: explain what descending from and and not descending from actually do with some kind of example. FHIR Examples File To include examples in an IG, you must do the following: Create a fhir_examples folder in the same folder as your CIMPL text files Put the JSON examples inside the fhir_examples folder. For each file: name the file as you wish, but we recommend my_example_id.json (e.g., bc-presence.json in the example, ensure there is a value for the id (e.g., \"id\": \"PatientExample01\" ) Within the example, ensure the meta.profile is set to the profile for the example (e.g., \"meta\": { \"profile\": [ \"http://hl7.org/fhir/us/shr/StructureDefinition/shr-core-Patient\" ] } )","title":"CIMPL 5.0 Reference Documentation"},{"location":"cimpl5Reference/#cimpl-50-reference-documentation","text":"This is a comprehensive guide to CIMPL 5.0 syntax. The latest release is CIMPL 6.0. This documentation is provided for historical purposes. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial .","title":"CIMPL 5.0 Reference Documentation"},{"location":"cimpl5Reference/#table-of-contents","text":"1. General Overview * 1.1 Whitespace * 1.2 Naming Conventions * 1.3 Ordinality * 1.4 Naming Collisions * 1.5 Versioning * 1.6 Comments 2. File Headers * 2.1 Sample File Header * 2.2 Grammar * 2.3 Namespace Declaration * 2.4 File Description * 2.5 Uses * 2.6 Url Shorthands * 2.7 CodeSystems 3. Data Element File * 3.1 Sample Data Element File * 3.2 Element Name Declaration * 3.3 Concept Code * 3.4 Inheritance * 3.5 Description * 3.6 Fields * 3.6.1 Value * 3.6.2 Primitives * 3.6.3 Field * 3.6.4 Inherited Field * 3.6.5 References * 3.7 Field Constraints * 3.7.1 No Constraint * 3.7.2 Cardinality * 3.7.3 Fixed Value * 3.7.4 Type * 3.7.5 Value Set * 3.7.6 Includes Code * 3.7.7 Includes Type 4. Map File * 4.1 Sample Map File * 4.2 Element Mapping * 4.3 Field Mapping * 4.4 Fix * 4.5 Constrain * 4.6 Slicing * 4.6.1 Declaring a Discriminator * 4.6.2 Moving the Slice Location * 4.6.3 Slice Strategies 5. Value Set File * 5.1 Sample Value Set File * 5.2 Value Set Declaration * 5.3 Value Set Description * 5.4 Code-Value Declaration 6. FHIR Examples File 7. Future Architectural Considerations","title":"Table of Contents"},{"location":"cimpl5Reference/#general-overview","text":"CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and declarative, with tools to produce FHIR Profiles, FHIR Implementation Guides, data dictionaries, and other assets.","title":"General Overview"},{"location":"cimpl5Reference/#whitespace","text":"Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 5.0 Namespace: shr.core ...is equivalent to this: Grammar: DataElement 5.0 Namespace: shr.core","title":"Whitespace"},{"location":"cimpl5Reference/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"cimpl5Reference/#file-names","text":"Data Element files: namespace.txt Value Set files: namespace_vs.txt Mapping files: namespace_map.txt Note: any periods in the namespace should be replaced by underscores","title":"File names"},{"location":"cimpl5Reference/#namespaces","text":"A namespace conventionally is denominated by the authoring organization and the broad category of elements the namespace defines, delineated by a period. For example: Namespace: shr.oncology Note: The organization name is recommended but not required (e.g., Namespace: oncology is also allowed).","title":"Namespaces"},{"location":"cimpl5Reference/#elements","text":"Elements are conventionally defined in PascalCase . For example: Element: GeologicalLocation Note: Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter.","title":"Elements"},{"location":"cimpl5Reference/#value-sets","text":"Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: It is required that an Value Set name begins with an uppercase letter.","title":"Value Sets"},{"location":"cimpl5Reference/#code-sets","text":"Within a custom value set, the individual codes are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or other radiation source\" #swimming_pool \"Swimming Pool\"","title":"Code Sets"},{"location":"cimpl5Reference/#ordinality","text":"CIMPL does not enforce or require ordinality in any of its definitions, i.e. an element defined at the bottom of the file can be used as field on an element defined at the top. There is, however, a requirement for a file's header information to be at the top of the file, before any definitions. See: File Headers for more information","title":"Ordinality"},{"location":"cimpl5Reference/#naming-collisions","text":"CIMPL does not support duplicate element names within a namespace. However, you are allowed to reuse an element name across different namespaces. In the case that you come across a collision due to an included namespace in Uses , you have to refer to the element by its Fully Qualified Name .","title":"Naming Collisions"},{"location":"cimpl5Reference/#versioning","text":"CIMPL follows the Semantic Versioning convention (MAJOR.MINOR.PATCH). MAJOR: A breaking change. This is reserved for drastic grammar overhauls. Does not support backwards compatibility to other major version releases. MINOR: Feature updates. Allows for backwards compatability within the major version. PATCH: Minor updates and bug fixes. Allows for backwards compatability within the major version. CIMPL is currently on major version 5. For a full changelog, see the Release Notes .","title":"Versioning"},{"location":"cimpl5Reference/#comments","text":"CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */","title":"Comments"},{"location":"cimpl5Reference/#file-headers","text":"Each CIMPL file contains header information that describes the file type, its scope and inheritance, and its purpose. It also allows developers to create aliases for urls and code systems.","title":"File Headers"},{"location":"cimpl5Reference/#sample-file-header","text":"Grammar: DataElement 5.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication CodeSystem: LNC = http://loinc.org","title":"Sample File Header"},{"location":"cimpl5Reference/#grammar","text":"The Grammar keyword is used to define the file type and the version of CIMPL used in development/parsing. This is required for all CIMPL files. Keyword Example Grammar Grammar: DataElement 5.0 Grammar Grammar: ValueSet 5.0 Grammar Grammar: Map 5.0 There are three possible options for file type: 1. DataElement 2. ValueSet 3. Mapping The version details the MAJOR and MINOR version the file was written for. The language is backwards compatibile within the MAJOR version number, i.e. DataElement 5.0 files will compile without problems on the 5.9.0 tooling. For more information, see Versioning .","title":"Grammar"},{"location":"cimpl5Reference/#namespace-declaration","text":"The Namespace keyword defines the scope of the file and serves as a broad grouping of DataElement , ValueSet and Map files within a domain. Keyword Example Namespace Namespace: shr.environment The namespace can be any number of lowercase period delimited words. Best practice is to follow the naming convention pattern of organization . domain (followed by subdomains if necessary). The tooling will not allow for duplicate namespaces. (Note: While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens)","title":"Namespace Declaration"},{"location":"cimpl5Reference/#file-description","text":"The Description keyword provides the user the ability to define the purpose of the file, within the confines of a project. Keyword Example Description Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" The namespace description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. (NOTE: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.)","title":"File Description"},{"location":"cimpl5Reference/#uses","text":"The Uses keyword provides a list of the namespaces used within the current namespace. Namespace inclusion allows you to use DataElement s and ValueSet s defined in other namespaces. Keyword Example Uses Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication In CIMPL version 5 and below, it is required that you import shr.core and shr.base for the tooling to run. (In the case of name collisions, you will have to indicidate DataElement s by their Fully Qualified Name ). The order of inclusion has no effect.","title":"Uses"},{"location":"cimpl5Reference/#url-shorthands","text":"The Path keyword allows for abbreviations of long urls. Keyword Example Path Path: FHIR = http://hl7.org/fhir/ValueSet This functionality is completely optional, but it is provided to make authoring easier. The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter).","title":"Url Shorthands"},{"location":"cimpl5Reference/#codesystems","text":"The CodeSystem keyword allows for abbrevations of codesystems. In order to use code systems in a DataElement definition or constraint, it is necessary to first define them in the file header (this is largely due to the complexity of codesystems' direct code references). Keyword Example CodeSystem CodeSystem: LNC = http://loinc.org You must define each codesystem you use in separate definitions across multiple lines, e.g. CodeSystem: LNC = http://loinc.org CodeSystem: SCT = http://sct.org The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter) .","title":"CodeSystems"},{"location":"cimpl5Reference/#data-element-file","text":"","title":"Data Element File"},{"location":"cimpl5Reference/#sample-data-element-file","text":"Grammar: DataElement 5.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication CodeSystem: LNC = http://loinc.org EntryElement: FinancialSituation Concept: MTH#C0516918 Based on: Panel Description: \"Measures of the ability of the subject to obtain and pay for the necessities of life.\" Value: CodeableConcept is MTH#C0516918 0..1 AnnualIncome 0..* IncomeSource PanelCode is LNC#83335-0","title":"Sample Data Element File"},{"location":"cimpl5Reference/#element-name-declaration","text":"The Element keyword allows users to define the name of the element and the lines following the Element keyword comprise the definition of that element. Keyword Example Element Element: Observation EntryElement EntryElement: FinancialSituation Abstract Element Abstract Element: Any Note the spacing discrepancy between EntryElement and Abstract Element . This has no semantic meaning but is inherent to the syntax. These keywords are used to define data elements with three different levels of expression in the target output: * EntryElement is used to define elements that will be used directly by the target output, i.e., data will be entered directly into this item by and end user once it has been mapped. For FHIR exports, these items will be created as 'Primary Profiles' * Element is used to define supporting data elements for EntryElement s. These data elements will be present in the target output as, but they are not the top-level items that are exported. For FHIR exports, these items will be created as 'Supporting Profiles'. * Abstract Element is used to define elements that are used only within the CIMPL mapping to create basic objects that will be leveraged by other data elements. They will not be present in the target mapping.","title":"Element Name Declaration"},{"location":"cimpl5Reference/#fully-qualified-names","text":"In addition to its declared name, all elements also have a unique identifying Fully Qualified Name ( FQN ). The FQN is a combination of the element's namespace and its declared name (through concatention delimited by a period). For example, the element Observation in the namespace shr.finding has the following FQN: shr.finding.Observation Note: While rare and considered bad practice, naming collisions between elements across multiple namespaces is possible. In the case of a naming collision (such as when a namespace Uses multiple namespaces that define an element with the same declared name), you would have to refer to the specific unique FQN instead of the declared name in element, field, and value definitions.","title":"Fully Qualified Names"},{"location":"cimpl5Reference/#concept-code","text":"The Concept keyword is used to define the concept code for the element. These are numerical codes that identify clinical terms, primitive or defined, organized in hierarchies. Keyword Example Concept Concept: MTH#C0516918 Concept codes for the meaning of the defined structure (SNOMED CT and LOINC codes, as an example). While optional, it is recommended you define the concept of an element. To see how it relates to FHIR output, see StructureDefinition.keyword .","title":"Concept Code"},{"location":"cimpl5Reference/#inheritance","text":"Provides the parent element from which the properties are inherited. This works similar to class inheritance in object orientated programming. Additionally, mappings are inherited alongside properties. Keyword Example Based on Based on: Panel Multiple inheritance is currently removed from CIMPL support. Selective inheritance is achievable through 'zeroing out' inherited properties. See Cardinality","title":"Inheritance"},{"location":"cimpl5Reference/#description","text":"The textual description of the element. Keyword Example Description Description: \"Measures of the ability of the...\" The element description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. To see how it relates to FHIR output, see StructureDefinition.description . (NOTE: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.)","title":"Description"},{"location":"cimpl5Reference/#fields","text":"","title":"Fields"},{"location":"cimpl5Reference/#value","text":"Defines what the element is. You are allowed to declare a value to be either a primitive or a DataElement. Keyword Example Value Value: CodeableConcept Value: string Value is an optional special field on an element that correspond more heavily to what the element is . You are also allowed to constrain the value similar to other fields. On the mapping side, you are able to map the value like any other field. Value defaults to a cardinality of 1..1 , but this can be changed, e.g.: Value: 0..1 Quantity","title":"Value"},{"location":"cimpl5Reference/#primitives","text":"CIMPL allows users to define fields as the following primitive data types: * boolean * integer * string * decimal * uri * base64Binary * instant * date * dateTime * time * code * oid * id * markdown * unsignedInt * positiveInt * xhtml","title":"Primitives"},{"location":"cimpl5Reference/#field","text":"Object properties on the element. Keyword Example 0..1 AnnualIncome In most cases, you refer to an element by its name. In the rare case of a naming collision, you must refer to it by its Fully Qualified Name .","title":"Field"},{"location":"cimpl5Reference/#inherited-field","text":"Object properties on the element inherited from the parent or other elements. Keyword Example PanelCode is LNC#83335-0","title":"Inherited Field"},{"location":"cimpl5Reference/#inherited-value","text":"Object value on the element inherited from the parent or other elements. Keyword Example Value Value is MTH#C0516918 The Value keyword can be used identically to an Inherited Field .","title":"Inherited Value"},{"location":"cimpl5Reference/#references","text":"In order to refer to an element as a class (i.e. a pointer as opposed to an instance), you can encapsulate the element name using ref() . This is helpful for defining complex objects with child elements that are already defined as parts of existing data elements. Keyword Example ref() 1..1 ref(Role) ref() 0..1 PartOf value is type ref(Organization) ref() Value: ref(Finding) ref() Value: 0..* ref(Observation) The ref(...) syntax should only encapsulate the element name. All other fields should be applied normally to the group. ref() can be used to specify that a reference is either the child element of a data element (e.g., 1..1 ref(Role) ) or the Value of an existing child element (e.g., 0..1 PartOf value is type ref(Organization) ).","title":"References"},{"location":"cimpl5Reference/#field-constraints","text":"Fields can be constrained to further specify their acceptable values using cardinalities and keywords, e.g.: * is * is type * from * includes","title":"Field Constraints"},{"location":"cimpl5Reference/#no-constraint","text":"Fields can exist without any constraints. They can also be constrained to a data type (or set of data types) without further constraining the possible values within that data type. Keyword Example 0..1 GeopoliticalLocation Value: CodeableConcept or Value: unsignedInt or positiveInt","title":"No Constraint"},{"location":"cimpl5Reference/#cardinality","text":"Cardinality defines the number of instances should exist for a value. The first digit indicates the minimum quantity, and additionally by setting it to 0 or to 1 , has the effect of making a field optional or required. The second digit expresses the upper bound. To express no upper bound, a * can be used in place of a number. When constraining an inherited field, you can only retain the previous cardinality, or constrain it to be narrower. Note: By constraining it to 0..0, you can remove an inherited field from an element. Keyword Example 0..* LanguageUsed 1..2 GovernmentIssuedID","title":"Cardinality"},{"location":"cimpl5Reference/#fixed-value","text":"The is keyword limits the field to a specifc value (e.g., a code , a specific string , or a boolean value). Keyword Example is ObservationCode is LNC#82810-3 Note: The is keyword locks the code for all instances of the data element. If you only need to lock the code for one particular mapping, do so using the fix keyword in the mapping file.","title":"Fixed Value"},{"location":"cimpl5Reference/#type","text":"The is type keywords limits the data type of a field to a previously defined element. Keyword Example is type Quantity is type DollarAmount Use case: If we have an abstract element, and we are making a more specific version of that element, we also want to make its fields more specific. For instance, if we have a DataElement Person which has a field Pet , and we making a more specific person DogOwner and we want to further specify its pet. In this case, we could constrain Pet is type Dog .","title":"Type"},{"location":"cimpl5Reference/#value-set","text":"The from keyword limits the value of a field to be from a specific value set, with different levels of requirement. Keyword Example Binding Strength from Substance from SubstanceOfAbuseVS Required must be Priority must be from http://hl7.org/fhir/ValueSet/request-priority Required should be 1..1 Status should be from http://hl7.org/fhir/ValueSet/event-status Preferred could be CodeableConcept could be from http://hl7.org/fhir/ValueSet/medication-as-needed-reason Example if covered Category from http://hl7.org/fhir/ValueSet/goal-category if covered Extensible The binding strengths correspond to FHIR binding strengths and have the same meaning: * Required: To be conformant, the concept in this element SHALL be from the specified value set * Preferred: Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant. * Example: Instances are not expected or even encouraged to draw from the specified value set. The value set merely provides examples of the types of concepts intended to be included. * Extensible: To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated. If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead.","title":"Value Set"},{"location":"cimpl5Reference/#includes-code","text":"For fields that are already defined with a data type of code , the includes keyword expands the allowable entries for that field. Keyword Example includes Category includes LNC#54511-1 \"Behavior\" includes ProblemCategory includes #adverse_reaction The first example above expands Category to include 54511-1 from the LOINC codesystem. Additionally, it is given a brief textual description of \"Behavior\" . The second example above expands the allowable codes in ProblemCategory to include #adverse_reaction . Unlike the first example, the value set does not precede the code, because it has defined on ProblemCategory 's parent using a from statement. Additionally, there is no textual description, as that is optional.","title":"Includes Code"},{"location":"cimpl5Reference/#includes-type","text":"Specifies the quantity of particular types of objects within the value. Keyword Example includes Foo includes 1..1 PhysicalActivityLevel This is useful in further specifying fields that are analagous to lists. In the above example, the field Foo is required to include 1 PhysicalActivityLevel . To add more inclusions, simply add more includes statements on Foo . For example, a blood pressure panel can include any number of tests, but we assume that at least one of those tests will be systolic pressure and another will be diastolic pressure: Element: VitalSign 1..* BloodPressurePanel includes 1..1 SystolicPressure includes 1..1 DiastolicPressure Note: The collective cardinality of all inclusions must fit within the field, i.e. if you are including 3 distinct elements, then the field must have a maximum cardinality greater than 3 (like * ).","title":"Includes Type"},{"location":"cimpl5Reference/#map-file","text":"By default, new elements will appear as FHIR extensions unless the element is mapped to an existing FHIR element. These mapping allow for simpler slicing and fixed values.","title":"Map File"},{"location":"cimpl5Reference/#sample-map-file","text":"Grammar: Map 5.0 Namespace: shr.allergy Target: FHIR_STU_3 Condition maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-condition: RelatedEncounter maps to context Informant maps to asserter Subject maps to subject Entry.CreationTime maps to assertedDate Value maps to code Category maps to category ClinicalStatus maps to clinicalStatus Onset maps to onset[x] Abatement maps to abatement[x] BodySiteOrCode[CodeableConcept] maps to bodySite BodySiteOrCode[BodySite] maps to http://hl7.org/fhir/StructureDefinition/body-structure Severity maps to severity Stage maps to stage Stage.Value maps to stage.summary Evidence maps to evidence","title":"Sample Map File"},{"location":"cimpl5Reference/#element-mapping","text":"Maps a CIMPL element to a target element. Keyword Example maps to FinancialSituation maps to DiagnosticResult: FinancialSituation: In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. If no FHIR mapping is defined for an element and it inherits no mappings from its parents, it defaults to a mapping to the Basic resource . In general, this is not recommended because it has no inherent semantic meaning for implementers. To promote interoperability and reuse, CIMPL modelers are encouraged to find target models that already exist and use constraints or extensions to modify them according to project needs.","title":"Element Mapping"},{"location":"cimpl5Reference/#field-mapping","text":"Maps a CIMPL element field to a target field. Keyword Example maps to MaritalStatus maps to maritalStatus maps to Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity maps to MultipleBirth maps to multipleBirth[x].boolean maps to Value.ActiveFlag maps to active maps to AdverseReaction.AllergenIrritant maps to reaction.substance maps to BodySiteOrCode[CodeableConcept] maps to bodySite In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. With FHIR as the target output, the right-hand side of the map statement can point to any field on a FHIR resource, including: * Fields that are at the root of the resource (e.g., maritalStatus ) * Fields that are child elements of root elements on the resource (e.g., reaction.substance ) * Fields that have a choice of data types (e.g., multipleBirth[x].boolean ) * Fields that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity )","title":"Field Mapping"},{"location":"cimpl5Reference/#fix","text":"Similar to the is keyword, the fix keyword allows for FHIR fields to be locked to a certain value. It is helpful for locking field values in specific mappings (instead of in the DataElement definition, which would be locked for all potential mappings). Keyword Example fix fix status to #completed Note about syntax: The element being fixed on left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any code or primitive value to be fixed.","title":"Fix"},{"location":"cimpl5Reference/#constrain","text":"The constrain keyword allows users to constrain the cardinality of elements in output files. Keyword Example constrain constrain explanation to 0..1 Note about syntax: The element being fixed on the left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any cardinality .","title":"Constrain"},{"location":"cimpl5Reference/#slicing","text":"When fields are allowed to repeat on a target model (e.g., have cardinality with an upper bound greater than 1), it is common practice to specify which CIMPL elements are mapped to instances of that repeated field on the target model. This process is called slicing . For example, the FHIR Task resource allows for an arbitrary number of input fields to be added. To ensure that all each of the input fields is uniquely addressable by a parsing engine, those inputs need to be differentiated by a discriminator . See the FHIR documentation for more detail about slicing and discriminators TODO: Add a slicing example to the sample map file","title":"Slicing"},{"location":"cimpl5Reference/#declaring-a-discriminator","text":"To perform any slicing, a discriminator needs to be declared, using slice on followed by the discriminator. Keyword Example slice on Laterality maps to qualifier (slice on = coding.code) slice on type TODO CIMPL supports the FHIR processing types for discriminators: | Discriminator | Definition | | ------------- | ---------- | | value | The slices have different values in the nominated element| | exists | The slices are differentiated by the presence or absence of the nominated element| | pattern | The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x]| | type |The slices are differentiated by type of the nominated element to a specifed profile| | profile | The slices are differentiated by conformance of the nominated element to a specifed profile|","title":"Declaring a Discriminator"},{"location":"cimpl5Reference/#moving-the-slice-location","text":"If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Keyword Example slice at Members.Observation maps to related.target (slice at = related; slice on type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occuring at related.target . Instead, the slice at = related ensures that the slicing is occuring at the related element.","title":"Moving the Slice Location"},{"location":"cimpl5Reference/#slicing-strategies","text":"TODO: What does this do and when should it be used? Keyword Example slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) * TODO: What is the syntax? What are the allowable options? * TODO: find or create a less complex example","title":"Slicing Strategies"},{"location":"cimpl5Reference/#value-set-file","text":"The value set files are used to define custom value sets and codes when existing sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient.","title":"Value Set File"},{"location":"cimpl5Reference/#sample-value-set-file","text":"Grammar: ValueSet 5.0 Namespace: shr.base ValueSet: ValueAbsentReasonVS Description: \"Reasons that a value associated with a test or other finding is missing.\" Includes codes from DAR #missing_refused \"Human source was asked but declined to respond to the question, or an applicable question was left unanswered.\" #missing_noexplanation \"The reason the information is not present is not known.\" #missing_nonesuch \"The answer is missing because nothing of a type of thing is known to exists, e.g., the siblings of an only child. Also use this code to represent a 'none of the above' answer\" #missing_collection \"Missing due to a problem collecting, identifying, or locating the specimen, including patient refusal or unable to provide specimen\" #missing_specimen \"Missing due to a problem with the specimen, e.g. contamination, clotting, improper tube type, improper storage, too small, etc.\" #missing_malfunction \"Missing due to instrument malfunction.\"","title":"Sample Value Set File"},{"location":"cimpl5Reference/#value-set-declaration","text":"Defines the name of the value set. Keyword Example ValueSet ValueSet: ProposedStatusVS By convention, all value sets should be Pascal case and end with VS .","title":"Value Set Declaration"},{"location":"cimpl5Reference/#value-set-description","text":"Defines the name of the value set. Keyword Example Description Description: \"The status of a proposal.\"","title":"Value Set Description"},{"location":"cimpl5Reference/#code-value-declaration","text":"Define the code or value. Keyword Example #proposed \"The proposal has been proposed, but not accepted or rejected.\" CAP#29915 \"None/Negative\" Each value is prefaced by a hash symbol ( # ) and followed by a description enclosed in quotation marks. By convention, each value should use lowercase snake_case formatting . This can either be a new user defined code , or it can be individual codes from separate codesystems, such as the CAP#29915 example, in which 29915 is an existing code within the CAP codesystem.","title":"Code-Value Declaration"},{"location":"cimpl5Reference/#includes","text":"Extends a custom defined ValueSet to include codes from other codesystems. Keyword Example Includes Includes codes from MDR Includes and descending from Includes codes descending from SCT#105590001 Includes and descending from and and not descending from Includes codes descending from SCT#105590001 \"Substance\" and not descending from SCT#410942007 \"Drug or medicament\" You are allowed to include from either a codesystem or a specific code from a codesystem. TODO: explain what descending from and and not descending from actually do with some kind of example.","title":"Includes"},{"location":"cimpl5Reference/#fhir-examples-file","text":"To include examples in an IG, you must do the following: Create a fhir_examples folder in the same folder as your CIMPL text files Put the JSON examples inside the fhir_examples folder. For each file: name the file as you wish, but we recommend my_example_id.json (e.g., bc-presence.json in the example, ensure there is a value for the id (e.g., \"id\": \"PatientExample01\" ) Within the example, ensure the meta.profile is set to the profile for the example (e.g., \"meta\": { \"profile\": [ \"http://hl7.org/fhir/us/shr/StructureDefinition/shr-core-Patient\" ] } )","title":"FHIR Examples File"},{"location":"cimpl5Tutorial/","text":"CIMPL 5.0 Tutorial This is an extensive tutorial, meant to educate people about many different aspects of CIMPL. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL documentation . Table of Contents CIMPL 5.0 Tutorial Table of Contents Background Why use a modeling tool? Data Elements, Maps, and Value Sets Building Your First Data Model CIMPL Environment Setup Data Elements Header Create an Animal Value Sets Maps Command-Line Arguments Execution and Error Identification CIMPL Outputs FHIR Output Improving your First Data Model Inheritance and Constraints Element inheritance using Based on Constraints Managing Multiple Namespaces Concept Codes CodeSystem Declarations The includes Constraint Inherited Values Background This tutorial assumes that you are already comfortable with: Using a code editor (e.g., Visual Studio Code ) Using the command line on a unix-based OS (e.g., Linux, macOS) Data modeling (e.g., what separates a code from a value, what is a codeable concept) Data constraints (e.g., an element SHALL contain a specific code, another element MAY exist) Why use a modeling tool? It can be difficult for people to jump directly into resource modeling, especially for extensive, domain-specific implementations like FHIR. CIMPL is purpose-built to create clear, concise object models independent of their particular implementations. Abstraction between data models and implementations allows for cleaner code and a more repeatable and understandable process for building implementation code. Data Elements, Maps, and Value Sets CIMPL input files are either Data Elements, Maps, or Value Sets. Data Element files are the backbone of your input - they define individual data elements, whether those data elements are nested within other data elements, and the cardinalities of those data elements, among other things Map files dictate how the elements defined in your data model should be represented in a target implementation (for now, FHIR is the only output supported). Value Set files can be used to define custom codes and/or value sets for use in your data models. Building Your First Data Model Let's get started with a data model using an example. Say we've just purchased a zoo and we want to define a data model for the animal clinic at our new zoo, which could include things like: Animals Staff Facilities Medicines Food etc. CIMPL Environment Setup Before we develop any models, let's make sure our environment is set up. If you haven't already done so, follow the CIMPL Installation instructions and check that everything is working using the Hello World test. Create a directory that shares the same parent folder as your shr-cli installation and name it zoo : mkdir ~/cimpl/zoo Your directory structure should look like this: cimpl |- shr-cli |- zoo We'll need to copy some files from the SHR specification into the zoo directory to ensure that the shr-cli tool runs properly. Download the following files and place them in the zoo directory: base_map.txt base.txt core_map.txt core_vs.txt core.txt Your directory structure should now look like this: cimpl |- shr-cli |- zoo |- base_map.txt |- base.txt |- core_map.txt |- core_vs.txt |- core.txt Data Elements Header The core part of any data model is the definition of its data elements. Many modeling tools use diagrams or database tables to define their data elements, but CIMPL is defined using plain text. Create a file called zoo_animal.txt and open it. To give our zoo_animal.txt file some context, we need to include some header information. Let's start with a line that describes what the file is: Grammar: DataElement 5.0 Every CIMPL file starts by defining the Grammar . The common CIMPL files are DataElement , Map , and ValueSet . We'll get into Map and ValueSet later. This is a DataElement file that is using CIMPL version 5.0 . Next, add your file to a namespace : Grammar: DataElement 5.0 Namespace: zoo.animal The namespace allows you to define a scope for value sets, data elements, and data mappings. By convention, the namespace is period-delimited, with the project ( zoo ) preceding the specific data model that we are defining ( animal ). The filename ( zoo_animal.txt ) doesn't have to match, but it's good practice to keep the two consistent. Filenames should use underscores in place of periods to avoid confusion with file types. While we're at it, let's give this file a description: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Descriptions can include any characters (except quotation marks) and be as long as you need, but it is good practice to keep them short and simple. By default, we'll need to include some basic modeling building blocks with the uses keyword: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base Once our zoo gets more complicated, we will need to add more to the uses statement, but for now we're just including the basic building blocks that all CIMPL models would not want to redefine (e.g., Entry , Quantity , CodeSystem , etc.). Great! That's it for the DataElement file header. Create an Animal With the header information out of the way, we can start defining our first data element: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal Since we plan to map this element to some output (we'll get into mapping later), we're using the term EntryElement to describe our Animal . Eventually, this element will have data entered directly into it, thus EntryElement and not just Element . Let's add some attributes to our animal: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType We've added four separate attributes to this Animal : DateOfBirth , Name , AnimalType , and DeceasedStatus . Users familiar with traditional cardinality notation for data modeling will notice that the DateOfBirth and DeceasedStatus fields are required and can only appear once, while the AnimalType is optional and our Animal can have an arbitrary number of Name s. CIMPL doesn't know how to interpret these attributes yet, so let's define them as child Element s, starting with DateOfBirth : Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date We've defined DateOfBirth as an Element , added a short Description , and assigned a Value of date , which is one of the primitive data types that CIMPL accepts . CIMPL is whitespace-agnostic, so the indentation is not necessary, but it is good practice to indent child elements underneath their parents. Element s can get more complicated but let's leave it at that. Now that you know the basic structure of an Element , let's define Name and DeceasedStatus (as a string and boolean , respectively): Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Since we want AnimalType to be restricted to a certain set of values, we need to define a custom ValueSet file. Create a file called zoo_animal_vs.txt and open it. Value Sets Just like we did for the DataElement file, we need to define some header information for our ValueSet file: Grammar: ValueSet 5.0 Namespace: zoo.animal That's it! Since the ValueSet file is in the same namespace as our DataElement file, we don't need to add a Description or set up inheritance with a Uses statement. Start defining our AnimalType value set by giving it a name: Grammar: ValueSet 5.0 Namespace: zoo.animal ValueSet: AnimalTypeVS // These are the major classes of animal that we want to model. By convention, all value sets should be Pascal case and end with VS . You may notice that we've added a comment to the value set after the double-slash ( // ). CIMPL uses JavaScript comment syntax and you can add comments in your files to give extra context to certain items. They aren't required, but could be helpful later on when you are reviewing the file. With the value set named, let's go ahead and add some values: Grammar: ValueSet 5.0 Namespace: zoo.animal ValueSet: AnimalTypeVS // These are the major classes of animal that we want to model. #invertebrate \"Invertebrates are characterized by their lack of backbones and internal skeletons\" #fish \"Fish breathe using gills, and are equipped with 'lateral lines' that detect water currents and even electricity\" #amphibian \"Amphibians are characterized by their semi-aquatic lifestyles (they have to stay near bodies of water, both to maintain the moisture of their skin and to lay their eggs)\" #reptile \"Reptiles are characterized by their cold-blooded metabolisms, their scaly skin, and their leathery eggs, which, unlike amphibians, they can lay some distance away from bodies of water\" #bird \"Birds are characterized by their coats of feathers, their warm-blooded metabolisms, their memorable songs (at least in certain species), and their ability to adapt to a wide range of habitats\" #mammal \"Mammals are characterized by their hair or fur (which all species possess during some stage of their life cycles), the milk with which they suckle their young, and their warm-blooded metabolisms\" Each value is prefaced by a hash symbol ( # ) and followed by a description enclosed in quotation marks. By convention, each value should use lowercase snake_case formatting . We've defined our custom ValueSet but we still need to add it to our DataElement file, so open zoo_animal.txt and add the full definition for our AnimalType : Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS Now, AnimalType will be restricted to the values defined in our custom value set, thanks to the code from [ValueSet] syntax. That's it! We have defined our DataElement file and a custom ValueSet for AnimalType , so we can map our model to its output. Create a file called zoo_animal_map.txt and open it. Maps Our data model is fully defined, but we still need to map it to an output format. Currently, CIMPL only supports output to various versions of the FHIR specification . Let's create the file header for our map: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 In this case, we plan to map our data model to FHIR resources, so we are using FHIR_STU_3 as our target model. Next, we map our EntryElement to its FHIR counterpart: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: For our clinic, it makes sense to map animals as Patient resources in FHIR , since they will be the entities receiving care. In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your FHIR output. Let's map our animal attributes. The name and birthDate fields exist in the FHIR Patient resource , so it looks like they will be simple mappings from our Name and DateOfBirth attributes: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: Name maps to name DateOfBirth maps to birthDate The FHIR Patient resource represents the deceased status using the deceased[x] field. The [x] indicates that this field provides a choice of data types; in this case boolean or dateTime . Since our DeceasedStatus element is a boolean value, we can map it to deceased[x] and the CIMPL framework will properly identify it as mapping to the boolean choice: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: Name maps to name DateOfBirth maps to birthDate DeceasedStatus maps to deceased[x] That just leaves AnimalType , which...doesn't seem to fit nicely into any of the fields on the FHIR Patient resource. There are fields for animal.species , animal.breed , and animal.genderStatus , but there isn't anything that maps well to our custom animal class codes. That's okay! If we simply leave off a mapping for the AnimalType , it will be created as an extension on the FHIR Patient resource. More information about FHIR extensions is available in the FHIR documentation. With all of our data elements, custom value sets, and mapping defined for our Animal element, it's time to run the shr-cli tool. Command-Line Arguments Before we run the shr-cli tool, let's break down the syntax for calling it using the command line: node {location_of_shr_cli_tool} {location_of_cimpl_files} {optional_arguments} node : The shr-cli tool is written in node.js , so we start our statement by calling for that application. {location_of_shr_cli_tool} : Next, we need to tell node which code to run by giving it the directory where the shr-cli tool lives. If you're in the shr-cli directory, you can use a single period ( . ) as a shorthand for that directory. {location_of_cimpl_files} : Now that node has the code it needs to run, we need to give it the directory where our CIMPL files reside. {optional_arguments} : There are a few other options that you can pass to the shr-cli tool. Check the README for all of the possible arguments . Execution and Error Identification Run the shr-cli tool using the following commands: cd ~/cimpl/shr-cli node . ../zoo -o ../zoo/out Uh-oh. You should see the following output: [15:21:21.846Z] INFO shr: Starting CLI Import/Export [15:21:24.435Z] ERROR shr: Mismatched types. Cannot map zoo.animal.Name[Value: string] to [HumanName]. ERROR_CODE:13022 (module=shr-fhir-export, shrId=zoo.animal.Animal, target=Patient, mappingRule=\"Name maps to name\") [15:21:25.410Z] INFO shr: Compiling Documentation for 3 namespaces... (module=shr-json-javadoc) [15:21:25.492Z] INFO shr: Building documentation pages for 31 elements... (module=shr-json-javadoc) [15:21:25.669Z] INFO shr: Finished CLI Import/Export ------------------------------------------------------------ Elapsed time: 3.829s 1 errors (shr-fhir-export) 0 warnings ------------------------------------------------------------ Huh - it looks like we have an error. That's okay! This is pretty common in developing CIMPL files and the output from the shr-cli tool can help us troubleshoot. In, particular, this line tells us where we need to make changes: [15:21:24.435Z] ERROR shr: Mismatched types. Cannot map zoo.animal.Name[Value: string] to [HumanName]. ERROR_CODE:13022 (module=shr-fhir-export, shrId=zoo.animal.Animal, target=Patient, mappingRule=\"Name maps to name\") We defined our Name element as a string , but the name attribute on the FHIR Patient record has the type of HumanName . We have two options: 1. We can redefine the Name element as a HumanName , define the HumanName data type, and redo the mapping so the Name element is properly mapped to FHIR fields 2. We can remove the mapping from Name to the name attribute on the FHIR patient and allow the Name to be created as an extension Note: for more information about possible errors, see the Error Message Documentation Let's take the easier path of removing the mapping for Name . Change your zoo_animal_map.txt file to: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: DateOfBirth maps to birthDate DeceasedStatus maps to deceased[x] With the Name field removed from the mapping, the shr-cli output should run without errors: computer:shr-cli username$ node . ../zoo -o ../zoo/out [18:06:56.010Z] INFO shr: Starting CLI Import/Export [18:07:00.775Z] INFO shr: Compiling Documentation for 3 namespaces... (module=shr-json-javadoc) [18:07:00.881Z] INFO shr: Building documentation pages for 31 elements... (module=shr-json-javadoc) [18:07:01.135Z] INFO shr: Finished CLI Import/Export ------------------------------------------------------------ Elapsed time: 5.136s 0 errors 0 warnings ------------------------------------------------------------ Excellent. You should find that the out directory in your zoo folder now contains quite a bit of material. We'll explore its contents in the next section. CIMPL Outputs By default, shr-cli takes CIMPL models and exports files into the following directories (under out/ ): * cimcore : The serialized, machine-readable CIMCORE (Clinical Information Modeling Computable Representation) files representing the CIMPL input. For more information, see the CIMCORE Documentation . * es6 : ES6 JavaScript classes that support interacting with instances of the SHR elements within JS code. Typically, a JavaScript application will load SHR data from a JSON or FHIR format and then represent the entries in memory using these ES6 classes. * fhir : HL7 FHIR ( Fast Healthcare Interoperability Resources ) is an open, international standard for electronic exchange of healthcare information that is governed by HL7. The files in this folder define FHIR profiles, extensions, logical models, value sets, code systems, and the source needed to generate an HL7 FHIR Implementation Guide. * json : A legacy serialization format used to generate parts of standardhealthrecord.org . This format has been deprecated in favor of CIMCORE . * json-schema : JSON schemas used to define and validate the structure of instance data. * modeldoc : Javadoc -style HTML documentation representing the CIMPL data elements. Casual users may find this documentation easier to review than the CIMPL text input files. Each of the generated files in these directories would take a considerable amount of time to create by hand, but CIMPL's concise syntax combined with the shr-cli generators allow for quick initial and subsequent drafts. FHIR Output For this tutorial, we will focus on the FHIR output. Open the following file: zoo/out/fhir/profiles/zoo-animal-Animal.json This is a JSON representation of a FHIR profile. It's a bit difficult to read in this form, but we can make it slightly more legible by creating a FHIR Implementation Guide. In the development of FHIR standards, an Implementation Guide is the document that most people review when writing software that includes a data standard. It is a human-readable webpage that can contain multiple profiles, extensions, value sets, code sets, etc. and gives context to how those items should be used in a software application. Let's add some project-specific context to our Implementation Guide. Open the following file: zoo/config.json It should look something like this: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } } Let's edit this file to make it more specific to our project: { \"projectName\": \"We bought a zoo\", \"projectShorthand\": \"ZOO\", \"projectURL\": \"http://thatzoowebought.com\", \"fhirURL\": \"http://thatzoowebought.com/fhir\", \"implementationGuide\": { \"npmName\": \"zoo\", \"version\": \"0.0.1\", \"indexContent\": \"zoo.html\" }, \"publisher\": \"Zoo Owner\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://thatzoowebought.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Zoe the Zoo Owner\", \"organization\": \"Zoo Owner\", \"email\": \"zoe@thatzoowebought.com\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) Zoo Owner <http://thatzoowebought.com>\" } } That's better. Note that we also added two new fields to the implementationGuide object: npmName and version . These are new requirements from the FHIR IG Publisher and haven't yet been integrated into the default config template -- but we need them to successfully run the IG Publisher. You'll also notice that the implementationGuide object's indexContent value references a file named zoo.html . This file contains the HTML content that will always show up on the homepage of your generated Implementation Guide. If you have a mission statement, a project timeline, or other general context for your project, this is a good place to include them. Note that this file will be embedded within the <body> tag of the IG home page, so you should not include <html> , <head> , or <body> tags yourself. Let's create the zoo/zoo.html file with the following contents: <h1>We Bought a Zoo!</h1> <p>In 2018, after coming into an absurd amount of money, we decided to buy a zoo! Now, we need to figure out how to care for all the animals. This Implementation Guide describes the data models for our new zoo clinic IT system.</p> After running the shr-cli tool again, we can generate the IG using HL7's FHIR IG Publishing tool . Run the following commands: cd ~/cimpl/shr-cli cp -r ../zoo/out . yarn run ig:publish Note: if this fails, see the shr-cli README for more detailed instructions on running the FHIR IG generator . Open the following file: ~/cimpl/shr-cli/out/fhir/guide/output/index.html It should look something like this: Let's take a look at the items that CIMPL generated. Click the 'Profiles' link and you should see this: Since we only have one profile, that screen isn't terribly helpful. Click on the 'Animal' link to see the profile we just generated: That's much more helpful. You can see a few of the things we defined in config.json , the Name and AnimalType extensions defined in our mapping, and other bindings and constraints created by the shr-cli tool. For a more compact view of the profiled resource, click on the Differential Table tab: This looks a lot more like the DataElement file. All four of our Animal attributes are present and the AnimalType is explicitly bound to our AnimalTypeVS value set. You may notice that the Type for birthDate is not listed here. That is because it is already explicitly defined on the FHIR Patient resource as a date . This 'Differential Table' view only shows the differences between the generated profile and the FHIR resources on which they are based. Improving your First Data Model Now that we've built a very simple model for our animals, we can expand it using other aspects of the CIMPL language. Inheritance and Constraints Let's start by making a few more animals in our zoo_animal.txt file: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS EntryElement: Lion Based on: Animal Description: \"The king of the jungle.\" AnimalType is #mammal EntryElement: Shark Based on: Animal Description: \"The king of the ocean.\" AnimalType is #fish EntryElement: Eagle Based on: Animal Description: \"The king of the sky.\" AnimalType is #bird Looks like this zoo has quite the display! We've added three animals to our model ( Lion , Shark , and Eagle ) to show additional CIMPL functionality: Element inheritance using Based on Since all three are animals, we can go ahead and make all three of them Based on on the Animal class we've already defined. This lets Lion , Shark , and Eagle inherit all of the properties of Animal (i.e., DateOfBirth , Name , etc.), so we don't have to redefine them on the more specific animals. This includes mapping inheritance, so if we don't add new fields, we don't have to create new mappings! Constraints We've constrained each of these animals' AnimalType using {element} is {value} to make the model more specific to our creatures. In our AnimalType definition, we established that its code must come from the custom AnimalTypeVS value set. From that value set, the #mammal , #fish , and #bird codes are relevant for those animals. Constraints (e.g., is ) are an important capability in CIMPL that lead to more accurate, specific models. We will keep coming back to this concept, but it will be helpful to refer to the CIMPL documentation . Managing Multiple Namespaces Now that our zoo is full of animals, where do we put them? We haven't defined any enclosures yet, and it wouldn't exactly make sense to put them in the zoo.animal namespace, so let's make a new zoo.facility namespace. Similarly to how we made the zoo.animal namespace, let's go ahead and make a new file called zoo_facility.txt and add header information: Grammar: DataElement 5.0 Namespace: zoo.facility Description: \"Enclosure environments of the zoo\" Uses: shr.core, shr.base Now let's add an Enclosure and some specific types of enclosures: Grammar: DataElement 5.0 Namespace: zoo.facility Description: \"Enclosure environments of the zoo\" Uses: shr.core, shr.base CodeSystem: MTH = http://ncimeta.nci.nih.gov EntryElement: Enclosure Concept: MTH#C2986715 Value: code from EnclosureVS 1..1 Dimensions Dimensions.DimensionComponent includes 1..1 Length includes 1..1 Width EntryElement: Jungle Based on: Enclosure Value is #tropical EntryElement: Aquarium Based on: Enclosure Value is #aquatic EntryElement: Aviary Based on: Enclosure Value is #sky In addition to this new namespace ( zoo.facility ), we've introduced a few new CIMPL concepts: Concept Codes Concept codes are numerical codes organized in hierarchies that identify clinical terms. They can be useful for correlating your element with a specific clinical concept but do not impact the structure of your elements or add any specific constraints about how they are used. For instance, the Enclosure can be described by the NCI Metathesaurus code MTH#C2986715 . In the FHIR output, this outputs as StructureDefinition.keyword . CodeSystem Declarations In order to use that concept code, we must first define the CodeSystem in the header of our file. This allows us to reference the NCI Metathesaurus with the MTH abbrevation. All abbrevations must be uppercase. The includes Constraint The Dimensions element includes DimensionComponent values for both a Length and a Width . We don't have to define those elements here, because they are already defined in shr.core . This includes structure is a constraint (specifically the includes type constraint) that allows you to specify members of a list. In this case, since both Length and Width are Based on DimensionComponent and the Dimensions element can include multiple DimensionComponent elements, we are specifying that Dimensions must include both Length and Width (though it may also contain other DimensionComponent elements). Inherited Value s In Jungle , Aquarium , and Aviary , we introduce the concept of constraining an inherited Value . While the Enclosure element's Value is constrained to a value set (using code from EnclosureVS ), we can further constrain the Value for Jungle , Aquarium , and Aviary to a specific code using the is keyword (e.g., Value is #sky ). We've used AnimalEnclosureVS but it isn't defined yet. Let's create a new ValueSet file named shr_facility_vs.txt and add that value set: Grammar: ValueSet 5.0 Namespace: zoo.facility ValueSet: EnclosureVS // These are the environments in which our animals live. #tropical \"An environment with average temperature of above 18 degrees Celsius and considerable precipitation during at least part of the year\" #aquatic \"An ecosystem in a body of water\" #sky \"An ecosystem in the sky\" Now, going back to our zoo_animal.txt file, let's add this information to our animals: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base, zoo.facility EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType 1..* Enclosure Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS EntryElement: Lion Based on: Animal Description: \"The king of the jungle.\" AnimalType is #mammal Enclosure is type Jungle EntryElement: Shark Based on: Animal Description: \"The king of the ocean.\" AnimalType is #fish Enclosure is type Aquarium EntryElement: Eagle Based on: Animal Description: \"The king of the sky.\" AnimalType is #bird Enclosure is type Aviary We've made two very important edits: 1. We added the zoo.facility namespace to the Uses statement in the file header, allowing our zoo.animal files to reference any item in the zoo.facility files. 2. We've added Enclosure as a child element of Animal and further constrained the types of enclosure allowed for each of our animals ( Lion , Shark , and Eagle ) using the is type .","title":"CIMPL 5.0 Tutorial"},{"location":"cimpl5Tutorial/#cimpl-50-tutorial","text":"This is an extensive tutorial, meant to educate people about many different aspects of CIMPL. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL documentation .","title":"CIMPL 5.0 Tutorial"},{"location":"cimpl5Tutorial/#table-of-contents","text":"CIMPL 5.0 Tutorial Table of Contents Background Why use a modeling tool? Data Elements, Maps, and Value Sets Building Your First Data Model CIMPL Environment Setup Data Elements Header Create an Animal Value Sets Maps Command-Line Arguments Execution and Error Identification CIMPL Outputs FHIR Output Improving your First Data Model Inheritance and Constraints Element inheritance using Based on Constraints Managing Multiple Namespaces Concept Codes CodeSystem Declarations The includes Constraint Inherited Values","title":"Table of Contents"},{"location":"cimpl5Tutorial/#background","text":"This tutorial assumes that you are already comfortable with: Using a code editor (e.g., Visual Studio Code ) Using the command line on a unix-based OS (e.g., Linux, macOS) Data modeling (e.g., what separates a code from a value, what is a codeable concept) Data constraints (e.g., an element SHALL contain a specific code, another element MAY exist)","title":"Background"},{"location":"cimpl5Tutorial/#why-use-a-modeling-tool","text":"It can be difficult for people to jump directly into resource modeling, especially for extensive, domain-specific implementations like FHIR. CIMPL is purpose-built to create clear, concise object models independent of their particular implementations. Abstraction between data models and implementations allows for cleaner code and a more repeatable and understandable process for building implementation code.","title":"Why use a modeling tool?"},{"location":"cimpl5Tutorial/#data-elements-maps-and-value-sets","text":"CIMPL input files are either Data Elements, Maps, or Value Sets. Data Element files are the backbone of your input - they define individual data elements, whether those data elements are nested within other data elements, and the cardinalities of those data elements, among other things Map files dictate how the elements defined in your data model should be represented in a target implementation (for now, FHIR is the only output supported). Value Set files can be used to define custom codes and/or value sets for use in your data models.","title":"Data Elements, Maps, and Value Sets"},{"location":"cimpl5Tutorial/#building-your-first-data-model","text":"Let's get started with a data model using an example. Say we've just purchased a zoo and we want to define a data model for the animal clinic at our new zoo, which could include things like: Animals Staff Facilities Medicines Food etc.","title":"Building Your First Data Model"},{"location":"cimpl5Tutorial/#cimpl-environment-setup","text":"Before we develop any models, let's make sure our environment is set up. If you haven't already done so, follow the CIMPL Installation instructions and check that everything is working using the Hello World test. Create a directory that shares the same parent folder as your shr-cli installation and name it zoo : mkdir ~/cimpl/zoo Your directory structure should look like this: cimpl |- shr-cli |- zoo We'll need to copy some files from the SHR specification into the zoo directory to ensure that the shr-cli tool runs properly. Download the following files and place them in the zoo directory: base_map.txt base.txt core_map.txt core_vs.txt core.txt Your directory structure should now look like this: cimpl |- shr-cli |- zoo |- base_map.txt |- base.txt |- core_map.txt |- core_vs.txt |- core.txt","title":"CIMPL Environment Setup"},{"location":"cimpl5Tutorial/#data-elements-header","text":"The core part of any data model is the definition of its data elements. Many modeling tools use diagrams or database tables to define their data elements, but CIMPL is defined using plain text. Create a file called zoo_animal.txt and open it. To give our zoo_animal.txt file some context, we need to include some header information. Let's start with a line that describes what the file is: Grammar: DataElement 5.0 Every CIMPL file starts by defining the Grammar . The common CIMPL files are DataElement , Map , and ValueSet . We'll get into Map and ValueSet later. This is a DataElement file that is using CIMPL version 5.0 . Next, add your file to a namespace : Grammar: DataElement 5.0 Namespace: zoo.animal The namespace allows you to define a scope for value sets, data elements, and data mappings. By convention, the namespace is period-delimited, with the project ( zoo ) preceding the specific data model that we are defining ( animal ). The filename ( zoo_animal.txt ) doesn't have to match, but it's good practice to keep the two consistent. Filenames should use underscores in place of periods to avoid confusion with file types. While we're at it, let's give this file a description: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Descriptions can include any characters (except quotation marks) and be as long as you need, but it is good practice to keep them short and simple. By default, we'll need to include some basic modeling building blocks with the uses keyword: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base Once our zoo gets more complicated, we will need to add more to the uses statement, but for now we're just including the basic building blocks that all CIMPL models would not want to redefine (e.g., Entry , Quantity , CodeSystem , etc.). Great! That's it for the DataElement file header.","title":"Data Elements Header"},{"location":"cimpl5Tutorial/#create-an-animal","text":"With the header information out of the way, we can start defining our first data element: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal Since we plan to map this element to some output (we'll get into mapping later), we're using the term EntryElement to describe our Animal . Eventually, this element will have data entered directly into it, thus EntryElement and not just Element . Let's add some attributes to our animal: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType We've added four separate attributes to this Animal : DateOfBirth , Name , AnimalType , and DeceasedStatus . Users familiar with traditional cardinality notation for data modeling will notice that the DateOfBirth and DeceasedStatus fields are required and can only appear once, while the AnimalType is optional and our Animal can have an arbitrary number of Name s. CIMPL doesn't know how to interpret these attributes yet, so let's define them as child Element s, starting with DateOfBirth : Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date We've defined DateOfBirth as an Element , added a short Description , and assigned a Value of date , which is one of the primitive data types that CIMPL accepts . CIMPL is whitespace-agnostic, so the indentation is not necessary, but it is good practice to indent child elements underneath their parents. Element s can get more complicated but let's leave it at that. Now that you know the basic structure of an Element , let's define Name and DeceasedStatus (as a string and boolean , respectively): Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Since we want AnimalType to be restricted to a certain set of values, we need to define a custom ValueSet file. Create a file called zoo_animal_vs.txt and open it.","title":"Create an Animal"},{"location":"cimpl5Tutorial/#value-sets","text":"Just like we did for the DataElement file, we need to define some header information for our ValueSet file: Grammar: ValueSet 5.0 Namespace: zoo.animal That's it! Since the ValueSet file is in the same namespace as our DataElement file, we don't need to add a Description or set up inheritance with a Uses statement. Start defining our AnimalType value set by giving it a name: Grammar: ValueSet 5.0 Namespace: zoo.animal ValueSet: AnimalTypeVS // These are the major classes of animal that we want to model. By convention, all value sets should be Pascal case and end with VS . You may notice that we've added a comment to the value set after the double-slash ( // ). CIMPL uses JavaScript comment syntax and you can add comments in your files to give extra context to certain items. They aren't required, but could be helpful later on when you are reviewing the file. With the value set named, let's go ahead and add some values: Grammar: ValueSet 5.0 Namespace: zoo.animal ValueSet: AnimalTypeVS // These are the major classes of animal that we want to model. #invertebrate \"Invertebrates are characterized by their lack of backbones and internal skeletons\" #fish \"Fish breathe using gills, and are equipped with 'lateral lines' that detect water currents and even electricity\" #amphibian \"Amphibians are characterized by their semi-aquatic lifestyles (they have to stay near bodies of water, both to maintain the moisture of their skin and to lay their eggs)\" #reptile \"Reptiles are characterized by their cold-blooded metabolisms, their scaly skin, and their leathery eggs, which, unlike amphibians, they can lay some distance away from bodies of water\" #bird \"Birds are characterized by their coats of feathers, their warm-blooded metabolisms, their memorable songs (at least in certain species), and their ability to adapt to a wide range of habitats\" #mammal \"Mammals are characterized by their hair or fur (which all species possess during some stage of their life cycles), the milk with which they suckle their young, and their warm-blooded metabolisms\" Each value is prefaced by a hash symbol ( # ) and followed by a description enclosed in quotation marks. By convention, each value should use lowercase snake_case formatting . We've defined our custom ValueSet but we still need to add it to our DataElement file, so open zoo_animal.txt and add the full definition for our AnimalType : Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS Now, AnimalType will be restricted to the values defined in our custom value set, thanks to the code from [ValueSet] syntax. That's it! We have defined our DataElement file and a custom ValueSet for AnimalType , so we can map our model to its output. Create a file called zoo_animal_map.txt and open it.","title":"Value Sets"},{"location":"cimpl5Tutorial/#maps","text":"Our data model is fully defined, but we still need to map it to an output format. Currently, CIMPL only supports output to various versions of the FHIR specification . Let's create the file header for our map: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 In this case, we plan to map our data model to FHIR resources, so we are using FHIR_STU_3 as our target model. Next, we map our EntryElement to its FHIR counterpart: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: For our clinic, it makes sense to map animals as Patient resources in FHIR , since they will be the entities receiving care. In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your FHIR output. Let's map our animal attributes. The name and birthDate fields exist in the FHIR Patient resource , so it looks like they will be simple mappings from our Name and DateOfBirth attributes: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: Name maps to name DateOfBirth maps to birthDate The FHIR Patient resource represents the deceased status using the deceased[x] field. The [x] indicates that this field provides a choice of data types; in this case boolean or dateTime . Since our DeceasedStatus element is a boolean value, we can map it to deceased[x] and the CIMPL framework will properly identify it as mapping to the boolean choice: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: Name maps to name DateOfBirth maps to birthDate DeceasedStatus maps to deceased[x] That just leaves AnimalType , which...doesn't seem to fit nicely into any of the fields on the FHIR Patient resource. There are fields for animal.species , animal.breed , and animal.genderStatus , but there isn't anything that maps well to our custom animal class codes. That's okay! If we simply leave off a mapping for the AnimalType , it will be created as an extension on the FHIR Patient resource. More information about FHIR extensions is available in the FHIR documentation. With all of our data elements, custom value sets, and mapping defined for our Animal element, it's time to run the shr-cli tool.","title":"Maps"},{"location":"cimpl5Tutorial/#command-line-arguments","text":"Before we run the shr-cli tool, let's break down the syntax for calling it using the command line: node {location_of_shr_cli_tool} {location_of_cimpl_files} {optional_arguments} node : The shr-cli tool is written in node.js , so we start our statement by calling for that application. {location_of_shr_cli_tool} : Next, we need to tell node which code to run by giving it the directory where the shr-cli tool lives. If you're in the shr-cli directory, you can use a single period ( . ) as a shorthand for that directory. {location_of_cimpl_files} : Now that node has the code it needs to run, we need to give it the directory where our CIMPL files reside. {optional_arguments} : There are a few other options that you can pass to the shr-cli tool. Check the README for all of the possible arguments .","title":"Command-Line Arguments"},{"location":"cimpl5Tutorial/#execution-and-error-identification","text":"Run the shr-cli tool using the following commands: cd ~/cimpl/shr-cli node . ../zoo -o ../zoo/out Uh-oh. You should see the following output: [15:21:21.846Z] INFO shr: Starting CLI Import/Export [15:21:24.435Z] ERROR shr: Mismatched types. Cannot map zoo.animal.Name[Value: string] to [HumanName]. ERROR_CODE:13022 (module=shr-fhir-export, shrId=zoo.animal.Animal, target=Patient, mappingRule=\"Name maps to name\") [15:21:25.410Z] INFO shr: Compiling Documentation for 3 namespaces... (module=shr-json-javadoc) [15:21:25.492Z] INFO shr: Building documentation pages for 31 elements... (module=shr-json-javadoc) [15:21:25.669Z] INFO shr: Finished CLI Import/Export ------------------------------------------------------------ Elapsed time: 3.829s 1 errors (shr-fhir-export) 0 warnings ------------------------------------------------------------ Huh - it looks like we have an error. That's okay! This is pretty common in developing CIMPL files and the output from the shr-cli tool can help us troubleshoot. In, particular, this line tells us where we need to make changes: [15:21:24.435Z] ERROR shr: Mismatched types. Cannot map zoo.animal.Name[Value: string] to [HumanName]. ERROR_CODE:13022 (module=shr-fhir-export, shrId=zoo.animal.Animal, target=Patient, mappingRule=\"Name maps to name\") We defined our Name element as a string , but the name attribute on the FHIR Patient record has the type of HumanName . We have two options: 1. We can redefine the Name element as a HumanName , define the HumanName data type, and redo the mapping so the Name element is properly mapped to FHIR fields 2. We can remove the mapping from Name to the name attribute on the FHIR patient and allow the Name to be created as an extension Note: for more information about possible errors, see the Error Message Documentation Let's take the easier path of removing the mapping for Name . Change your zoo_animal_map.txt file to: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: DateOfBirth maps to birthDate DeceasedStatus maps to deceased[x] With the Name field removed from the mapping, the shr-cli output should run without errors: computer:shr-cli username$ node . ../zoo -o ../zoo/out [18:06:56.010Z] INFO shr: Starting CLI Import/Export [18:07:00.775Z] INFO shr: Compiling Documentation for 3 namespaces... (module=shr-json-javadoc) [18:07:00.881Z] INFO shr: Building documentation pages for 31 elements... (module=shr-json-javadoc) [18:07:01.135Z] INFO shr: Finished CLI Import/Export ------------------------------------------------------------ Elapsed time: 5.136s 0 errors 0 warnings ------------------------------------------------------------ Excellent. You should find that the out directory in your zoo folder now contains quite a bit of material. We'll explore its contents in the next section.","title":"Execution and Error Identification"},{"location":"cimpl5Tutorial/#cimpl-outputs","text":"By default, shr-cli takes CIMPL models and exports files into the following directories (under out/ ): * cimcore : The serialized, machine-readable CIMCORE (Clinical Information Modeling Computable Representation) files representing the CIMPL input. For more information, see the CIMCORE Documentation . * es6 : ES6 JavaScript classes that support interacting with instances of the SHR elements within JS code. Typically, a JavaScript application will load SHR data from a JSON or FHIR format and then represent the entries in memory using these ES6 classes. * fhir : HL7 FHIR ( Fast Healthcare Interoperability Resources ) is an open, international standard for electronic exchange of healthcare information that is governed by HL7. The files in this folder define FHIR profiles, extensions, logical models, value sets, code systems, and the source needed to generate an HL7 FHIR Implementation Guide. * json : A legacy serialization format used to generate parts of standardhealthrecord.org . This format has been deprecated in favor of CIMCORE . * json-schema : JSON schemas used to define and validate the structure of instance data. * modeldoc : Javadoc -style HTML documentation representing the CIMPL data elements. Casual users may find this documentation easier to review than the CIMPL text input files. Each of the generated files in these directories would take a considerable amount of time to create by hand, but CIMPL's concise syntax combined with the shr-cli generators allow for quick initial and subsequent drafts.","title":"CIMPL Outputs"},{"location":"cimpl5Tutorial/#fhir-output","text":"For this tutorial, we will focus on the FHIR output. Open the following file: zoo/out/fhir/profiles/zoo-animal-Animal.json This is a JSON representation of a FHIR profile. It's a bit difficult to read in this form, but we can make it slightly more legible by creating a FHIR Implementation Guide. In the development of FHIR standards, an Implementation Guide is the document that most people review when writing software that includes a data standard. It is a human-readable webpage that can contain multiple profiles, extensions, value sets, code sets, etc. and gives context to how those items should be used in a software application. Let's add some project-specific context to our Implementation Guide. Open the following file: zoo/config.json It should look something like this: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } } Let's edit this file to make it more specific to our project: { \"projectName\": \"We bought a zoo\", \"projectShorthand\": \"ZOO\", \"projectURL\": \"http://thatzoowebought.com\", \"fhirURL\": \"http://thatzoowebought.com/fhir\", \"implementationGuide\": { \"npmName\": \"zoo\", \"version\": \"0.0.1\", \"indexContent\": \"zoo.html\" }, \"publisher\": \"Zoo Owner\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://thatzoowebought.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Zoe the Zoo Owner\", \"organization\": \"Zoo Owner\", \"email\": \"zoe@thatzoowebought.com\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) Zoo Owner <http://thatzoowebought.com>\" } } That's better. Note that we also added two new fields to the implementationGuide object: npmName and version . These are new requirements from the FHIR IG Publisher and haven't yet been integrated into the default config template -- but we need them to successfully run the IG Publisher. You'll also notice that the implementationGuide object's indexContent value references a file named zoo.html . This file contains the HTML content that will always show up on the homepage of your generated Implementation Guide. If you have a mission statement, a project timeline, or other general context for your project, this is a good place to include them. Note that this file will be embedded within the <body> tag of the IG home page, so you should not include <html> , <head> , or <body> tags yourself. Let's create the zoo/zoo.html file with the following contents: <h1>We Bought a Zoo!</h1> <p>In 2018, after coming into an absurd amount of money, we decided to buy a zoo! Now, we need to figure out how to care for all the animals. This Implementation Guide describes the data models for our new zoo clinic IT system.</p> After running the shr-cli tool again, we can generate the IG using HL7's FHIR IG Publishing tool . Run the following commands: cd ~/cimpl/shr-cli cp -r ../zoo/out . yarn run ig:publish Note: if this fails, see the shr-cli README for more detailed instructions on running the FHIR IG generator . Open the following file: ~/cimpl/shr-cli/out/fhir/guide/output/index.html It should look something like this: Let's take a look at the items that CIMPL generated. Click the 'Profiles' link and you should see this: Since we only have one profile, that screen isn't terribly helpful. Click on the 'Animal' link to see the profile we just generated: That's much more helpful. You can see a few of the things we defined in config.json , the Name and AnimalType extensions defined in our mapping, and other bindings and constraints created by the shr-cli tool. For a more compact view of the profiled resource, click on the Differential Table tab: This looks a lot more like the DataElement file. All four of our Animal attributes are present and the AnimalType is explicitly bound to our AnimalTypeVS value set. You may notice that the Type for birthDate is not listed here. That is because it is already explicitly defined on the FHIR Patient resource as a date . This 'Differential Table' view only shows the differences between the generated profile and the FHIR resources on which they are based.","title":"FHIR Output"},{"location":"cimpl5Tutorial/#improving-your-first-data-model","text":"Now that we've built a very simple model for our animals, we can expand it using other aspects of the CIMPL language.","title":"Improving your First Data Model"},{"location":"cimpl5Tutorial/#inheritance-and-constraints","text":"Let's start by making a few more animals in our zoo_animal.txt file: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS EntryElement: Lion Based on: Animal Description: \"The king of the jungle.\" AnimalType is #mammal EntryElement: Shark Based on: Animal Description: \"The king of the ocean.\" AnimalType is #fish EntryElement: Eagle Based on: Animal Description: \"The king of the sky.\" AnimalType is #bird Looks like this zoo has quite the display! We've added three animals to our model ( Lion , Shark , and Eagle ) to show additional CIMPL functionality:","title":"Inheritance and Constraints"},{"location":"cimpl5Tutorial/#element-inheritance-using-based-on","text":"Since all three are animals, we can go ahead and make all three of them Based on on the Animal class we've already defined. This lets Lion , Shark , and Eagle inherit all of the properties of Animal (i.e., DateOfBirth , Name , etc.), so we don't have to redefine them on the more specific animals. This includes mapping inheritance, so if we don't add new fields, we don't have to create new mappings!","title":"Element inheritance using Based on"},{"location":"cimpl5Tutorial/#constraints","text":"We've constrained each of these animals' AnimalType using {element} is {value} to make the model more specific to our creatures. In our AnimalType definition, we established that its code must come from the custom AnimalTypeVS value set. From that value set, the #mammal , #fish , and #bird codes are relevant for those animals. Constraints (e.g., is ) are an important capability in CIMPL that lead to more accurate, specific models. We will keep coming back to this concept, but it will be helpful to refer to the CIMPL documentation .","title":"Constraints"},{"location":"cimpl5Tutorial/#managing-multiple-namespaces","text":"Now that our zoo is full of animals, where do we put them? We haven't defined any enclosures yet, and it wouldn't exactly make sense to put them in the zoo.animal namespace, so let's make a new zoo.facility namespace. Similarly to how we made the zoo.animal namespace, let's go ahead and make a new file called zoo_facility.txt and add header information: Grammar: DataElement 5.0 Namespace: zoo.facility Description: \"Enclosure environments of the zoo\" Uses: shr.core, shr.base Now let's add an Enclosure and some specific types of enclosures: Grammar: DataElement 5.0 Namespace: zoo.facility Description: \"Enclosure environments of the zoo\" Uses: shr.core, shr.base CodeSystem: MTH = http://ncimeta.nci.nih.gov EntryElement: Enclosure Concept: MTH#C2986715 Value: code from EnclosureVS 1..1 Dimensions Dimensions.DimensionComponent includes 1..1 Length includes 1..1 Width EntryElement: Jungle Based on: Enclosure Value is #tropical EntryElement: Aquarium Based on: Enclosure Value is #aquatic EntryElement: Aviary Based on: Enclosure Value is #sky In addition to this new namespace ( zoo.facility ), we've introduced a few new CIMPL concepts:","title":"Managing Multiple Namespaces"},{"location":"cimpl5Tutorial/#concept-codes","text":"Concept codes are numerical codes organized in hierarchies that identify clinical terms. They can be useful for correlating your element with a specific clinical concept but do not impact the structure of your elements or add any specific constraints about how they are used. For instance, the Enclosure can be described by the NCI Metathesaurus code MTH#C2986715 . In the FHIR output, this outputs as StructureDefinition.keyword .","title":"Concept Codes"},{"location":"cimpl5Tutorial/#codesystem-declarations","text":"In order to use that concept code, we must first define the CodeSystem in the header of our file. This allows us to reference the NCI Metathesaurus with the MTH abbrevation. All abbrevations must be uppercase.","title":"CodeSystem Declarations"},{"location":"cimpl5Tutorial/#the-includes-constraint","text":"The Dimensions element includes DimensionComponent values for both a Length and a Width . We don't have to define those elements here, because they are already defined in shr.core . This includes structure is a constraint (specifically the includes type constraint) that allows you to specify members of a list. In this case, since both Length and Width are Based on DimensionComponent and the Dimensions element can include multiple DimensionComponent elements, we are specifying that Dimensions must include both Length and Width (though it may also contain other DimensionComponent elements).","title":"The includes Constraint"},{"location":"cimpl5Tutorial/#inherited-values","text":"In Jungle , Aquarium , and Aviary , we introduce the concept of constraining an inherited Value . While the Enclosure element's Value is constrained to a value set (using code from EnclosureVS ), we can further constrain the Value for Jungle , Aquarium , and Aviary to a specific code using the is keyword (e.g., Value is #sky ). We've used AnimalEnclosureVS but it isn't defined yet. Let's create a new ValueSet file named shr_facility_vs.txt and add that value set: Grammar: ValueSet 5.0 Namespace: zoo.facility ValueSet: EnclosureVS // These are the environments in which our animals live. #tropical \"An environment with average temperature of above 18 degrees Celsius and considerable precipitation during at least part of the year\" #aquatic \"An ecosystem in a body of water\" #sky \"An ecosystem in the sky\" Now, going back to our zoo_animal.txt file, let's add this information to our animals: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base, zoo.facility EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType 1..* Enclosure Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS EntryElement: Lion Based on: Animal Description: \"The king of the jungle.\" AnimalType is #mammal Enclosure is type Jungle EntryElement: Shark Based on: Animal Description: \"The king of the ocean.\" AnimalType is #fish Enclosure is type Aquarium EntryElement: Eagle Based on: Animal Description: \"The king of the sky.\" AnimalType is #bird Enclosure is type Aviary We've made two very important edits: 1. We added the zoo.facility namespace to the Uses statement in the file header, allowing our zoo.animal files to reference any item in the zoo.facility files. 2. We've added Enclosure as a child element of Animal and further constrained the types of enclosure allowed for each of our animals ( Lion , Shark , and Eagle ) using the is type .","title":"Inherited Values"},{"location":"cimpl6ObjectiveFHIR/","text":"Objective FHIR User Guide Note: This documentation is in draft form. This is an introductory guide to Objective FHIR Version 1.0, implemented in the Clinical Information Modeling and Profiling Language (CIMPL). The Guide assumes some knowledge of CIMPL. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial . Or, see the CIMPL 6 Reference Manual . Table of Contents Objective FHIR User Guide Overview Philosophy Meta-Model Mapping to FHIR Coverage Naming Subclassing Subclassing, Part 2 Comparison Between Profiling Tools Key Concepts Data Types Actors Event Times Building Blocks Class Hierarchy Resource, Domain Resource, Metadata Information Item EntityOrRole Clinical Statement Future Appendix: Relationship to Other Initiatives Overview Objective FHIR (\"OBF\") is an object-oriented abstraction of FHIR. It provides modelers a way to define a detailed clinical information model by subclassing, extending, and constraining a pre-existing class library. These classes can then be translated automatically into FHIR profiles, FHIR Implementation Guides, data dictionaries, schemas, and other assets, using a choice of the three major FHIR versions: DSTU 2, STU 3, and R4. Philosophy OBF classes resemble FHIR R4, but differ in carefully considered ways that increase consistency and reusability of the resulting models and profiles. Objective FHIR allows data structures of all sorts to be reused. This means that individual data elements and frequently-occurring structures can be defined once and used repeatedly. Objective FHIR addresses one of the frequent criticisms of FHIR, specifically its lack of horizontal consistency . FHIR not only uses different names for equivalent things in different resources, but often, altogether different modeling approaches. This is a result of having resources managed by separate groups. OBF creates a layer that smooths over many of these differences, not for aesthetic or theoretical reasons, but to make the whole framework easier to learn, enable greater code reuse, and most importantly, to make the resulting clinical models more interoperable . OBF also insulates modelers from differences between FHIR versions. The OBF classes are based on FHIR R4, but the same content is mapped to previous versions, specifically, DSTU 2 and STU 3. This means you can model once and publish the same content across multiple FHIR versions. Meta-Model Objective FHIR has been developed using the Clinical Information Modeling and Profiling Language (CIMPL). CIMPL is a powerful, FHIR-aware, high-level language for creating clinical models. Expressing the model in CIMPL means that Objective FHIR models can automatically be turned into FHIR Profiles, Implementation Guides, data dictionaries, and other useful artifacts, in multiple FHIR versions. Conceptually, there is nothing that prevents the same model from be expressed in other formalisms, some of which are mentioned in the Appendix . However, OBF in CIMPL is a complete, ready-made solution. Mapping to FHIR One of the significant benefits of the OBF framework, compared to using CIMPL alone, is that mapping to FHIR has already been done for you. In most cases, you don't have to worry about mapping, and you can focus entirely on modeling. The only exceptions are when you create a new class that doesn't inherit from a pre-mapped OBF class, override a previous mapping (rare), or add an extension to a pre-mapped class that requires mapping to a nested extension. Coverage Not all FHIR R4 resources are covered by Objective FHIR. We are working to expand the coverage. The model documentation is the best source to determine if OBF covers your needs. Naming Attribute names in OBF may differ from FHIR names. When they do so, it is usually to make the meaning of the attribute more explicit. OBF names are meant to be meaningful outside of the context of a single class. For example, the FHIR attribute Encounter.period is not entirely self-explanatory, especially when period is considered alone, outside of the context provided by Encounter . To be more reusable, OBF uses the name OccurrencePeriod . Coupled with a different event, such as a procedure, the renamed attribute's meaning is more clear. Although an attribute name is rarely a sufficient definition, OBF moves the needle in that direction. Subclassing To continue the scenario above, suppose you want a more specific concept of OccurrencePeriod applied to a surgical procedure. In this case, we can subclass: Element: SurgicalProcedureOccurrencePeriod Parent: OccurrencePeriod Description: The period of time for a surgery, from the first incision time to the last incision close time, as defined by https://manual.jointcommission.org/releases/archive/TJC2010B/DataElem0127.html. The structure and content of OccurrenceTime is inherited by the new class (cardinalities, data type, the fact that the start time must be less than the end time, etc.), so repeating that information is unnecessary. Don't repeat yourself (DRY) is a major benefit of inheritance. The DRY principle is stated as \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system\". Subclassing, Part 2 The previous example is trivial, but almost everything you do in OBF will involve creating new classes from existing ones. Here's a more involved example: Entry: GenomicsReport Parent: DiagnosticReport Description: \"Genetic analysis summary report. The report may include one or more tests, with two distinct test types... (truncated)\" Property: SpecimenType 0..1 Property: RegionStudied 0..* Code from https://www.ncbi.nlm.nih.gov/gtr (preferred) Category 1..1 Category = DS#GE \"Genetics\" Observation includes GeneticVariantFound 0..* includes GeneticVariantTested 0..* SpecimenType from GeneticSpecimenTypeVS (extensible) Although the purpose of this guide is not to teach CIMPL, this is worth pulling apart: The first two lines create the class GenomicsReport , based on DiagnosticReport . Entry is a CIMPL building block that roughly corresponds to a FHIR resource, and Parent obviously identifies the parent class. Following the Description , two new properties (with cardinalities) are introduced: SpecimenType and RegionStudied . Using CIMPL, you don't fuss with extensions -- that will happen automatically when the class is mapped to FHIR. After the keyword section, there is a series of constraint statements. Without delving into details, these statements say: The Code identifying the report should preferably come from the Genetic Test Registry . The Category will occur exactly once, and will be fixed to the code GE (Genetics) drawn from a code system aliased to DS (mapped elsewhere to http://terminology.hl7.org/CodeSystem/v2-0074 ). The Observation attribute should include zero or more GeneticVariantFound observations and zero or more GeneticVariantTested observations. The includes statement is the way CIMPL slices arrays. Finally, the SpecimenType, which we've just added as a new class property, is extensibly bound to the value set GeneticSpecimenTypeVS . We now have a general-purpose genomics report. We can use this class in the form of a FHIR profile, or use it as a parent for defining more specific genomics reports, perhaps AncestryDotComGenomicsReport . Comparison Between Profiling Tools In FHIR terms, subclassing is akin to profiling profiles, which can be achieved with a number of tools, notably Forge and Trifolia . Both these tools are extremely well-done, and generously supported by commercial entities. However, Forge and Trifolia are graphical user interfaces on top of StructureDefinitions, the low-level \"assembly language\" of FHIR. By contrast, CIMPL is like a high-level programming language. Experience has shown that creating and maintaining a complex project is much easier when you use a language, compared to a visual editor. That's why programming languages are almost always text-based, while visual programming has had comparatively little uptake. Even Unified Modeling Language (UML) - a model-diagramming standard that has been around for decades - is fraught with portability problems , despite having its own exchange format, XMI . As stated by Thomas Beale , \"Architects these days tend to limit their use of UML to package diagrams and a few illustrative class diagrams, while developers tend to go straight to code or use tools that pretty-print extracted textual forms of software such as swagger and apiary.\" (emphasis added). CIMPL takes the latter approach, producing a variety of explanatory and implementable assets generated from CIMPL code, rather than vice versa. When clinical modeling projects grow to a certain size, many of your activities will involve repeatedly re-visiting, revising, refactoring, renaming, and redoing. You will find that global search and search-and-replace across multiple text files will be an indispensible tool. Maintaining your project as CIMPL text not only opens the door to these operations, but also enables meaningful source code control. Objective FHIR is hosted in Github, which gives developers the ability distribute work across multiple branches, compare changes, and merge contributions, allowing your projects to scale in ways that visual editors can't support. Key Concepts Data Types The primitive types used in OBF are those defined in CIMPL, which correspond one-to-one with FHIR primitives, except for the way CIMPL handles coded types . Complex data types in OBF are also the same as FHIR R4. They are found in the obf.datatype namespace. Since complex types like Quantity are ubiquitous, you will almost certainly need to import the obf.datatype into your namespace. This is done using the Uses keyword. Actors Name Description SubjectOfRecord The subject of a clinical statement, often called the Patient or the Subject. The SubjectOfRecord typically identifies the clinical record in which this statement is contained. InformationSource The originator or source of the information or request: a practitioner, patient, related person, organization, an algorithm, device, etc. Author The actor who created the item and it responsible for the content (regardless of the information source or who recorded it). If only the author is given, it is assumed the author is the information source and the recorder. FocalSubject The person or entity that the information in this resource relates to, if different than the person of record. Participant An actor (usually a Practitioner, Patient, or Organization but potentially a device or other entity) that participates in a healthcare task or activity. The participant is not necessarily the performer of the action. Performer The actor that carried out the observation or action. Note: Currently, OBF doesn't include the information recorder among the key actors. The recorder is the actor who physically enters the information, as opposed to creating or being responsible for the information. Author is occasionally mapped to a FHIR attribute named recorder when it is apparent that the resource designers assumed the author and recorder are the same. Event Times Name Description CreationDateTime The point in time when an ancillary item (such as a report or image) was created. OccurrenceTimeOrPeriod The time or period when an event occurred. StatementTimeOrPeriod The time a record of an action or situation was created. RelevantTime The time or time period that the statement addresses, not necessarily when the information is gathered. LastUpdated The last time a record was updated. NonOccurrenceTimeOrPeriod The time or period an event was asserted not to have occurred (currently not used) Building Blocks OBF classes fall into one of four categories, which are the building blocks of CIMPL: Building Block Description Inherits from Analogous FHIR Type Element The lowest-level building block, representing a property-value pair. Element Property or simple extension Group A building block comprised of other building blocks, specifically, other Groups, Elements, and Entries. Group Backbone element or complex extension Entry A building block representing a group of related information, complete enough to support stand-alone interpretation. Entry or Abstract Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Abstract none Class Hierarchy In this section, we describe the overall organization and some key classes in Objective FHIR. A pared-down view of the OBF hierarchy is shown below. For full details of each class, please refer to the OBF model documentation . The purpose of the hierarchy is two-fold: 1) To define properties uniformly across multiple classes. For example, almost every FHIR resource should have an author, but many don't, and those that do use a variety of different names . It shouldn't be left up to individual resources, managed by different work groups, to each define author themselves. Inevitably, they will define it differently, or forget entirely, as FHIR R4 shows. Inheriting from a common parent prevents that. 1) To provide a set of ready-made classes that users can extend. An example is QuantitativeLaboratoryObservation , based on Observation . FHIR's approach to uniformity is to define certain patterns, such as the request pattern . However, FHIR stops short of actually implementing these patterns across resources. Implementations can't assume all requests have the same core properties, and can't write generic methods for processing requests. Instead, each type of request must be implemented as a one-off. Resource, Domain Resource, Metadata At the top of the OBF hierarchy are the classes Resource and DomainResource. They involve the Metadata group. These classes align with FHIR. Information Item InformationItem includes definitional items, value set definitions, questionnaire, research study, entities such as locations and organizations, people, financial information, etc. While InformationItem has no attributes itself, it serves as a conceptual grouper for things that exist in the clinical world that are not statements about a patient's health or healthcare. EntityOrRole This branch of the hierarchy, which splits into Entity and Role, represent the potential actors in healthcare scenarios. Entities include organizations, locations, devices, medications, and other \"things\", physical and conceptual. Roles are patient, practitioner, related person, and research subject. FHIR models these resources by conflating the role with the person playing the role. Although this is not the optimal model, OBF continues that practice, just to make OBF more obvious to FHIR users. Earlier versions of OBF modeled a person separately from the role(s) that person could play. Clinical Statement ClinicalStatement provides properties and behaviors common to entries in a medical record. This class also allows for common representation of simple data provenance elements: SubjectOfRecord , CareContext ( Encounter or EpisodeOfCare ), and StatementDateTime . Below ClinicalStatement are two classes, SituationStatement and ActionStatement : SituationStatements covers many types of descriptive information, including opinions, evaluations, laboratory results, genomic data, and social information. ActionStatements covers requested and performed actions, such as prescribing and taking medications, performing procedures, requesting a service. Future Current work is focused on using the classes defined in Objective FHIR directly in implementations, leveraging automatically generated Javascript classes and methods that, at runtime, translate FHIR resources to and from the logical model classes. This would allow implementers to use object oriented programming in much more powerful ways than available in native FHIR, with its flat class structure and complex extension representations. Appendix: Relationship to Other Initiatives Conceptually, Objective FHIR could be expressed in other modeling frameworks, besides CIMPL. Some of the potential frameworks include: Unified Modeling Language (UML) for structure coupled with Object Constraint Language (OCL) for constraint representation. The Federal Health Information Model initiative (FHIM) has conducted some experiments using Model-Driven Health Tools to try and convert UML/OCL models into FHIR profiles. Basic Meta-Model (BMM) for class hierarchy, coupled with Archetype Description Language (ADL) for constraint representation. BMM/ADL has been used in openEHR . Claude Nanjo of University of Utah has conducted some experiments to try to convert ADL/BMM models into FHIR profiles. Clinical Element Models . CEMs are being used to produce some Clinical Information Modeling Initiative (CIMI) FHIR Implementation Guides . Essential parts of CEM-related tooling are internal to Intermountain Healthcare. Objective FHIR is an open source project , and we welcome contributions.","title":"Objective FHIR User Guide"},{"location":"cimpl6ObjectiveFHIR/#objective-fhir-user-guide","text":"Note: This documentation is in draft form. This is an introductory guide to Objective FHIR Version 1.0, implemented in the Clinical Information Modeling and Profiling Language (CIMPL). The Guide assumes some knowledge of CIMPL. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial . Or, see the CIMPL 6 Reference Manual . Table of Contents Objective FHIR User Guide Overview Philosophy Meta-Model Mapping to FHIR Coverage Naming Subclassing Subclassing, Part 2 Comparison Between Profiling Tools Key Concepts Data Types Actors Event Times Building Blocks Class Hierarchy Resource, Domain Resource, Metadata Information Item EntityOrRole Clinical Statement Future Appendix: Relationship to Other Initiatives","title":"Objective FHIR User Guide"},{"location":"cimpl6ObjectiveFHIR/#overview","text":"Objective FHIR (\"OBF\") is an object-oriented abstraction of FHIR. It provides modelers a way to define a detailed clinical information model by subclassing, extending, and constraining a pre-existing class library. These classes can then be translated automatically into FHIR profiles, FHIR Implementation Guides, data dictionaries, schemas, and other assets, using a choice of the three major FHIR versions: DSTU 2, STU 3, and R4.","title":"Overview"},{"location":"cimpl6ObjectiveFHIR/#philosophy","text":"OBF classes resemble FHIR R4, but differ in carefully considered ways that increase consistency and reusability of the resulting models and profiles. Objective FHIR allows data structures of all sorts to be reused. This means that individual data elements and frequently-occurring structures can be defined once and used repeatedly. Objective FHIR addresses one of the frequent criticisms of FHIR, specifically its lack of horizontal consistency . FHIR not only uses different names for equivalent things in different resources, but often, altogether different modeling approaches. This is a result of having resources managed by separate groups. OBF creates a layer that smooths over many of these differences, not for aesthetic or theoretical reasons, but to make the whole framework easier to learn, enable greater code reuse, and most importantly, to make the resulting clinical models more interoperable . OBF also insulates modelers from differences between FHIR versions. The OBF classes are based on FHIR R4, but the same content is mapped to previous versions, specifically, DSTU 2 and STU 3. This means you can model once and publish the same content across multiple FHIR versions.","title":"Philosophy"},{"location":"cimpl6ObjectiveFHIR/#meta-model","text":"Objective FHIR has been developed using the Clinical Information Modeling and Profiling Language (CIMPL). CIMPL is a powerful, FHIR-aware, high-level language for creating clinical models. Expressing the model in CIMPL means that Objective FHIR models can automatically be turned into FHIR Profiles, Implementation Guides, data dictionaries, and other useful artifacts, in multiple FHIR versions. Conceptually, there is nothing that prevents the same model from be expressed in other formalisms, some of which are mentioned in the Appendix . However, OBF in CIMPL is a complete, ready-made solution.","title":"Meta-Model"},{"location":"cimpl6ObjectiveFHIR/#mapping-to-fhir","text":"One of the significant benefits of the OBF framework, compared to using CIMPL alone, is that mapping to FHIR has already been done for you. In most cases, you don't have to worry about mapping, and you can focus entirely on modeling. The only exceptions are when you create a new class that doesn't inherit from a pre-mapped OBF class, override a previous mapping (rare), or add an extension to a pre-mapped class that requires mapping to a nested extension.","title":"Mapping to FHIR"},{"location":"cimpl6ObjectiveFHIR/#coverage","text":"Not all FHIR R4 resources are covered by Objective FHIR. We are working to expand the coverage. The model documentation is the best source to determine if OBF covers your needs.","title":"Coverage"},{"location":"cimpl6ObjectiveFHIR/#naming","text":"Attribute names in OBF may differ from FHIR names. When they do so, it is usually to make the meaning of the attribute more explicit. OBF names are meant to be meaningful outside of the context of a single class. For example, the FHIR attribute Encounter.period is not entirely self-explanatory, especially when period is considered alone, outside of the context provided by Encounter . To be more reusable, OBF uses the name OccurrencePeriod . Coupled with a different event, such as a procedure, the renamed attribute's meaning is more clear. Although an attribute name is rarely a sufficient definition, OBF moves the needle in that direction.","title":"Naming"},{"location":"cimpl6ObjectiveFHIR/#subclassing","text":"To continue the scenario above, suppose you want a more specific concept of OccurrencePeriod applied to a surgical procedure. In this case, we can subclass: Element: SurgicalProcedureOccurrencePeriod Parent: OccurrencePeriod Description: The period of time for a surgery, from the first incision time to the last incision close time, as defined by https://manual.jointcommission.org/releases/archive/TJC2010B/DataElem0127.html. The structure and content of OccurrenceTime is inherited by the new class (cardinalities, data type, the fact that the start time must be less than the end time, etc.), so repeating that information is unnecessary. Don't repeat yourself (DRY) is a major benefit of inheritance. The DRY principle is stated as \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system\".","title":"Subclassing"},{"location":"cimpl6ObjectiveFHIR/#subclassing-part-2","text":"The previous example is trivial, but almost everything you do in OBF will involve creating new classes from existing ones. Here's a more involved example: Entry: GenomicsReport Parent: DiagnosticReport Description: \"Genetic analysis summary report. The report may include one or more tests, with two distinct test types... (truncated)\" Property: SpecimenType 0..1 Property: RegionStudied 0..* Code from https://www.ncbi.nlm.nih.gov/gtr (preferred) Category 1..1 Category = DS#GE \"Genetics\" Observation includes GeneticVariantFound 0..* includes GeneticVariantTested 0..* SpecimenType from GeneticSpecimenTypeVS (extensible) Although the purpose of this guide is not to teach CIMPL, this is worth pulling apart: The first two lines create the class GenomicsReport , based on DiagnosticReport . Entry is a CIMPL building block that roughly corresponds to a FHIR resource, and Parent obviously identifies the parent class. Following the Description , two new properties (with cardinalities) are introduced: SpecimenType and RegionStudied . Using CIMPL, you don't fuss with extensions -- that will happen automatically when the class is mapped to FHIR. After the keyword section, there is a series of constraint statements. Without delving into details, these statements say: The Code identifying the report should preferably come from the Genetic Test Registry . The Category will occur exactly once, and will be fixed to the code GE (Genetics) drawn from a code system aliased to DS (mapped elsewhere to http://terminology.hl7.org/CodeSystem/v2-0074 ). The Observation attribute should include zero or more GeneticVariantFound observations and zero or more GeneticVariantTested observations. The includes statement is the way CIMPL slices arrays. Finally, the SpecimenType, which we've just added as a new class property, is extensibly bound to the value set GeneticSpecimenTypeVS . We now have a general-purpose genomics report. We can use this class in the form of a FHIR profile, or use it as a parent for defining more specific genomics reports, perhaps AncestryDotComGenomicsReport .","title":"Subclassing, Part 2"},{"location":"cimpl6ObjectiveFHIR/#comparison-between-profiling-tools","text":"In FHIR terms, subclassing is akin to profiling profiles, which can be achieved with a number of tools, notably Forge and Trifolia . Both these tools are extremely well-done, and generously supported by commercial entities. However, Forge and Trifolia are graphical user interfaces on top of StructureDefinitions, the low-level \"assembly language\" of FHIR. By contrast, CIMPL is like a high-level programming language. Experience has shown that creating and maintaining a complex project is much easier when you use a language, compared to a visual editor. That's why programming languages are almost always text-based, while visual programming has had comparatively little uptake. Even Unified Modeling Language (UML) - a model-diagramming standard that has been around for decades - is fraught with portability problems , despite having its own exchange format, XMI . As stated by Thomas Beale , \"Architects these days tend to limit their use of UML to package diagrams and a few illustrative class diagrams, while developers tend to go straight to code or use tools that pretty-print extracted textual forms of software such as swagger and apiary.\" (emphasis added). CIMPL takes the latter approach, producing a variety of explanatory and implementable assets generated from CIMPL code, rather than vice versa. When clinical modeling projects grow to a certain size, many of your activities will involve repeatedly re-visiting, revising, refactoring, renaming, and redoing. You will find that global search and search-and-replace across multiple text files will be an indispensible tool. Maintaining your project as CIMPL text not only opens the door to these operations, but also enables meaningful source code control. Objective FHIR is hosted in Github, which gives developers the ability distribute work across multiple branches, compare changes, and merge contributions, allowing your projects to scale in ways that visual editors can't support.","title":"Comparison Between Profiling Tools"},{"location":"cimpl6ObjectiveFHIR/#key-concepts","text":"","title":"Key Concepts"},{"location":"cimpl6ObjectiveFHIR/#data-types","text":"The primitive types used in OBF are those defined in CIMPL, which correspond one-to-one with FHIR primitives, except for the way CIMPL handles coded types . Complex data types in OBF are also the same as FHIR R4. They are found in the obf.datatype namespace. Since complex types like Quantity are ubiquitous, you will almost certainly need to import the obf.datatype into your namespace. This is done using the Uses keyword.","title":"Data Types"},{"location":"cimpl6ObjectiveFHIR/#actors","text":"Name Description SubjectOfRecord The subject of a clinical statement, often called the Patient or the Subject. The SubjectOfRecord typically identifies the clinical record in which this statement is contained. InformationSource The originator or source of the information or request: a practitioner, patient, related person, organization, an algorithm, device, etc. Author The actor who created the item and it responsible for the content (regardless of the information source or who recorded it). If only the author is given, it is assumed the author is the information source and the recorder. FocalSubject The person or entity that the information in this resource relates to, if different than the person of record. Participant An actor (usually a Practitioner, Patient, or Organization but potentially a device or other entity) that participates in a healthcare task or activity. The participant is not necessarily the performer of the action. Performer The actor that carried out the observation or action. Note: Currently, OBF doesn't include the information recorder among the key actors. The recorder is the actor who physically enters the information, as opposed to creating or being responsible for the information. Author is occasionally mapped to a FHIR attribute named recorder when it is apparent that the resource designers assumed the author and recorder are the same.","title":"Actors"},{"location":"cimpl6ObjectiveFHIR/#event-times","text":"Name Description CreationDateTime The point in time when an ancillary item (such as a report or image) was created. OccurrenceTimeOrPeriod The time or period when an event occurred. StatementTimeOrPeriod The time a record of an action or situation was created. RelevantTime The time or time period that the statement addresses, not necessarily when the information is gathered. LastUpdated The last time a record was updated. NonOccurrenceTimeOrPeriod The time or period an event was asserted not to have occurred (currently not used)","title":"Event Times"},{"location":"cimpl6ObjectiveFHIR/#building-blocks","text":"OBF classes fall into one of four categories, which are the building blocks of CIMPL: Building Block Description Inherits from Analogous FHIR Type Element The lowest-level building block, representing a property-value pair. Element Property or simple extension Group A building block comprised of other building blocks, specifically, other Groups, Elements, and Entries. Group Backbone element or complex extension Entry A building block representing a group of related information, complete enough to support stand-alone interpretation. Entry or Abstract Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Abstract none","title":"Building Blocks"},{"location":"cimpl6ObjectiveFHIR/#class-hierarchy","text":"In this section, we describe the overall organization and some key classes in Objective FHIR. A pared-down view of the OBF hierarchy is shown below. For full details of each class, please refer to the OBF model documentation . The purpose of the hierarchy is two-fold: 1) To define properties uniformly across multiple classes. For example, almost every FHIR resource should have an author, but many don't, and those that do use a variety of different names . It shouldn't be left up to individual resources, managed by different work groups, to each define author themselves. Inevitably, they will define it differently, or forget entirely, as FHIR R4 shows. Inheriting from a common parent prevents that. 1) To provide a set of ready-made classes that users can extend. An example is QuantitativeLaboratoryObservation , based on Observation . FHIR's approach to uniformity is to define certain patterns, such as the request pattern . However, FHIR stops short of actually implementing these patterns across resources. Implementations can't assume all requests have the same core properties, and can't write generic methods for processing requests. Instead, each type of request must be implemented as a one-off.","title":"Class Hierarchy"},{"location":"cimpl6ObjectiveFHIR/#resource-domain-resource-metadata","text":"At the top of the OBF hierarchy are the classes Resource and DomainResource. They involve the Metadata group. These classes align with FHIR.","title":"Resource, Domain Resource, Metadata"},{"location":"cimpl6ObjectiveFHIR/#information-item","text":"InformationItem includes definitional items, value set definitions, questionnaire, research study, entities such as locations and organizations, people, financial information, etc. While InformationItem has no attributes itself, it serves as a conceptual grouper for things that exist in the clinical world that are not statements about a patient's health or healthcare.","title":"Information Item"},{"location":"cimpl6ObjectiveFHIR/#entityorrole","text":"This branch of the hierarchy, which splits into Entity and Role, represent the potential actors in healthcare scenarios. Entities include organizations, locations, devices, medications, and other \"things\", physical and conceptual. Roles are patient, practitioner, related person, and research subject. FHIR models these resources by conflating the role with the person playing the role. Although this is not the optimal model, OBF continues that practice, just to make OBF more obvious to FHIR users. Earlier versions of OBF modeled a person separately from the role(s) that person could play.","title":"EntityOrRole"},{"location":"cimpl6ObjectiveFHIR/#clinical-statement","text":"ClinicalStatement provides properties and behaviors common to entries in a medical record. This class also allows for common representation of simple data provenance elements: SubjectOfRecord , CareContext ( Encounter or EpisodeOfCare ), and StatementDateTime . Below ClinicalStatement are two classes, SituationStatement and ActionStatement : SituationStatements covers many types of descriptive information, including opinions, evaluations, laboratory results, genomic data, and social information. ActionStatements covers requested and performed actions, such as prescribing and taking medications, performing procedures, requesting a service.","title":"Clinical Statement"},{"location":"cimpl6ObjectiveFHIR/#future","text":"Current work is focused on using the classes defined in Objective FHIR directly in implementations, leveraging automatically generated Javascript classes and methods that, at runtime, translate FHIR resources to and from the logical model classes. This would allow implementers to use object oriented programming in much more powerful ways than available in native FHIR, with its flat class structure and complex extension representations.","title":"Future"},{"location":"cimpl6ObjectiveFHIR/#appendix-relationship-to-other-initiatives","text":"Conceptually, Objective FHIR could be expressed in other modeling frameworks, besides CIMPL. Some of the potential frameworks include: Unified Modeling Language (UML) for structure coupled with Object Constraint Language (OCL) for constraint representation. The Federal Health Information Model initiative (FHIM) has conducted some experiments using Model-Driven Health Tools to try and convert UML/OCL models into FHIR profiles. Basic Meta-Model (BMM) for class hierarchy, coupled with Archetype Description Language (ADL) for constraint representation. BMM/ADL has been used in openEHR . Claude Nanjo of University of Utah has conducted some experiments to try to convert ADL/BMM models into FHIR profiles. Clinical Element Models . CEMs are being used to produce some Clinical Information Modeling Initiative (CIMI) FHIR Implementation Guides . Essential parts of CEM-related tooling are internal to Intermountain Healthcare. Objective FHIR is an open source project , and we welcome contributions.","title":"Appendix: Relationship to Other Initiatives"},{"location":"cimpl6Reference/","text":"CIMPL 6.0 Reference Documentation Note: This documentation is a draft. This is a comprehensive guide to CIMPL 6.0 syntax. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial . Table of Contents CIMPL 6.0 Reference Documentation Overview CIMPL Versioning Namespaces File Types Naming Conventions File Names Namespace Names Class Names Fully Qualified Names Value Set Names Local Code Names Reserved Words Whitespace Comments Primitives Concept Codes Keywords Abstract CodeSystem Concept Description Element Entry Grammar Group Namespace Parent Path Property Uses Value ValueSet CIMPL Paths Dot Notation Entries Terminate Paths Bracket Notation for Value Choices Path Example Constraints Cardinality Constraint Fixed Value Constraint Append Constraint Substitute Constraint Value Set Binding Constraint Includes Constraint Only Constraint Class File Class File Example Class File Header Class Definitions Class Type and Name Declaration Properties and Values Naming Recommendations Value Set File Value Set File Example Value Set File Header Value Set Definition Explicit Codes Implicit Codes Map File Inheritance of Mapping Rules Mapping CIMPL Primitives to FHIR Map File Example Map File Header Setting the Mapping Target Mapping Properties Mapping to References Placement of Extensions Special Mapping Statements fix constrain Slicing Slicing Strategies Declaring a Discriminator Moving the Slice Location Appendix A: Changes from CIMPL 5.x Overview CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a specially-designed language for defining clinical information models. It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles and implementation guides (IG). Because it is a language , written in text statements, CIMPL encourages distributed, team-based development using conventional source-code control tools such as Github. CIMPL provides tooling that enables you to define a model once, and publish that model to multiple versions of FHIR. CIMPL Versioning CIMPL follows the semantic versioning convention (MAJOR.MINOR.PATCH). MAJOR: A major release has significant new functionality and potentially, grammar changes or other non-backward-compatible changes. MINOR: Contains new or modified features, while maintaining backwards compatability within the major version. PATCH: Contains minor updates and bug fixes, while maintaining backwards compatability within the major version. CIMPL is currently on major version 6. For a full change log, see the Release Notes . Namespaces CIMPL organizes information into namespaces. A namespace is conventionally denoted by the authoring organization or project name, and the broad category of elements the namespace defines, delineated by a period. Namespaces must begin with a lowercase character. For example: Namespace: onco.core Note: The organization or project name is recommended but not required (e.g., Namespace: lab is also allowed). File Types Model information in CIMPL is stored in the following three file types: Class files (.txt): contain definitions of CIMPL classes, which map to FHIR profiles and extensions. Value Set files (.txt): contain definitions of value sets defined in the namespace. Map files (.txt): contain information on how the CIMPL models relate to FHIR resources, profiles, and elements. Each namespace will typically have one or more class files, and if needed, a value set and map file. Naming Conventions File Names File names must begin with lower case and typically include the namespace: Class files: namespace.txt or namespace_something.txt Value Set files: namespace_vs.txt or namespace_something_vs.txt Mapping files: namespace_map.txt or namespace_something_map.txt Any periods in the namespace should be replaced by underscores. For example, a namespace called odh.occupation , the recommended value set file name is odh_occupation_vs.txt . The something is useful when you want to break up the contents of a single namespace into multiple files, for example: obf_action.txt obf_finding.txt Note: obf stands for Objective FHIR , a set of classes provided with CIMPL that can help you create FHIR profiles. For more information, see Objective FHIR Overview Additional files for configuring and producing FHIR implementation guides (IGs), and their naming conventions include: Configuration files: ig-igname-config.json Content profile files: ig-igname-cp.json IG examples: ignameExampleName.json IG HTML pages: anyName.html Namespace Names Best practice is to follow the naming convention pattern of organization.domain or project.domain (followed by subdomains if necessary). Example Purpose obf.lab Laboratory profiles belonging to Objective FHIR odh Occupational Data for Health onco.core Core namespace for oncology-related profiles Class Names Elements, Groups and Entries are conventionally defined in PascalCase . For example: * Element: DetectionTime * Group: Dosage * Entry: AdverseEvent Note: Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter. Fully Qualified Names CIMPL does not support duplicate class names within a single namespace. However, the same name may occur in different namespaces. In the case of naming collisions due to an included namespace in Uses , you have to refer to the class by its fully qualified name (FQN). The FQN is a combination of the element's namespace and its declared name (through concatenation delimited by a period). For example, the element CancerCondition in the namespace onco.core has the following FQN: onco.core.CancerCondition FQNs are only required in case of naming collisions between namespaces. Value Set Names Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: Value Set names must begin with an uppercase letter. Local Code Names Within a custom value set, the individual codes (denoted by # symbol) are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or other radiation source\" #swimming_pool \"Swimming Pool\" Reserved Words CIMPL has a number of reserved words and phrases that are part of CIMPL's grammar (e.g., boolean , or , from , maps to ). For a complete list of reserved words, refer to the ANTLR4 grammar . Whitespace Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 6.0 Namespace: myExampleNamespace is equivalent to this: Grammar: DataElement 6.0 Namespace: myExampleNamespace Comments CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */ Primitives Primitives are distinguished by starting with lower case letter. CIMPL defines the following primitive data types. With the exception of concept (a simplified representation of code, Coding, and CodeableConcept), the primitive types in CIMPL align with FHIR: concept boolean integer string decimal uri base64Binary instant date dateTime time oid id markdown unsignedInt positiveInt xhtml Note: CIMPL does not have an explicit \"Reference\" type. References are determined during the mapping process. Concept Codes CIMPL uses a single primitive type, concept to represent coded terms from controlled vocabularies. A concept combines three elements: code system, code, and optional display test. The grammar for specifying concepts is: SYSTEM#code \"Display text\" For example: SCT#363346000 \"Malignant neoplastic disease (disorder)\" ICD10CM#C004 \"Malignant neoplasm of lower lip, inner aspect\" The SYSTEM is an alias for a canonical URI that represents a controlled vocabulary. Aliases must be declared in the file header using the CodeSystem keyword . You cannot use the canonical URI directly in the concept grammar. Unlike FHIR, CIMPL does not differentiate between code, Coding, and CodeableConcept. See Mapping Concept Codes for information on CIMPL maps concept to these FHIR types. Note: Future versions of CIMPL will expand concept to include the code system version. Keywords Keywords are used to make various declarations. Keywords always appear at the beginning of a line and are followed by a colon. Keyword Summary: | Keyword | Purpose | File Type(s) | |----------|---------|---------| | Abstract | Declare an non-instantiable class | Class | | CodeSystem | Define a code system alias | Class, Value Set | | Concept | Express the meaning of a class | Class | | Description | Provide a human-readable description | Class, Value Set | | Element | Declare lowest-level (elemental) model building block | Class | | Entry | Declare a stand-alone class | Class | | Grammar | Define how a file should be parsed | All | | Group | Declare mid-level, non-stand-alone model building block | Class | | Namespace | Associate a file with a namespace | All | | Parent | Specify inheritance | Class | | Path | Alias long URLs | Class, Value Set | | Property | Define an attribute in a class | Class | | Uses | Import namespace(s) | Class | | Value | Define data type(s) of Elements | Class | | ValueSet | Define a value set | Value Set | Abstract The Abstract keyword is used to declare a new Abstract class. Abstract classes are identical to Entries, except they are not instantiable. For details, see Class File . Example: Abstract: ActionStatement CodeSystem The CodeSystem keyword provides an alias or shorthand for the canonical URI of code system. You must define a code system alias before you can use codes from that system in constraints or value sets. By convention, the alias should be be UPPER CASE, although the tooling does allow for numbers and hyphens after the first upper case letter. Examples: CodeSystem: LNC = http://loinc.org CodeSystem: SCT = http://snomed.info/sct Concept The Concept keyword (not to be confused with the concept primitive ) establishes the meaning of a class in terms of a code (or codes) from controlled vocabularies. Assigning a concept allows the meaning of the class to be understood without inferring it from the class name. If multiple concept codes are used, they should appear as a comma-separated list. This keyword is optional. Examples: Concept: MTH#C3858779 \"Security classification\" Description The Description keyword is used for a narrative that defines the namespace, class, or value set. Example: Description: \"Oncology data elements that broadly apply to most cancer cases.\" Note: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.) Element The Element keyword is used to declare a new class of type Element, the lowest-level building block in CIMPL. For details, see Class File . Example: Element: EvidenceType Entry The Entry keyword is used to declare a new stand-alone class, analogous to a Resource or Profile in FHIR. For details, see Class File . Example: Entry: GenomicsReport Grammar The Grammar keyword defines how the file is to be parsed. The grammar declaration must be the first line in each CIMPL file. File Type Required First Line Current Version # Class Grammar: DataElement #.# 6.0 Value Set Grammar: ValueSet #.# 5.1 Map Grammar: Map #.# 5.1 Note: no space in ValueSet The version details the MAJOR and MINOR version of the grammar the file was written for. The grammar version is typically note the same as the CIMPL release. Generally, the major version of the Grammar matches the major version number of CIMPL, however, at the time of the CIMPL 6.0 release, the ValueSet and Map grammar remain at 5.1. Group The Group keyword is used to declare a building block comprised of one or more properties, similar to a complex data type in FHIR. For details, see Class File . Example: Group: Dosage Namespace The Namespace keyword defines the association of the file with a namespace, and is required in DataElement , ValueSet and Map files. The namespace can be any number of lowercase period-delimited words. Examples: Namespace: odh Namespace: onco.core Note: While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens. Parent Through the Parent keyword, CIMPL provides a mechanism for basing a class on another class, the child inheriting all properties and constraints from the parent. The child class can then extend information inherited from the parent by adding additional properties and applying additional constraints. Additionally, mappings are inherited alongside properties. At most one parent class can be specified. The Parent declaration is optional There are restrictions on which building blocks can inherit from other building blocks. The rules can be summarized as like inherits from like : Building Block Can Inherit From Element Element Group Group Entry Abstract or Entry Abstract Abstract Note: Although the CIMPL 6.0 tooling does not currently enforce these inheritance rules, they will enforced in future releases. You are strongly encouraged to comply to these rules, and refactor any definitions ported from CIMPL 5.x that do not comply. Example: Parent: LaboratoryObservation Path The Path keyword allows for abbreviations of long URLs. This functionality is completely optional, but it is provided to make authoring easier. By convention, the alias should be be an all UPPER CASE word, although the tooling does allow for numbers and hyphens after the first letter. Example: Path: FHIR = http://hl7.org/fhir/ValueSet Property Classes based on Group, Entry, and Abstract are composed of one or more properties (called fields or attributes in object-oriented programming). A property can be any Element, Group, or Entry, but never a primitive. Each property must have a specified cardinality range, represented as min..max , indicating the number of repeats of the property. The Property keyword cannot be used in Elements. In the following example, StudyArm has three properties: Name , Type , and Comment . Name is singular and required, Type is optional and repeating, and Comment is singular and optional: Group: StudyArm Description: \"Refers to participant(s) in a clinical trial assigned to receive specific interventions according to a protocol.\" Property: Name 1..1 Property: Type 0..* Property: Comment 0..1 Property: ResearchStudy 1..1 A property that refers to an Entry (such as ResearchStudy, above) is implicitly a reference (pointer) to an instance of that Entry, rather than implying the Entry is \"in-lined\" into the class. Note: CIMPL 5.0 Grammar use of the keyword ref() is now obsolete. Uses The Uses keyword appears in the Class file and provides a comma-separated list of the namespaces imported to the current namespace. This keyword allows you to use the classes and value sets defined in other namespaces. The list order has no effect. Examples: Uses: obf.datatype Uses: obf.datatype, obf, onco.core Value Value represents the data type(s) an Element can accept. This keyword can only be when defining an Element. Each Element must have exactly one Value , although the value itself can be a choice of several data types. Value choices can be primitives , Elements , Groups , or Entries . A value may be inherited and constrained in the child class. Examples: Element: DetectionTime Description: \"The date on which the condition was first observed.\" Value: dateTime Element: ExpectedPerformanceTime Description: \"When an action should be performed.\" Value: dateTime or TimePeriod or Timing Element: SubstanceOrCode Description: \"A code or substance reference identifying the ingredient.\" Value: concept or Substance or Medication Although in general, constraints cannot be applied to a property or value at the same time the item is defined, you are allowed to bind a value set to a concept value choice at the same time the value is defined, as follows: Element: IsPrimaryTumor Description: \"Whether the tumor is the original or first tumor in the body, for a particular cancer.\" Value: concept from YesNoUnknownVS (required) For more information on binding, see Value Set Binding Constraint . Note: CIMPL 5.0 Grammar associating a cardinality to a Value is now obsolete. ValueSet Defines the name of a value set defined inside CIMPL (references to external value sets are also allowed). By convention, all value sets should be Pascal case, start with the name of the corresponding concept-type Element that is being bound to the value set, and end with VS . Example: ValueSet: ProposedStatusVS CIMPL Paths CIMPL provides grammar that allows you to refer to any part of a CIMPL class, regardless of nesting. This section outlines CIMPL Path Grammar, which is used in constraints and mapping . Dot Notation Dot notation is used to denote nested properties. The path lists the properties in order, separated by a dot (.) For example, if Patient has a ContactPoint , and ContactPoint has a Priority , then the path to Priority is Patient.ContactPoint.Priority . Entries Terminate Paths An Entry can appear in a path only as its final element. Paths represent nested containment within one class, and Entries are independent objects. Paths cannot \"hop\" from one Entry to another. For example, Procedure has a Patient property, and while Procedure.Patient is a valid path, Procedure.Patient.gender is not. The former path can be used to set the cardinality of Patient within the Procedure class, but the latter would (illegally) constrain an attribute within Patient from inside Procedure . Bracket Notation for Value Choices Values can offer a choice of data types . Bracket notation is used to refer to a particular value choice. Bracket notation must always be used when an Element is part of a CIMPL path. How value choices appear in paths depends on whether the path appears with an Element definition or not. Inside an: Refer to the Value choices as: Element Value[choice] Entry or Group ElementName[choice] Example: Entry: Procedure Property: Priority 0..1 Priority[concept] = SCT#394849002 \"High Priority\" // not Value[concept] Element: Priority Value: integer or concept Value[concept] from PriorityVS (required) // not Priority[concept] Note: The requirement in CIMPL 6.0 to use bracket notation even when the value has only one choice is a change from CIMPL 5. Path Example Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Group: Location Description: \"Location of the landmark\" Property: Code 0..1 Property: Laterality 0..1 Property: Orientation 0..1 Element: Distance Description: \"How far the body location of interest is from the given landmark.\" Value: Quantity Element: Direction Description: \"The direction from the landmark to the body location of interest.\" Value: ClockFaceDirection or AnatomicalDirection Element: ClockFaceDirection Description: \"A direction indicated by o'clock position or degrees relative to 12 o'clock.\" Value: concept or Angle Group: Quantity Description: \"A quantity with units.\" Property: Number 0..1 Property: Comparator 0..1 Property: Units 0..1 This example assumes all paths begin at Landmark. Path to Path Direction Landmark.Direction Laterality Landmark.Location.Laterality ClockFaceDirection Landmark.Direction[ClockFaceDirection] Angle Landmark.Direction[ClockFaceDirection][Angle] Units Landmark.Distance[Quantity].Units A reliable method to create a CIMPL path is to first view it as a dot path, then bracket any part of the path that is a Value, and finally, remove the dot before each left (open) bracket. Here's an example of that process, for the path from Landmark to Units: 1) Find the path: Landmark to Distance , Distance to Quantity , Quantity to Units . 1) Reduce to dot path: Landmark.Distance.Quantity.Units 1) Bracket each Value: Landmark.Distance.[Quantity].Units 1) Remove dot before left (open) bracket: Landmark.Distance[Quantity].Units Constraints Constraints are a way to shape a general model for a particular purpose. Properties, values, and value choices can be constrained. Constraint targets can be be top-level or deeply nested (the latter referred to using CIMPL paths ), inherited or locally-defined. Unlike keyword declarations, constraint statements do not begin with a keyword. Most constraint statements have three parts: The subject of the constraint A reserved word or phrase indicating the type of constraint The constraint value being applied Here are several examples of this pattern: Example Subject Reserved word Value applied IsPrimaryTumor = true IsPrimaryTumor = true Specimen substitute TumorSpecimen Specimen substitute TumorSpecimen BodyLocation from BodyLocationVS BodyLocation from BodyLocationVS LanguageUsed 0..1 LanguageUsed (implicit) 0..1 Here is a summary of constraints supported in CIMPL 6: To do this.. Use this Keyword or Symbol Applies to Narrow cardinality {min}..{max} Property Assign a fixed value = Property or Value[Choice] Append a fixed value to an array += Array Property Narrow a data type substitute Property or Value[Choice] Bind a value set from Property or Value[Choice] Slice an array includes Array Property Narrow choices for a value only Value Cardinality Constraint Cardinality defines the number of repeats that can exist for a property. Cardinality is specified using FHIR syntax, {min}..{max}, where the first integer indicates the minimum repeats (0 implying optional), and the second digit expresses the upper bound on the number of repeats. To express no upper bound, a * is used. When constraining cardinality, you can only narrow the previously declared cardinality. The cardinality constraint only applies to properties. Declaration Constraint Subsequent Constraint Property: LanguageUsed 0..* LanguageUsed 0..1 LanguageUsed 0..0 Property: GovernmentIssuedID 0..* GovernmentIssuedID 1..* GovernmentIssuedID 1..1 Property: Status 1..1 Status 0..1 invalid Note: By constraining a property to 0..0, you effectively remove the property. Use 0..0 with caution, because if an instance does include that property, the instance will fail validation and may be rejected. Fixed Value Constraint The = operator fixes a property to a specific value (e.g., a specific code, boolean value, etc.). The assigned value must be consistent with the defined data type, and is always a primitive. Fixed value constraints apply to properties and value choices. Example Syntax Fix a code to a property ObservationCode = LNC#82810-3 Fix a boolean value to a property IsPrimaryTumor = true Fix a code to a value choice Value[concept] = SCT#233613009 \"Pneumonia\" Fix the units associated with a Quantity value choice Value[Quantity].Units = UCUM#cm Fix a code to a value Value = SCT#233613009 \"Pneumonia\" invalid Notes: 1) Bracket notation must always be used when applying a constraint to a value choice, even if the value has only one choice . This is a change from CIMPL 5. 1) CIMPL allows fixed concept values to be overridden in child classes. Although this seems to violate the notion that constraints should get progressive tighter in subclasses, it is necessary when narrowing the meaning of a class characterized by a concept code. For example, the class Pneumonia , with fixed code, SCT#233604007 , may have a child, Fungal Pneumonia , with fixed code SCT#233613009 , the latter overriding the former. CIMPL will assume, without checking, that the code describing the child class has more constrained semantics than the code it replaces. 1) Fixing numerical types and strings (including URLs) is not yet supported, although this feature is planned. 1) If you only need to fix a value code for one particular mapping (one version of FHIR, for example), do so using the fix keyword in the mapping file. Append Constraint The append ( += ) operator appends a fixed primitive value (boolean, concept, etc.) to an array property. You can use the += operation repeatedly on the same array, limited only be the cardinality of the array. The append operator can only be applied to repeating properties. For example, you would use += to insert a particular Social Security Number (SSN) or Driver's License number into an array of identifiers (in contrast, includes would be used to require the array contain one or more SSNs, without specifying a particular SSN.) Example Syntax Insert \"Behavior\" into Category array Category += LNC#54511-1 \"Behavior\" Add \"Social History\" to same array Category += OBSCAT#social-history \"Social History\" Substitute Constraint The substitute keyword constrains the data type of a property. The new data type that is substituted for the original must be a subclass of the original data type. Example Syntax Constrain the property Specimen to be a TumorSpecimen Specimen substitute TumorSpecimen note: TumorSpecimen must be a subclass of Specimen Constrain a value choice of type Quantity to SimpleQuantity Value[Quantity] substitute SimpleQuantity note: SimpleQuantity is a subclass of Quantity Value Set Binding Constraint Binding is the process of associating a concept with a set of possible values. Binding uses the keyword from . The object of a binding must be an Element whose value is a concept. The value set that is being bound can be a value set defined in CIMPL or a canonical URL external to CIMPL. CIMPL uses the same binding strengths as FHIR , namely: required (strongest) indicates that the code must come from the specified value set. extensible indicates that the code must come from the specified set if the value set contains a relevant code ; otherwise a code outside the value set may be chosen. preferred indicates that the code should ideally come from the specified value set, but codes outside the value set may also be chosen. example (weakest) indicates that the code may come from anywhere; the specified value set is for example purposes only. The following rules apply to binding in CIMPL 6: If no binding strength is specified, the binding is assumed to be required . When further constraining an existing binding, the binding strength can stay the same or be made tighter (e.g., replacing an preferred binding with an extensible or required binding), but never loosened. Constraining may leave the binding strength the same and change the value set instead. However, certain changes permitted in CIMPL may violate FHIR profiling principles . In particular, FHIR will permit a required value set to be replaced by another required value set only if the codes in the new value set are a subset of the codes in the original value set. For extensible bindings, the new value set can contain codes not in the existing value set, but additional codes SHOULD NOT have the same meaning as existing codes in the base value set. Example Syntax Required binding of a Property (property is an Element with concept data type) ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (required) Required binding of a Property (by default) ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical Extensible binding of a Property ReasonCode from ReasonCodeVS (extensible) Preferred binding of a Property BodyLocation from BodyLocationVS (preferred) Required binding of a Value Choice that is a concept Value[concept] from http://hl7.org/fhir/ValueSet/condition-clinical (required) Required binding of a Value Choice that is an Element with whose value is a ClinicalStatus Value[ClinicalStatus] from http://hl7.org/fhir/ValueSet/condition-clinical (required) Includes Constraint The includes constraint is used to specify that a repeating property (array) should contain a certain class or classes. FHIR refers to this as slicing . In CIMPL, it is a simple matter of saying an array includes certain types of elements. The includes statement has several requirements: The elements included in the array must conform to the data type of the array. For example, if the array is Identifier 0..* , the items included in the array must be Identifiers or be inherit from Identifier. Cardinality of each inclusion must be specified, and must fit the cardinality of the array. For example, if the array property has a finite maximum cardinality, you cannot include an element with cardinality 0..*. The keyword includes is repeated for each item the array should contain. The includes constraint does not apply to Values. Here is an example: Measurement 0..* // the array property ... Measurement includes TumorLength 1..1 includes TumorWidth 0..1 includes TumorDepth 0..1 TumorLength, TumorWidth, and TumorDepth all must inherit from Measurement, because Measurement is the array property being sliced. Optionally, the second statement can be written on separate lines (since CIMPL is whitespace insensitive): Measurement includes TumorLength 1..1 includes TumorWidth 0..1 includes TumorDepth 0..1 Here is another example: Identifier 1..* // the array property ... Identifier includes NationalProviderIdentifier 0..1 includes TaxIdentificationNumber 0..1 In this case, either NationalProviderIdentifier or TaxIdentificationNumber must be present, even though both are individually optional, because of the 1..* cardinality on Identifier. Note: When using includes , special mapping syntax is required. See Slicing . Only Constraint Values can have multiple data types. Use the only constraint in an Element to narrow the choice of data types. The only constraint can only be applied to a Value that has multiple choices. The grammar of only constraints varies depending on whether the constraint appears in an Element, or another type of Class. Example: Element: Priority Value: integer or concept Inside Class... Grammar Element Value only integer Entry or Group Priority only integer Note: CIMPL currently does not support narrowing a choice to a more limited choice, for example, narrowing a choice of three types to two types. This feature is planned. Class File Class files contain definitions of the information model. Class File Example Here is an abbreviated example of a class file: Grammar: DataElement 6.0 Namespace: obf.lab Description: \"Profiles of laboratory tests and panels.\" Uses: datatype, obf CodeSystem: LNC = http://loinc.org CodeSystem: UCUM = http://unitsofmeasure.org Abstract: SimpleQuantLabWithRequiredUnits Parent: SimpleQuantitativeLaboratoryObservation Description: \"Laboratory tests that must be reported with units.\" DataValue 1..1 DataValue only QuantityWithRequiredUnits DataAbsentReason 0..0 Group: QuantityWithRequiredUnits Parent: Quantity Description: \"A quantity with that requires a coded unit of measure.\" Units 1..1 Entry: GlobulinMCncPtSerQnCalculatedLabObs Parent: SimpleQuantLabWithRequiredUnits Description: \"Globulin [Mass/\u200bvolume] in Serum by calculation\" Code = LNC#10834-0 \"Globulin [Mass/\u200bvolume] in Serum by calculation\" DataValue[Quantity].Units from EquivalentUnitsVS-g-per-L (required) Class File Header The elements of the class file header are (in order): 1) Grammar (required) 1) Namespace (required) 1) Description (recommended; once per namespace) 1) Uses (optional; as needed) 1) CodeSystem (optional; as needed) 1) Path (optional) For a further description, see Keywords . Note: Uses imports namespaces whose classes can be used as if they were locally defined. However, if a class name in an imported namespace collides with a local class name, you must refer to that element by its fully qualified name . Class Definitions Following the header, the class file contains a number of class definitions. The order of definitions does not matter. A class definition has a sequence of declarations, although after the first declaration, a strict order is not prescribed. Follow the links for further explanation of each item: 1) Class Type and Name Declaration (required) 1) Parent Declaration (optional) 1) Concept Declaration (optional) 1) Description (optional but highly recommended) 1) Property Declarations (for Entry, Abstract and Group) or Value Declaration (for Element) (optional, but typically present) 1) Constraint statements (optional) Class Type and Name Declaration The first line of all class definitions is a keyword representing the type of building block, followed by a descriptive name you choose. Class names must be unique within a given namespace. CIMPL provides four types of building blocks: Building Block Description Has... Analogous FHIR Type Element The lowest-level building block, representing a property-value pair. Value Property or simple extension Group A building block comprised of other building blocks, specifically, other Groups, Elements, and Entries. Properties Backbone element or complex extension Entry A building block representing a group of related information, complete enough to support stand-alone interpretation. Properties Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Properties none Properties and Values When defining classes, bear in mind that an Element has exactly one Value field and no Property fields, whereas, a Group , Entry , or Abstract can have multiple Property fields but cannot have a Value field. Furthermore, a Property cannot have choices, but a Value can. These differences are illustrated in this example: Element: ExpectedPerformanceTime Description: \"When an action should be performed.\" Value: dateTime or TimePeriod or Timing Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Summary: Keyword Appears in How Many Times? Has Cardinality? Has Choices? Can be a... Value Element Exactly Once No Yes (optionally) primitive, Element, Group, or Entry Property Group , Entry , or Abstract Zero or more Yes No Element, Group, or Entry Naming Recommendations All classes in CIMPL, from Elements to Entries, are reusable outside of their original context. To promote reuse, try to choose names that are self-explanatory and context-independent. For example, a property named Text is too vague, whereas DisplayText and InstructionText are more self-explanatory and may be completely understandable when placed into a specific context. However, an overly-specific name like AddressDisplayText could inhibit reuse because it affixes the context of an address to the concept of a display text. Value Set File The value set files are used to define custom value sets and codes when existing value set sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient, and a new value set must be defined. Value Set File Example A (truncated) example value set file is shown below: Grammar: ValueSet 5.1 Namespace: onco.core CodeSystem: SCT = http://snomed.info/sct CodeSystem: ICD10CM = http://hl7.org/fhir/sid/icd-10-cm ValueSet: CancerDiseaseStatusEvidenceTypeVS Description: \"The type of evidence backing up the clinical determination of cancer progression.\" SCT#363679005 \"Imaging (procedure)\" SCT#252416005 \"Histopathology test (procedure)\" SCT#711015009 \"Assessment of symptom control (procedure)\" SCT#5880005 \"Physical examination procedure (procedure)\" SCT#250724005 \"Tumor marker measurement (procedure)\" SCT#386344002 \"Laboratory data interpretation (procedure)\" ValueSet: SecondaryCancerDisorderVS Description: \"Types of secondary malignant neoplastic disease\" Includes codes descending from SCT#128462008 \"Secondary malignant neoplastic disease (disorder)\" ICD10CM#C7B00 \"Secondary carcinoid tumors, unspecified site\" ICD10CM#C7B01 \"Secondary carcinoid tumors of distant lymph nodes\" ICD10CM#C7B02 \"Secondary carcinoid tumors of liver\" ICD10CM#C7B03 \"Secondary carcinoid tumors of bone\" ICD10CM#C7B04 \"Secondary carcinoid tumors of peritoneum\" Value Set File Header Grammar and Namespace are required keywords in a Value Set file header. One or more CodeSystem will be needed. For a further description, see Keywords . Value Set Definition Following the header, the Value Set file contains a number of value set definitions. The order of definitions does not matter. Each definition follows a set sequence of declarations. Follow the links for further explanation of each item: 1) Value Set Declaration (required) 1) Description (optional but highly recommended) 1) Code Declarations (optional) 1) Includes Codes statements (optional) Explicit Codes Explicit code declarations are used to add specific codes to a value set. Codes can either be locally-defined, or selected from external code systems, such as the CAP#29915 example, in which 29915 is an existing code within the CAP code system. If the code is defined locally, the namespace serves as the code system. For the syntax of concept codes, see Concept Codes . Type Example Locally-defined code #proposed \"The proposal has been proposed, but not accepted or rejected.\" Externally-defined code CAP#29915 \"None/Negative\" Implicit Codes Implicit code declarations are used to add sets of codes to a value set, in particular, from hierarchically-defined code systems. At present, the only hierarchical system supported is SNOMED-CT. There are three variants involving the Includes codes phrase: Phrase Example Result Includes codes from Includes codes from MDR Value set contains all codes from MDR code system Includes codes descending from Includes codes descending from SCT#105590001 Value set contains SCT#1055900001 and all codes below it in the SNOMED-CT hierarchy and not descending from Includes codes descending from SCT#363346000 \"Malignant neoplastic disease\" and not descending from SCT#128462008 \"Secondary malignant neoplastic disease\" Value set contains SCT#363346000 and all codes below it in the SNOMED-CT hierarchy, except code SCT#128462008 and all codes below it Map File Map files control how classes defined in CIMPL are expressed as FHIR profiles. Map files are FHIR-version dependent. Currently, you can map to FHIR DSTU 2, STU 3, R4. If you use the supplied Objective FHIR base classes , you many not need to create a map file. Inheritance of Mapping Rules Maps are defined in a series of mapping rules. A powerful feature of CIMPL is that mapping rules are inherited. If your class that inherits from a parent class that already is mapped, you do not need to create a new map for your class. However, if you you want specify mappings for new properties, or override the inherited map, you may do so. The inheritance of mapping rules follows the class hierarchy. If there is no map for a class or attribute, CIMPL tooling automatically looks to the parent class to try and find a mapping. The first mapping rule found will be applied. If no mapping rule is found for a property defined in CIMPL, a FHIR extension will be created. If no mapping is found for an Entry, that Entry will be mapped to the Basic resource . In general, mapping to Basic is not recommended because it has no inherent semantic meaning for implementers. Any unmapped properties will appear as FHIR extensions. Mapping CIMPL Primitives to FHIR CIMPL follows somewhat flexible rules on how CIMPL primitives map to FHIR. For example, a unsignedInt in CIMPL can map to an integer type in FHIR (since every unsignedInt is an integer, there is no loss of information). However, mappings that lose information, such as integer in CIMPL to unsignedInt in FHIR, generally will trigger mapping errors. An exception is that CIMPL concept is allowed to map to FHIR code . The following table shows the acceptable mappings between CIMPL and FHIR: CIMPL Primitive Can map to FHIR... concept code, Coding, CodableConcept boolean boolean, code integer integer, Quantity string string decimal decimal uri uri base64Binary base64Binary instant instant date date dateTime dateTime, date, instant time time oid oid id id markdown markdown, string unsignedInt unsignedInt, integer, Quantity positiveInt positiveInt, unsignedInt, integer, Quantity xtml xtml Map File Example Grammar: Map 5.1 Namespace: obf Target: FHIR_STU_3 Dosage maps to Dosage: DoseSequenceNumber maps to sequence InstructionText maps to text InstructionCode maps to additionalInstruction PatientInstruction maps to patientInstruction Timing maps to timing AsNeeded maps to asNeeded[x] AdministrationSite maps to site RouteIntoBody maps to route Method maps to method DoseAndRate.DoseAmount maps to dose[x] DoseAndRate.DoseRate maps to rate[x] MaxDosePerPeriod maps to maxDosePerPeriod MaxDosePerAdministration maps to maxDosePerAdministration MaxDosePerLifetime maps to maxDosePerLifetime MedicationStatement maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-medicationstatement: Identifier maps to identifier MedicationBasedOn maps to basedOn MedicationStatementPartOf maps to partOf CareContext maps to context Status maps to status StatusReason maps to extension Category maps to category MedicationCodeOrReference maps to medication[x] OccurrenceTimeOrPeriod maps to effective[x] StatementDateTime maps to dateAsserted MedicationInformationSource maps to informationSource SubjectOfRecord maps to subject SupportingInformation maps to derivedFrom fix taken to #y constrain reasonNotTaken to 0..0 constrain dosage to 0..1 ReasonCode maps to reasonCode MedicationReasonReference maps to reasonReference Annotation maps to note Dosage maps to dosage Map File Header The header of a map file must include a Grammar , Namespace , and Target keywords. The Target keyword gives the version of FHIR that the CIMPL model is mapped to, either FHIR_DSTU_2 , FHIR_STU_3 , or FHIR_R4 . For a further description of the header keywords, see Keywords . Setting the Mapping Target Each block in a mapping file begins with statement that establishes a resource, profile, or complex data type that is the target for the mapping. In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in the target output. The mapping target can be a FHIR resource or profile that is part of the target FHIR release version. The initial statement in each mapping block must end with a colon (:). CIMPL Building Block FHIR Target Example Entry Resource SocialHistoryObservation maps to Observation: Entry Profile LaboratoryObservation maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-observationresults: Group Complex Datatype Timing maps to Timing: Mapping Properties After the first line, the remainder of the block consists of statements that map CIMPL properties to FHIR elements. Each statement begins with a CIMPL path , followed by the phrase maps to , and ending with the target FHIR path. With FHIR as the target output, the right-hand side of the map statement can point to any field on a FHIR resource, including: Fields that are at the root of the resource (e.g., maritalStatus ) Fields that are child elements of root elements on the resource (e.g., reaction.substance ) Fields that have a choice of data types (e.g., multipleBirth[x].boolean ) Fields that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity ) Fields that support FHIR Reference() types. CIMPL type FHIR type Example Property element MaritalStatus maps to maritalStatus Property extension Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity Path element Value.ActiveFlag maps to active Path path AdverseReaction.AllergenIrritant maps to reaction.substance Value choice element BodySiteOrCode[concept] maps to bodySite Mapping to References FHIR resources and profiles require an explicit Reference() indicator when referring to another resource or profile. In CIMPL, this is not required or allowed. CIMPL follows the rule that whenever a property is an Entry, that property is mapped as a reference in FHIR. Example: CIMPL Definition Corresponding FHIR Property: Encounter 0..1 encounter: 0..1 Reference(Encounter) Placement of Extensions As mentioned above, if no mapping rule is found for a property, an extension will be automatically created. By default, the extension will be a top-level element in the FHIR profile. Sometimes you may want the extension to appear in a different place, perhaps inside a nested element. To put the extension precisely where you want it, you can map to FHIR paths that include extension . Here's an example involving AdverseEvent: PotentialCause.CauseCategory maps to suspectEntity.extension This rule will create an extension named CauseCategory under AdverseEvent.suspectEntity, rather than directly under AdverseEvent. Note that rules such as this: DetectionTime maps to extension leave the default behavior unchanged, and are not required. However, they can be used to document the intent to create an extension. Special Mapping Statements fix fix allows FHIR fields to be assigned a value. Note that it is the FHIR resource that is getting the value, not the CIMPL class. This enables you to fix a FHIR value without having change the class definition, which would affect all potential mappings. Example: fix status to #completed constrain constrain allows users to constrain the cardinality of FHIR elements. Note that is the FHIR resource that is getting the constraint, not the CIMPL class. The cardinality is expressed in {min}..{max} form. Keyword Example constrain constrain explanation to 0..1 Slicing When fields are allowed to repeat on a target model (e.g., have cardinality with an upper bound greater than 1), it is common practice to specify which CIMPL elements are mapped to instances of that repeated field on the target model. This process is called slicing . For example, the FHIR Task resource allows for an arbitrary number of input fields to be added. To ensure that each input field is uniquely addressable by a parsing engine, those inputs need to be differentiated by a discriminator . See the FHIR documentation for more detail about slicing and discriminators . Slicing Strategies Slicing is used when there is a variation of how an individual element is represented and a need to model it as a sub-list. An example of this is the FHIR Blood Pressure profile , which can be considered an observation with two components which are identical in structure other than their represented code. In CIMPL, slicing strategies are specified in the map file. Two reserved phrases are used in conjunction to specify the slide: slice on slice strategy Examples of its usage in a statement are shown below: Phrase Example slice on / slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) slice on / slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) slice on Laterality maps to qualifier (slice on = concept) Declaring a Discriminator To perform any slicing, a discriminator needs to be declared, using slice on followed by the discriminator. CIMPL supports the FHIR processing types for discriminators: Discriminator Definition value The slices have different values in the nominated element exists The slices are differentiated by the presence or absence of the nominated element pattern The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x] type The slices are differentiated by type of the nominated element to a specified profile profile The slices are differentiated by conformance of the nominated element to a specified profile (not recommended) Moving the Slice Location If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Reserved Phrase Example slice at Members.Observation maps to related.target (slice at = related; slice on type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occurring at related.target . Instead, the slice at = related ensures that the slicing is occurring at the related element. Appendix A: Changes from CIMPL 5.x For those who have created detailed models using CIMPL 5.0, there have been significant grammar changes to CIMPL 6.0. The table below summarizes these changes: Change Type Change Description CIMPL 5.0 Example CIMPL 6.0 Example Section New keyword only eliminates all value choices except one None FindingResult only concept Only Constraint New keyword Property is required to define properties for an Entry or Element. 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword Replace EntryElement keyword replaced by Entry EntryElement: CourseOfTreatmentPerformed Entry: CourseOfTreatmentPerformed Element Keyword Replace Based on keyword replaced by Parent Based on: Observation Parent: Observation Parent Keyword Syntax change Cardinality is specified after the property or class name 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword , Cardinality Constraint Replace is constraint for fixed values replaced by = FindingTopicCode is LNC#48676-1 FindingTopicCode = LNC#48676-1 Field Constraints Replace substitution of a more specific element derived from a parent element using is type keyword replaced by substitute . Specimen is type BreastSpecimen Specimen substitute BreastSpecimen Substitute Replace code , Coding , and CodeableConcept primitives are replaced by a new primitive concept Value: CodeableConcept from AttributionCategoryVS Value: concept from AttributionCategoryVS Primitives Replace must be , should be , could be , and if covered value set constraints are obsolete and replaced by (required) , (preferred) , (extensible) , and (example) Type from BreastSpecimenTypeVS if covered Type from BreastSpecimenTypeVS (required) Value Set Binding Constraint Replace ref() is now obsolete. value is type replaced by substitute and bracket notation denoting value choices SourceSpecimen value is type ref(BreastSpecimen) SourceSpecimen[Specimen] substitute BreastSpecimen Mapping to References","title":"CIMPL 6.0 Reference Documentation"},{"location":"cimpl6Reference/#cimpl-60-reference-documentation","text":"Note: This documentation is a draft. This is a comprehensive guide to CIMPL 6.0 syntax. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial . Table of Contents CIMPL 6.0 Reference Documentation Overview CIMPL Versioning Namespaces File Types Naming Conventions File Names Namespace Names Class Names Fully Qualified Names Value Set Names Local Code Names Reserved Words Whitespace Comments Primitives Concept Codes Keywords Abstract CodeSystem Concept Description Element Entry Grammar Group Namespace Parent Path Property Uses Value ValueSet CIMPL Paths Dot Notation Entries Terminate Paths Bracket Notation for Value Choices Path Example Constraints Cardinality Constraint Fixed Value Constraint Append Constraint Substitute Constraint Value Set Binding Constraint Includes Constraint Only Constraint Class File Class File Example Class File Header Class Definitions Class Type and Name Declaration Properties and Values Naming Recommendations Value Set File Value Set File Example Value Set File Header Value Set Definition Explicit Codes Implicit Codes Map File Inheritance of Mapping Rules Mapping CIMPL Primitives to FHIR Map File Example Map File Header Setting the Mapping Target Mapping Properties Mapping to References Placement of Extensions Special Mapping Statements fix constrain Slicing Slicing Strategies Declaring a Discriminator Moving the Slice Location Appendix A: Changes from CIMPL 5.x","title":"CIMPL 6.0 Reference Documentation"},{"location":"cimpl6Reference/#overview","text":"CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a specially-designed language for defining clinical information models. It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles and implementation guides (IG). Because it is a language , written in text statements, CIMPL encourages distributed, team-based development using conventional source-code control tools such as Github. CIMPL provides tooling that enables you to define a model once, and publish that model to multiple versions of FHIR.","title":"Overview"},{"location":"cimpl6Reference/#cimpl-versioning","text":"CIMPL follows the semantic versioning convention (MAJOR.MINOR.PATCH). MAJOR: A major release has significant new functionality and potentially, grammar changes or other non-backward-compatible changes. MINOR: Contains new or modified features, while maintaining backwards compatability within the major version. PATCH: Contains minor updates and bug fixes, while maintaining backwards compatability within the major version. CIMPL is currently on major version 6. For a full change log, see the Release Notes .","title":"CIMPL Versioning"},{"location":"cimpl6Reference/#namespaces","text":"CIMPL organizes information into namespaces. A namespace is conventionally denoted by the authoring organization or project name, and the broad category of elements the namespace defines, delineated by a period. Namespaces must begin with a lowercase character. For example: Namespace: onco.core Note: The organization or project name is recommended but not required (e.g., Namespace: lab is also allowed).","title":"Namespaces"},{"location":"cimpl6Reference/#file-types","text":"Model information in CIMPL is stored in the following three file types: Class files (.txt): contain definitions of CIMPL classes, which map to FHIR profiles and extensions. Value Set files (.txt): contain definitions of value sets defined in the namespace. Map files (.txt): contain information on how the CIMPL models relate to FHIR resources, profiles, and elements. Each namespace will typically have one or more class files, and if needed, a value set and map file.","title":"File Types"},{"location":"cimpl6Reference/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"cimpl6Reference/#file-names","text":"File names must begin with lower case and typically include the namespace: Class files: namespace.txt or namespace_something.txt Value Set files: namespace_vs.txt or namespace_something_vs.txt Mapping files: namespace_map.txt or namespace_something_map.txt Any periods in the namespace should be replaced by underscores. For example, a namespace called odh.occupation , the recommended value set file name is odh_occupation_vs.txt . The something is useful when you want to break up the contents of a single namespace into multiple files, for example: obf_action.txt obf_finding.txt Note: obf stands for Objective FHIR , a set of classes provided with CIMPL that can help you create FHIR profiles. For more information, see Objective FHIR Overview Additional files for configuring and producing FHIR implementation guides (IGs), and their naming conventions include: Configuration files: ig-igname-config.json Content profile files: ig-igname-cp.json IG examples: ignameExampleName.json IG HTML pages: anyName.html","title":"File Names"},{"location":"cimpl6Reference/#namespace-names","text":"Best practice is to follow the naming convention pattern of organization.domain or project.domain (followed by subdomains if necessary). Example Purpose obf.lab Laboratory profiles belonging to Objective FHIR odh Occupational Data for Health onco.core Core namespace for oncology-related profiles","title":"Namespace Names"},{"location":"cimpl6Reference/#class-names","text":"Elements, Groups and Entries are conventionally defined in PascalCase . For example: * Element: DetectionTime * Group: Dosage * Entry: AdverseEvent Note: Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter.","title":"Class Names"},{"location":"cimpl6Reference/#fully-qualified-names","text":"CIMPL does not support duplicate class names within a single namespace. However, the same name may occur in different namespaces. In the case of naming collisions due to an included namespace in Uses , you have to refer to the class by its fully qualified name (FQN). The FQN is a combination of the element's namespace and its declared name (through concatenation delimited by a period). For example, the element CancerCondition in the namespace onco.core has the following FQN: onco.core.CancerCondition FQNs are only required in case of naming collisions between namespaces.","title":"Fully Qualified Names"},{"location":"cimpl6Reference/#value-set-names","text":"Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: Value Set names must begin with an uppercase letter.","title":"Value Set Names"},{"location":"cimpl6Reference/#local-code-names","text":"Within a custom value set, the individual codes (denoted by # symbol) are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or other radiation source\" #swimming_pool \"Swimming Pool\"","title":"Local Code Names"},{"location":"cimpl6Reference/#reserved-words","text":"CIMPL has a number of reserved words and phrases that are part of CIMPL's grammar (e.g., boolean , or , from , maps to ). For a complete list of reserved words, refer to the ANTLR4 grammar .","title":"Reserved Words"},{"location":"cimpl6Reference/#whitespace","text":"Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 6.0 Namespace: myExampleNamespace is equivalent to this: Grammar: DataElement 6.0 Namespace: myExampleNamespace","title":"Whitespace"},{"location":"cimpl6Reference/#comments","text":"CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */","title":"Comments"},{"location":"cimpl6Reference/#primitives","text":"Primitives are distinguished by starting with lower case letter. CIMPL defines the following primitive data types. With the exception of concept (a simplified representation of code, Coding, and CodeableConcept), the primitive types in CIMPL align with FHIR: concept boolean integer string decimal uri base64Binary instant date dateTime time oid id markdown unsignedInt positiveInt xhtml Note: CIMPL does not have an explicit \"Reference\" type. References are determined during the mapping process.","title":"Primitives"},{"location":"cimpl6Reference/#concept-codes","text":"CIMPL uses a single primitive type, concept to represent coded terms from controlled vocabularies. A concept combines three elements: code system, code, and optional display test. The grammar for specifying concepts is: SYSTEM#code \"Display text\" For example: SCT#363346000 \"Malignant neoplastic disease (disorder)\" ICD10CM#C004 \"Malignant neoplasm of lower lip, inner aspect\" The SYSTEM is an alias for a canonical URI that represents a controlled vocabulary. Aliases must be declared in the file header using the CodeSystem keyword . You cannot use the canonical URI directly in the concept grammar. Unlike FHIR, CIMPL does not differentiate between code, Coding, and CodeableConcept. See Mapping Concept Codes for information on CIMPL maps concept to these FHIR types. Note: Future versions of CIMPL will expand concept to include the code system version.","title":"Concept Codes"},{"location":"cimpl6Reference/#keywords","text":"Keywords are used to make various declarations. Keywords always appear at the beginning of a line and are followed by a colon. Keyword Summary: | Keyword | Purpose | File Type(s) | |----------|---------|---------| | Abstract | Declare an non-instantiable class | Class | | CodeSystem | Define a code system alias | Class, Value Set | | Concept | Express the meaning of a class | Class | | Description | Provide a human-readable description | Class, Value Set | | Element | Declare lowest-level (elemental) model building block | Class | | Entry | Declare a stand-alone class | Class | | Grammar | Define how a file should be parsed | All | | Group | Declare mid-level, non-stand-alone model building block | Class | | Namespace | Associate a file with a namespace | All | | Parent | Specify inheritance | Class | | Path | Alias long URLs | Class, Value Set | | Property | Define an attribute in a class | Class | | Uses | Import namespace(s) | Class | | Value | Define data type(s) of Elements | Class | | ValueSet | Define a value set | Value Set |","title":"Keywords"},{"location":"cimpl6Reference/#abstract","text":"The Abstract keyword is used to declare a new Abstract class. Abstract classes are identical to Entries, except they are not instantiable. For details, see Class File . Example: Abstract: ActionStatement","title":"Abstract"},{"location":"cimpl6Reference/#codesystem","text":"The CodeSystem keyword provides an alias or shorthand for the canonical URI of code system. You must define a code system alias before you can use codes from that system in constraints or value sets. By convention, the alias should be be UPPER CASE, although the tooling does allow for numbers and hyphens after the first upper case letter. Examples: CodeSystem: LNC = http://loinc.org CodeSystem: SCT = http://snomed.info/sct","title":"CodeSystem"},{"location":"cimpl6Reference/#concept","text":"The Concept keyword (not to be confused with the concept primitive ) establishes the meaning of a class in terms of a code (or codes) from controlled vocabularies. Assigning a concept allows the meaning of the class to be understood without inferring it from the class name. If multiple concept codes are used, they should appear as a comma-separated list. This keyword is optional. Examples: Concept: MTH#C3858779 \"Security classification\"","title":"Concept"},{"location":"cimpl6Reference/#description","text":"The Description keyword is used for a narrative that defines the namespace, class, or value set. Example: Description: \"Oncology data elements that broadly apply to most cancer cases.\" Note: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.)","title":"Description"},{"location":"cimpl6Reference/#element","text":"The Element keyword is used to declare a new class of type Element, the lowest-level building block in CIMPL. For details, see Class File . Example: Element: EvidenceType","title":"Element"},{"location":"cimpl6Reference/#entry","text":"The Entry keyword is used to declare a new stand-alone class, analogous to a Resource or Profile in FHIR. For details, see Class File . Example: Entry: GenomicsReport","title":"Entry"},{"location":"cimpl6Reference/#grammar","text":"The Grammar keyword defines how the file is to be parsed. The grammar declaration must be the first line in each CIMPL file. File Type Required First Line Current Version # Class Grammar: DataElement #.# 6.0 Value Set Grammar: ValueSet #.# 5.1 Map Grammar: Map #.# 5.1 Note: no space in ValueSet The version details the MAJOR and MINOR version of the grammar the file was written for. The grammar version is typically note the same as the CIMPL release. Generally, the major version of the Grammar matches the major version number of CIMPL, however, at the time of the CIMPL 6.0 release, the ValueSet and Map grammar remain at 5.1.","title":"Grammar"},{"location":"cimpl6Reference/#group","text":"The Group keyword is used to declare a building block comprised of one or more properties, similar to a complex data type in FHIR. For details, see Class File . Example: Group: Dosage","title":"Group"},{"location":"cimpl6Reference/#namespace","text":"The Namespace keyword defines the association of the file with a namespace, and is required in DataElement , ValueSet and Map files. The namespace can be any number of lowercase period-delimited words. Examples: Namespace: odh Namespace: onco.core Note: While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens.","title":"Namespace"},{"location":"cimpl6Reference/#parent","text":"Through the Parent keyword, CIMPL provides a mechanism for basing a class on another class, the child inheriting all properties and constraints from the parent. The child class can then extend information inherited from the parent by adding additional properties and applying additional constraints. Additionally, mappings are inherited alongside properties. At most one parent class can be specified. The Parent declaration is optional There are restrictions on which building blocks can inherit from other building blocks. The rules can be summarized as like inherits from like : Building Block Can Inherit From Element Element Group Group Entry Abstract or Entry Abstract Abstract Note: Although the CIMPL 6.0 tooling does not currently enforce these inheritance rules, they will enforced in future releases. You are strongly encouraged to comply to these rules, and refactor any definitions ported from CIMPL 5.x that do not comply. Example: Parent: LaboratoryObservation","title":"Parent"},{"location":"cimpl6Reference/#path","text":"The Path keyword allows for abbreviations of long URLs. This functionality is completely optional, but it is provided to make authoring easier. By convention, the alias should be be an all UPPER CASE word, although the tooling does allow for numbers and hyphens after the first letter. Example: Path: FHIR = http://hl7.org/fhir/ValueSet","title":"Path"},{"location":"cimpl6Reference/#property","text":"Classes based on Group, Entry, and Abstract are composed of one or more properties (called fields or attributes in object-oriented programming). A property can be any Element, Group, or Entry, but never a primitive. Each property must have a specified cardinality range, represented as min..max , indicating the number of repeats of the property. The Property keyword cannot be used in Elements. In the following example, StudyArm has three properties: Name , Type , and Comment . Name is singular and required, Type is optional and repeating, and Comment is singular and optional: Group: StudyArm Description: \"Refers to participant(s) in a clinical trial assigned to receive specific interventions according to a protocol.\" Property: Name 1..1 Property: Type 0..* Property: Comment 0..1 Property: ResearchStudy 1..1 A property that refers to an Entry (such as ResearchStudy, above) is implicitly a reference (pointer) to an instance of that Entry, rather than implying the Entry is \"in-lined\" into the class. Note: CIMPL 5.0 Grammar use of the keyword ref() is now obsolete.","title":"Property"},{"location":"cimpl6Reference/#uses","text":"The Uses keyword appears in the Class file and provides a comma-separated list of the namespaces imported to the current namespace. This keyword allows you to use the classes and value sets defined in other namespaces. The list order has no effect. Examples: Uses: obf.datatype Uses: obf.datatype, obf, onco.core","title":"Uses"},{"location":"cimpl6Reference/#value","text":"Value represents the data type(s) an Element can accept. This keyword can only be when defining an Element. Each Element must have exactly one Value , although the value itself can be a choice of several data types. Value choices can be primitives , Elements , Groups , or Entries . A value may be inherited and constrained in the child class. Examples: Element: DetectionTime Description: \"The date on which the condition was first observed.\" Value: dateTime Element: ExpectedPerformanceTime Description: \"When an action should be performed.\" Value: dateTime or TimePeriod or Timing Element: SubstanceOrCode Description: \"A code or substance reference identifying the ingredient.\" Value: concept or Substance or Medication Although in general, constraints cannot be applied to a property or value at the same time the item is defined, you are allowed to bind a value set to a concept value choice at the same time the value is defined, as follows: Element: IsPrimaryTumor Description: \"Whether the tumor is the original or first tumor in the body, for a particular cancer.\" Value: concept from YesNoUnknownVS (required) For more information on binding, see Value Set Binding Constraint . Note: CIMPL 5.0 Grammar associating a cardinality to a Value is now obsolete.","title":"Value"},{"location":"cimpl6Reference/#valueset","text":"Defines the name of a value set defined inside CIMPL (references to external value sets are also allowed). By convention, all value sets should be Pascal case, start with the name of the corresponding concept-type Element that is being bound to the value set, and end with VS . Example: ValueSet: ProposedStatusVS","title":"ValueSet"},{"location":"cimpl6Reference/#cimpl-paths","text":"CIMPL provides grammar that allows you to refer to any part of a CIMPL class, regardless of nesting. This section outlines CIMPL Path Grammar, which is used in constraints and mapping .","title":"CIMPL Paths"},{"location":"cimpl6Reference/#dot-notation","text":"Dot notation is used to denote nested properties. The path lists the properties in order, separated by a dot (.) For example, if Patient has a ContactPoint , and ContactPoint has a Priority , then the path to Priority is Patient.ContactPoint.Priority .","title":"Dot Notation"},{"location":"cimpl6Reference/#entries-terminate-paths","text":"An Entry can appear in a path only as its final element. Paths represent nested containment within one class, and Entries are independent objects. Paths cannot \"hop\" from one Entry to another. For example, Procedure has a Patient property, and while Procedure.Patient is a valid path, Procedure.Patient.gender is not. The former path can be used to set the cardinality of Patient within the Procedure class, but the latter would (illegally) constrain an attribute within Patient from inside Procedure .","title":"Entries Terminate Paths"},{"location":"cimpl6Reference/#bracket-notation-for-value-choices","text":"Values can offer a choice of data types . Bracket notation is used to refer to a particular value choice. Bracket notation must always be used when an Element is part of a CIMPL path. How value choices appear in paths depends on whether the path appears with an Element definition or not. Inside an: Refer to the Value choices as: Element Value[choice] Entry or Group ElementName[choice] Example: Entry: Procedure Property: Priority 0..1 Priority[concept] = SCT#394849002 \"High Priority\" // not Value[concept] Element: Priority Value: integer or concept Value[concept] from PriorityVS (required) // not Priority[concept] Note: The requirement in CIMPL 6.0 to use bracket notation even when the value has only one choice is a change from CIMPL 5.","title":"Bracket Notation for Value Choices"},{"location":"cimpl6Reference/#path-example","text":"Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Group: Location Description: \"Location of the landmark\" Property: Code 0..1 Property: Laterality 0..1 Property: Orientation 0..1 Element: Distance Description: \"How far the body location of interest is from the given landmark.\" Value: Quantity Element: Direction Description: \"The direction from the landmark to the body location of interest.\" Value: ClockFaceDirection or AnatomicalDirection Element: ClockFaceDirection Description: \"A direction indicated by o'clock position or degrees relative to 12 o'clock.\" Value: concept or Angle Group: Quantity Description: \"A quantity with units.\" Property: Number 0..1 Property: Comparator 0..1 Property: Units 0..1 This example assumes all paths begin at Landmark. Path to Path Direction Landmark.Direction Laterality Landmark.Location.Laterality ClockFaceDirection Landmark.Direction[ClockFaceDirection] Angle Landmark.Direction[ClockFaceDirection][Angle] Units Landmark.Distance[Quantity].Units A reliable method to create a CIMPL path is to first view it as a dot path, then bracket any part of the path that is a Value, and finally, remove the dot before each left (open) bracket. Here's an example of that process, for the path from Landmark to Units: 1) Find the path: Landmark to Distance , Distance to Quantity , Quantity to Units . 1) Reduce to dot path: Landmark.Distance.Quantity.Units 1) Bracket each Value: Landmark.Distance.[Quantity].Units 1) Remove dot before left (open) bracket: Landmark.Distance[Quantity].Units","title":"Path Example"},{"location":"cimpl6Reference/#constraints","text":"Constraints are a way to shape a general model for a particular purpose. Properties, values, and value choices can be constrained. Constraint targets can be be top-level or deeply nested (the latter referred to using CIMPL paths ), inherited or locally-defined. Unlike keyword declarations, constraint statements do not begin with a keyword. Most constraint statements have three parts: The subject of the constraint A reserved word or phrase indicating the type of constraint The constraint value being applied Here are several examples of this pattern: Example Subject Reserved word Value applied IsPrimaryTumor = true IsPrimaryTumor = true Specimen substitute TumorSpecimen Specimen substitute TumorSpecimen BodyLocation from BodyLocationVS BodyLocation from BodyLocationVS LanguageUsed 0..1 LanguageUsed (implicit) 0..1 Here is a summary of constraints supported in CIMPL 6: To do this.. Use this Keyword or Symbol Applies to Narrow cardinality {min}..{max} Property Assign a fixed value = Property or Value[Choice] Append a fixed value to an array += Array Property Narrow a data type substitute Property or Value[Choice] Bind a value set from Property or Value[Choice] Slice an array includes Array Property Narrow choices for a value only Value","title":"Constraints"},{"location":"cimpl6Reference/#cardinality-constraint","text":"Cardinality defines the number of repeats that can exist for a property. Cardinality is specified using FHIR syntax, {min}..{max}, where the first integer indicates the minimum repeats (0 implying optional), and the second digit expresses the upper bound on the number of repeats. To express no upper bound, a * is used. When constraining cardinality, you can only narrow the previously declared cardinality. The cardinality constraint only applies to properties. Declaration Constraint Subsequent Constraint Property: LanguageUsed 0..* LanguageUsed 0..1 LanguageUsed 0..0 Property: GovernmentIssuedID 0..* GovernmentIssuedID 1..* GovernmentIssuedID 1..1 Property: Status 1..1 Status 0..1 invalid Note: By constraining a property to 0..0, you effectively remove the property. Use 0..0 with caution, because if an instance does include that property, the instance will fail validation and may be rejected.","title":"Cardinality Constraint"},{"location":"cimpl6Reference/#fixed-value-constraint","text":"The = operator fixes a property to a specific value (e.g., a specific code, boolean value, etc.). The assigned value must be consistent with the defined data type, and is always a primitive. Fixed value constraints apply to properties and value choices. Example Syntax Fix a code to a property ObservationCode = LNC#82810-3 Fix a boolean value to a property IsPrimaryTumor = true Fix a code to a value choice Value[concept] = SCT#233613009 \"Pneumonia\" Fix the units associated with a Quantity value choice Value[Quantity].Units = UCUM#cm Fix a code to a value Value = SCT#233613009 \"Pneumonia\" invalid Notes: 1) Bracket notation must always be used when applying a constraint to a value choice, even if the value has only one choice . This is a change from CIMPL 5. 1) CIMPL allows fixed concept values to be overridden in child classes. Although this seems to violate the notion that constraints should get progressive tighter in subclasses, it is necessary when narrowing the meaning of a class characterized by a concept code. For example, the class Pneumonia , with fixed code, SCT#233604007 , may have a child, Fungal Pneumonia , with fixed code SCT#233613009 , the latter overriding the former. CIMPL will assume, without checking, that the code describing the child class has more constrained semantics than the code it replaces. 1) Fixing numerical types and strings (including URLs) is not yet supported, although this feature is planned. 1) If you only need to fix a value code for one particular mapping (one version of FHIR, for example), do so using the fix keyword in the mapping file.","title":"Fixed Value Constraint"},{"location":"cimpl6Reference/#append-constraint","text":"The append ( += ) operator appends a fixed primitive value (boolean, concept, etc.) to an array property. You can use the += operation repeatedly on the same array, limited only be the cardinality of the array. The append operator can only be applied to repeating properties. For example, you would use += to insert a particular Social Security Number (SSN) or Driver's License number into an array of identifiers (in contrast, includes would be used to require the array contain one or more SSNs, without specifying a particular SSN.) Example Syntax Insert \"Behavior\" into Category array Category += LNC#54511-1 \"Behavior\" Add \"Social History\" to same array Category += OBSCAT#social-history \"Social History\"","title":"Append Constraint"},{"location":"cimpl6Reference/#substitute-constraint","text":"The substitute keyword constrains the data type of a property. The new data type that is substituted for the original must be a subclass of the original data type. Example Syntax Constrain the property Specimen to be a TumorSpecimen Specimen substitute TumorSpecimen note: TumorSpecimen must be a subclass of Specimen Constrain a value choice of type Quantity to SimpleQuantity Value[Quantity] substitute SimpleQuantity note: SimpleQuantity is a subclass of Quantity","title":"Substitute Constraint"},{"location":"cimpl6Reference/#value-set-binding-constraint","text":"Binding is the process of associating a concept with a set of possible values. Binding uses the keyword from . The object of a binding must be an Element whose value is a concept. The value set that is being bound can be a value set defined in CIMPL or a canonical URL external to CIMPL. CIMPL uses the same binding strengths as FHIR , namely: required (strongest) indicates that the code must come from the specified value set. extensible indicates that the code must come from the specified set if the value set contains a relevant code ; otherwise a code outside the value set may be chosen. preferred indicates that the code should ideally come from the specified value set, but codes outside the value set may also be chosen. example (weakest) indicates that the code may come from anywhere; the specified value set is for example purposes only. The following rules apply to binding in CIMPL 6: If no binding strength is specified, the binding is assumed to be required . When further constraining an existing binding, the binding strength can stay the same or be made tighter (e.g., replacing an preferred binding with an extensible or required binding), but never loosened. Constraining may leave the binding strength the same and change the value set instead. However, certain changes permitted in CIMPL may violate FHIR profiling principles . In particular, FHIR will permit a required value set to be replaced by another required value set only if the codes in the new value set are a subset of the codes in the original value set. For extensible bindings, the new value set can contain codes not in the existing value set, but additional codes SHOULD NOT have the same meaning as existing codes in the base value set. Example Syntax Required binding of a Property (property is an Element with concept data type) ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (required) Required binding of a Property (by default) ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical Extensible binding of a Property ReasonCode from ReasonCodeVS (extensible) Preferred binding of a Property BodyLocation from BodyLocationVS (preferred) Required binding of a Value Choice that is a concept Value[concept] from http://hl7.org/fhir/ValueSet/condition-clinical (required) Required binding of a Value Choice that is an Element with whose value is a ClinicalStatus Value[ClinicalStatus] from http://hl7.org/fhir/ValueSet/condition-clinical (required)","title":"Value Set Binding Constraint"},{"location":"cimpl6Reference/#includes-constraint","text":"The includes constraint is used to specify that a repeating property (array) should contain a certain class or classes. FHIR refers to this as slicing . In CIMPL, it is a simple matter of saying an array includes certain types of elements. The includes statement has several requirements: The elements included in the array must conform to the data type of the array. For example, if the array is Identifier 0..* , the items included in the array must be Identifiers or be inherit from Identifier. Cardinality of each inclusion must be specified, and must fit the cardinality of the array. For example, if the array property has a finite maximum cardinality, you cannot include an element with cardinality 0..*. The keyword includes is repeated for each item the array should contain. The includes constraint does not apply to Values. Here is an example: Measurement 0..* // the array property ... Measurement includes TumorLength 1..1 includes TumorWidth 0..1 includes TumorDepth 0..1 TumorLength, TumorWidth, and TumorDepth all must inherit from Measurement, because Measurement is the array property being sliced. Optionally, the second statement can be written on separate lines (since CIMPL is whitespace insensitive): Measurement includes TumorLength 1..1 includes TumorWidth 0..1 includes TumorDepth 0..1 Here is another example: Identifier 1..* // the array property ... Identifier includes NationalProviderIdentifier 0..1 includes TaxIdentificationNumber 0..1 In this case, either NationalProviderIdentifier or TaxIdentificationNumber must be present, even though both are individually optional, because of the 1..* cardinality on Identifier. Note: When using includes , special mapping syntax is required. See Slicing .","title":"Includes Constraint"},{"location":"cimpl6Reference/#only-constraint","text":"Values can have multiple data types. Use the only constraint in an Element to narrow the choice of data types. The only constraint can only be applied to a Value that has multiple choices. The grammar of only constraints varies depending on whether the constraint appears in an Element, or another type of Class. Example: Element: Priority Value: integer or concept Inside Class... Grammar Element Value only integer Entry or Group Priority only integer Note: CIMPL currently does not support narrowing a choice to a more limited choice, for example, narrowing a choice of three types to two types. This feature is planned.","title":"Only Constraint"},{"location":"cimpl6Reference/#class-file","text":"Class files contain definitions of the information model.","title":"Class File"},{"location":"cimpl6Reference/#class-file-example","text":"Here is an abbreviated example of a class file: Grammar: DataElement 6.0 Namespace: obf.lab Description: \"Profiles of laboratory tests and panels.\" Uses: datatype, obf CodeSystem: LNC = http://loinc.org CodeSystem: UCUM = http://unitsofmeasure.org Abstract: SimpleQuantLabWithRequiredUnits Parent: SimpleQuantitativeLaboratoryObservation Description: \"Laboratory tests that must be reported with units.\" DataValue 1..1 DataValue only QuantityWithRequiredUnits DataAbsentReason 0..0 Group: QuantityWithRequiredUnits Parent: Quantity Description: \"A quantity with that requires a coded unit of measure.\" Units 1..1 Entry: GlobulinMCncPtSerQnCalculatedLabObs Parent: SimpleQuantLabWithRequiredUnits Description: \"Globulin [Mass/\u200bvolume] in Serum by calculation\" Code = LNC#10834-0 \"Globulin [Mass/\u200bvolume] in Serum by calculation\" DataValue[Quantity].Units from EquivalentUnitsVS-g-per-L (required)","title":"Class File Example"},{"location":"cimpl6Reference/#class-file-header","text":"The elements of the class file header are (in order): 1) Grammar (required) 1) Namespace (required) 1) Description (recommended; once per namespace) 1) Uses (optional; as needed) 1) CodeSystem (optional; as needed) 1) Path (optional) For a further description, see Keywords . Note: Uses imports namespaces whose classes can be used as if they were locally defined. However, if a class name in an imported namespace collides with a local class name, you must refer to that element by its fully qualified name .","title":"Class File Header"},{"location":"cimpl6Reference/#class-definitions","text":"Following the header, the class file contains a number of class definitions. The order of definitions does not matter. A class definition has a sequence of declarations, although after the first declaration, a strict order is not prescribed. Follow the links for further explanation of each item: 1) Class Type and Name Declaration (required) 1) Parent Declaration (optional) 1) Concept Declaration (optional) 1) Description (optional but highly recommended) 1) Property Declarations (for Entry, Abstract and Group) or Value Declaration (for Element) (optional, but typically present) 1) Constraint statements (optional)","title":"Class Definitions"},{"location":"cimpl6Reference/#class-type-and-name-declaration","text":"The first line of all class definitions is a keyword representing the type of building block, followed by a descriptive name you choose. Class names must be unique within a given namespace. CIMPL provides four types of building blocks: Building Block Description Has... Analogous FHIR Type Element The lowest-level building block, representing a property-value pair. Value Property or simple extension Group A building block comprised of other building blocks, specifically, other Groups, Elements, and Entries. Properties Backbone element or complex extension Entry A building block representing a group of related information, complete enough to support stand-alone interpretation. Properties Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Properties none","title":"Class Type and Name Declaration"},{"location":"cimpl6Reference/#properties-and-values","text":"When defining classes, bear in mind that an Element has exactly one Value field and no Property fields, whereas, a Group , Entry , or Abstract can have multiple Property fields but cannot have a Value field. Furthermore, a Property cannot have choices, but a Value can. These differences are illustrated in this example: Element: ExpectedPerformanceTime Description: \"When an action should be performed.\" Value: dateTime or TimePeriod or Timing Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Summary: Keyword Appears in How Many Times? Has Cardinality? Has Choices? Can be a... Value Element Exactly Once No Yes (optionally) primitive, Element, Group, or Entry Property Group , Entry , or Abstract Zero or more Yes No Element, Group, or Entry","title":"Properties and Values"},{"location":"cimpl6Reference/#naming-recommendations","text":"All classes in CIMPL, from Elements to Entries, are reusable outside of their original context. To promote reuse, try to choose names that are self-explanatory and context-independent. For example, a property named Text is too vague, whereas DisplayText and InstructionText are more self-explanatory and may be completely understandable when placed into a specific context. However, an overly-specific name like AddressDisplayText could inhibit reuse because it affixes the context of an address to the concept of a display text.","title":"Naming Recommendations"},{"location":"cimpl6Reference/#value-set-file","text":"The value set files are used to define custom value sets and codes when existing value set sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient, and a new value set must be defined.","title":"Value Set File"},{"location":"cimpl6Reference/#value-set-file-example","text":"A (truncated) example value set file is shown below: Grammar: ValueSet 5.1 Namespace: onco.core CodeSystem: SCT = http://snomed.info/sct CodeSystem: ICD10CM = http://hl7.org/fhir/sid/icd-10-cm ValueSet: CancerDiseaseStatusEvidenceTypeVS Description: \"The type of evidence backing up the clinical determination of cancer progression.\" SCT#363679005 \"Imaging (procedure)\" SCT#252416005 \"Histopathology test (procedure)\" SCT#711015009 \"Assessment of symptom control (procedure)\" SCT#5880005 \"Physical examination procedure (procedure)\" SCT#250724005 \"Tumor marker measurement (procedure)\" SCT#386344002 \"Laboratory data interpretation (procedure)\" ValueSet: SecondaryCancerDisorderVS Description: \"Types of secondary malignant neoplastic disease\" Includes codes descending from SCT#128462008 \"Secondary malignant neoplastic disease (disorder)\" ICD10CM#C7B00 \"Secondary carcinoid tumors, unspecified site\" ICD10CM#C7B01 \"Secondary carcinoid tumors of distant lymph nodes\" ICD10CM#C7B02 \"Secondary carcinoid tumors of liver\" ICD10CM#C7B03 \"Secondary carcinoid tumors of bone\" ICD10CM#C7B04 \"Secondary carcinoid tumors of peritoneum\"","title":"Value Set File Example"},{"location":"cimpl6Reference/#value-set-file-header","text":"Grammar and Namespace are required keywords in a Value Set file header. One or more CodeSystem will be needed. For a further description, see Keywords .","title":"Value Set File Header"},{"location":"cimpl6Reference/#value-set-definition","text":"Following the header, the Value Set file contains a number of value set definitions. The order of definitions does not matter. Each definition follows a set sequence of declarations. Follow the links for further explanation of each item: 1) Value Set Declaration (required) 1) Description (optional but highly recommended) 1) Code Declarations (optional) 1) Includes Codes statements (optional)","title":"Value Set Definition"},{"location":"cimpl6Reference/#explicit-codes","text":"Explicit code declarations are used to add specific codes to a value set. Codes can either be locally-defined, or selected from external code systems, such as the CAP#29915 example, in which 29915 is an existing code within the CAP code system. If the code is defined locally, the namespace serves as the code system. For the syntax of concept codes, see Concept Codes . Type Example Locally-defined code #proposed \"The proposal has been proposed, but not accepted or rejected.\" Externally-defined code CAP#29915 \"None/Negative\"","title":"Explicit Codes"},{"location":"cimpl6Reference/#implicit-codes","text":"Implicit code declarations are used to add sets of codes to a value set, in particular, from hierarchically-defined code systems. At present, the only hierarchical system supported is SNOMED-CT. There are three variants involving the Includes codes phrase: Phrase Example Result Includes codes from Includes codes from MDR Value set contains all codes from MDR code system Includes codes descending from Includes codes descending from SCT#105590001 Value set contains SCT#1055900001 and all codes below it in the SNOMED-CT hierarchy and not descending from Includes codes descending from SCT#363346000 \"Malignant neoplastic disease\" and not descending from SCT#128462008 \"Secondary malignant neoplastic disease\" Value set contains SCT#363346000 and all codes below it in the SNOMED-CT hierarchy, except code SCT#128462008 and all codes below it","title":"Implicit Codes"},{"location":"cimpl6Reference/#map-file","text":"Map files control how classes defined in CIMPL are expressed as FHIR profiles. Map files are FHIR-version dependent. Currently, you can map to FHIR DSTU 2, STU 3, R4. If you use the supplied Objective FHIR base classes , you many not need to create a map file.","title":"Map File"},{"location":"cimpl6Reference/#inheritance-of-mapping-rules","text":"Maps are defined in a series of mapping rules. A powerful feature of CIMPL is that mapping rules are inherited. If your class that inherits from a parent class that already is mapped, you do not need to create a new map for your class. However, if you you want specify mappings for new properties, or override the inherited map, you may do so. The inheritance of mapping rules follows the class hierarchy. If there is no map for a class or attribute, CIMPL tooling automatically looks to the parent class to try and find a mapping. The first mapping rule found will be applied. If no mapping rule is found for a property defined in CIMPL, a FHIR extension will be created. If no mapping is found for an Entry, that Entry will be mapped to the Basic resource . In general, mapping to Basic is not recommended because it has no inherent semantic meaning for implementers. Any unmapped properties will appear as FHIR extensions.","title":"Inheritance of Mapping Rules"},{"location":"cimpl6Reference/#mapping-cimpl-primitives-to-fhir","text":"CIMPL follows somewhat flexible rules on how CIMPL primitives map to FHIR. For example, a unsignedInt in CIMPL can map to an integer type in FHIR (since every unsignedInt is an integer, there is no loss of information). However, mappings that lose information, such as integer in CIMPL to unsignedInt in FHIR, generally will trigger mapping errors. An exception is that CIMPL concept is allowed to map to FHIR code . The following table shows the acceptable mappings between CIMPL and FHIR: CIMPL Primitive Can map to FHIR... concept code, Coding, CodableConcept boolean boolean, code integer integer, Quantity string string decimal decimal uri uri base64Binary base64Binary instant instant date date dateTime dateTime, date, instant time time oid oid id id markdown markdown, string unsignedInt unsignedInt, integer, Quantity positiveInt positiveInt, unsignedInt, integer, Quantity xtml xtml","title":"Mapping CIMPL Primitives to FHIR"},{"location":"cimpl6Reference/#map-file-example","text":"Grammar: Map 5.1 Namespace: obf Target: FHIR_STU_3 Dosage maps to Dosage: DoseSequenceNumber maps to sequence InstructionText maps to text InstructionCode maps to additionalInstruction PatientInstruction maps to patientInstruction Timing maps to timing AsNeeded maps to asNeeded[x] AdministrationSite maps to site RouteIntoBody maps to route Method maps to method DoseAndRate.DoseAmount maps to dose[x] DoseAndRate.DoseRate maps to rate[x] MaxDosePerPeriod maps to maxDosePerPeriod MaxDosePerAdministration maps to maxDosePerAdministration MaxDosePerLifetime maps to maxDosePerLifetime MedicationStatement maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-medicationstatement: Identifier maps to identifier MedicationBasedOn maps to basedOn MedicationStatementPartOf maps to partOf CareContext maps to context Status maps to status StatusReason maps to extension Category maps to category MedicationCodeOrReference maps to medication[x] OccurrenceTimeOrPeriod maps to effective[x] StatementDateTime maps to dateAsserted MedicationInformationSource maps to informationSource SubjectOfRecord maps to subject SupportingInformation maps to derivedFrom fix taken to #y constrain reasonNotTaken to 0..0 constrain dosage to 0..1 ReasonCode maps to reasonCode MedicationReasonReference maps to reasonReference Annotation maps to note Dosage maps to dosage","title":"Map File Example"},{"location":"cimpl6Reference/#map-file-header","text":"The header of a map file must include a Grammar , Namespace , and Target keywords. The Target keyword gives the version of FHIR that the CIMPL model is mapped to, either FHIR_DSTU_2 , FHIR_STU_3 , or FHIR_R4 . For a further description of the header keywords, see Keywords .","title":"Map File Header"},{"location":"cimpl6Reference/#setting-the-mapping-target","text":"Each block in a mapping file begins with statement that establishes a resource, profile, or complex data type that is the target for the mapping. In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in the target output. The mapping target can be a FHIR resource or profile that is part of the target FHIR release version. The initial statement in each mapping block must end with a colon (:). CIMPL Building Block FHIR Target Example Entry Resource SocialHistoryObservation maps to Observation: Entry Profile LaboratoryObservation maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-observationresults: Group Complex Datatype Timing maps to Timing:","title":"Setting the Mapping Target"},{"location":"cimpl6Reference/#mapping-properties","text":"After the first line, the remainder of the block consists of statements that map CIMPL properties to FHIR elements. Each statement begins with a CIMPL path , followed by the phrase maps to , and ending with the target FHIR path. With FHIR as the target output, the right-hand side of the map statement can point to any field on a FHIR resource, including: Fields that are at the root of the resource (e.g., maritalStatus ) Fields that are child elements of root elements on the resource (e.g., reaction.substance ) Fields that have a choice of data types (e.g., multipleBirth[x].boolean ) Fields that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity ) Fields that support FHIR Reference() types. CIMPL type FHIR type Example Property element MaritalStatus maps to maritalStatus Property extension Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity Path element Value.ActiveFlag maps to active Path path AdverseReaction.AllergenIrritant maps to reaction.substance Value choice element BodySiteOrCode[concept] maps to bodySite","title":"Mapping Properties"},{"location":"cimpl6Reference/#mapping-to-references","text":"FHIR resources and profiles require an explicit Reference() indicator when referring to another resource or profile. In CIMPL, this is not required or allowed. CIMPL follows the rule that whenever a property is an Entry, that property is mapped as a reference in FHIR. Example: CIMPL Definition Corresponding FHIR Property: Encounter 0..1 encounter: 0..1 Reference(Encounter)","title":"Mapping to References"},{"location":"cimpl6Reference/#placement-of-extensions","text":"As mentioned above, if no mapping rule is found for a property, an extension will be automatically created. By default, the extension will be a top-level element in the FHIR profile. Sometimes you may want the extension to appear in a different place, perhaps inside a nested element. To put the extension precisely where you want it, you can map to FHIR paths that include extension . Here's an example involving AdverseEvent: PotentialCause.CauseCategory maps to suspectEntity.extension This rule will create an extension named CauseCategory under AdverseEvent.suspectEntity, rather than directly under AdverseEvent. Note that rules such as this: DetectionTime maps to extension leave the default behavior unchanged, and are not required. However, they can be used to document the intent to create an extension.","title":"Placement of Extensions"},{"location":"cimpl6Reference/#special-mapping-statements","text":"","title":"Special Mapping Statements"},{"location":"cimpl6Reference/#fix","text":"fix allows FHIR fields to be assigned a value. Note that it is the FHIR resource that is getting the value, not the CIMPL class. This enables you to fix a FHIR value without having change the class definition, which would affect all potential mappings. Example: fix status to #completed","title":"fix"},{"location":"cimpl6Reference/#constrain","text":"constrain allows users to constrain the cardinality of FHIR elements. Note that is the FHIR resource that is getting the constraint, not the CIMPL class. The cardinality is expressed in {min}..{max} form. Keyword Example constrain constrain explanation to 0..1","title":"constrain"},{"location":"cimpl6Reference/#slicing","text":"When fields are allowed to repeat on a target model (e.g., have cardinality with an upper bound greater than 1), it is common practice to specify which CIMPL elements are mapped to instances of that repeated field on the target model. This process is called slicing . For example, the FHIR Task resource allows for an arbitrary number of input fields to be added. To ensure that each input field is uniquely addressable by a parsing engine, those inputs need to be differentiated by a discriminator . See the FHIR documentation for more detail about slicing and discriminators .","title":"Slicing"},{"location":"cimpl6Reference/#slicing-strategies","text":"Slicing is used when there is a variation of how an individual element is represented and a need to model it as a sub-list. An example of this is the FHIR Blood Pressure profile , which can be considered an observation with two components which are identical in structure other than their represented code. In CIMPL, slicing strategies are specified in the map file. Two reserved phrases are used in conjunction to specify the slide: slice on slice strategy Examples of its usage in a statement are shown below: Phrase Example slice on / slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) slice on / slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) slice on Laterality maps to qualifier (slice on = concept)","title":"Slicing Strategies"},{"location":"cimpl6Reference/#declaring-a-discriminator","text":"To perform any slicing, a discriminator needs to be declared, using slice on followed by the discriminator. CIMPL supports the FHIR processing types for discriminators: Discriminator Definition value The slices have different values in the nominated element exists The slices are differentiated by the presence or absence of the nominated element pattern The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x] type The slices are differentiated by type of the nominated element to a specified profile profile The slices are differentiated by conformance of the nominated element to a specified profile (not recommended)","title":"Declaring a Discriminator"},{"location":"cimpl6Reference/#moving-the-slice-location","text":"If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Reserved Phrase Example slice at Members.Observation maps to related.target (slice at = related; slice on type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occurring at related.target . Instead, the slice at = related ensures that the slicing is occurring at the related element.","title":"Moving the Slice Location"},{"location":"cimpl6Reference/#appendix-a-changes-from-cimpl-5x","text":"For those who have created detailed models using CIMPL 5.0, there have been significant grammar changes to CIMPL 6.0. The table below summarizes these changes: Change Type Change Description CIMPL 5.0 Example CIMPL 6.0 Example Section New keyword only eliminates all value choices except one None FindingResult only concept Only Constraint New keyword Property is required to define properties for an Entry or Element. 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword Replace EntryElement keyword replaced by Entry EntryElement: CourseOfTreatmentPerformed Entry: CourseOfTreatmentPerformed Element Keyword Replace Based on keyword replaced by Parent Based on: Observation Parent: Observation Parent Keyword Syntax change Cardinality is specified after the property or class name 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword , Cardinality Constraint Replace is constraint for fixed values replaced by = FindingTopicCode is LNC#48676-1 FindingTopicCode = LNC#48676-1 Field Constraints Replace substitution of a more specific element derived from a parent element using is type keyword replaced by substitute . Specimen is type BreastSpecimen Specimen substitute BreastSpecimen Substitute Replace code , Coding , and CodeableConcept primitives are replaced by a new primitive concept Value: CodeableConcept from AttributionCategoryVS Value: concept from AttributionCategoryVS Primitives Replace must be , should be , could be , and if covered value set constraints are obsolete and replaced by (required) , (preferred) , (extensible) , and (example) Type from BreastSpecimenTypeVS if covered Type from BreastSpecimenTypeVS (required) Value Set Binding Constraint Replace ref() is now obsolete. value is type replaced by substitute and bracket notation denoting value choices SourceSpecimen value is type ref(BreastSpecimen) SourceSpecimen[Specimen] substitute BreastSpecimen Mapping to References","title":"Appendix A: Changes from CIMPL 5.x"},{"location":"cimpl6Tutorial_detail/","text":"CIMPL 6.0 In-depth Tutorial This is an extensive tutorial, meant to educate people about many different aspects of CIMPL. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Reference documentation . TBD","title":"CIMPL 6.0 In-depth Tutorial"},{"location":"cimpl6Tutorial_detail/#cimpl-60-in-depth-tutorial","text":"This is an extensive tutorial, meant to educate people about many different aspects of CIMPL. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Reference documentation . TBD","title":"CIMPL 6.0 In-depth Tutorial"},{"location":"cimpl6Tutorial_helloWorld/","text":"CIMPL 6.0 'Hello World' Tutorial Let\u2019s do a \u201cHello, World\u201d using CIMPL v6! Note: Make sure you have completed the CIMPL Installation instructions before proceeding, and that shr-cli is installed in ~/cimpl/shr-cli . Start by creating a folder structure for our new project. Open up your favorite (Unix-based) command-line tool and enter the following: cd ~/cimpl mkdir hello_world Now, create a file called HelloWorld.txt in the ~/cimpl/hello_world folder and add the following data definitions: Grammar: DataElement 6.0 Namespace: hello Description: \"A simple example of CIMPL.\" EntryElement: HelloWorld Description: \"A silly profile.\" Property: SayHello 0..1 Element: SayHello Description: \"An extension indicating whether to say hello\" Value: boolean Next, create a file called HelloWorld_map.txt that defines the mapping to FHIR. Since this doesn\u2019t align with any particular resource, it will map to Basic . This file is even simpler: Grammar: Map 6.0 Namespace: hello Target: FHIR_STU_3 HelloWorld maps to Basic: We didn\u2019t map the SayHello data element to an existing element inside this resource, so it will automatically appear as an extension. Next, we need some simple HTML for the Implementation Guide pages, so create an exampleIndexContent.html file with the following content: HELLO HELLO HELLO Finally, we need a configuration file. Create an ig-hello_world-config.json file with these contents: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"npmName\": \"hello_world\", \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } } Now, go back to your shr-cli installation and run the hello world: cd ~/cimpl/shr-cli node . -c ig-hello_world-config.json ../hello_world When the program runs, it will output a warning message alerting you that mapping to Basic usually isn\u2019t the best choice, but in this case, it is intentional. After the program runs, the generated profile (a FHIR StructureDefinition ) will be found in ~/cimpl/shr-cli/out/fhir/profiles/ . StructureDefinition s are verbose, and this one clocks in at several hundred lines. A friendlier view is created when we create an implementation guide (IG). To do this, we use the existing FHIR implementation guide (IG) publisher . IG Generation with a Proxy Server Note: If your organization uses a proxy server, you'll need to explicitly declare a few options. If your organization does not use a proxy server, you can skip ahead to IG Generation . On Windows: java %JAVA_OPTS% -Xms4g -Xmx8g -jar out/fhir/guide/org.hl7.fhir.igpublisher.jar -ig out/fhir/guide/ig.json Note: users have reported issues with running the IG publisher on windows behind a proxy. Please try to run the IG publisher without connecting to a proxy On Linux/MacOS: java $JAVA_OPTS -Xms4g -Xmx8g -jar out/fhir/guide/org.hl7.fhir.igpublisher.jar -ig out/fhir/guide/ig.json IG Generation (without a Proxy Server) To generate the IG, run: cd ~/cimpl/shr-cli yarn run ig:publish Note : If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. The generated profile page will be located at ~/cimpl/shr-cli/out/fhir/guide/output/StructureDefinition-hello-HelloWorld.html . Open this page in your favorite web browser. Note: the IG is automatically branded as part of the Standard Health Record (SHR). We are working on \u201cde-branding\u201d the IG, so please ignore the SHR references for now. You should see a FHIR profile that looks like a traditional FHIR Implementation Guide . For a more comprehensive understanding of the CIMPL grammar and how to use it for your project, continue to the Tutorial .","title":"CIMPL 6.0 'Hello World' Tutorial"},{"location":"cimpl6Tutorial_helloWorld/#cimpl-60-hello-world-tutorial","text":"Let\u2019s do a \u201cHello, World\u201d using CIMPL v6! Note: Make sure you have completed the CIMPL Installation instructions before proceeding, and that shr-cli is installed in ~/cimpl/shr-cli . Start by creating a folder structure for our new project. Open up your favorite (Unix-based) command-line tool and enter the following: cd ~/cimpl mkdir hello_world Now, create a file called HelloWorld.txt in the ~/cimpl/hello_world folder and add the following data definitions: Grammar: DataElement 6.0 Namespace: hello Description: \"A simple example of CIMPL.\" EntryElement: HelloWorld Description: \"A silly profile.\" Property: SayHello 0..1 Element: SayHello Description: \"An extension indicating whether to say hello\" Value: boolean Next, create a file called HelloWorld_map.txt that defines the mapping to FHIR. Since this doesn\u2019t align with any particular resource, it will map to Basic . This file is even simpler: Grammar: Map 6.0 Namespace: hello Target: FHIR_STU_3 HelloWorld maps to Basic: We didn\u2019t map the SayHello data element to an existing element inside this resource, so it will automatically appear as an extension. Next, we need some simple HTML for the Implementation Guide pages, so create an exampleIndexContent.html file with the following content: HELLO HELLO HELLO Finally, we need a configuration file. Create an ig-hello_world-config.json file with these contents: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"npmName\": \"hello_world\", \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } } Now, go back to your shr-cli installation and run the hello world: cd ~/cimpl/shr-cli node . -c ig-hello_world-config.json ../hello_world When the program runs, it will output a warning message alerting you that mapping to Basic usually isn\u2019t the best choice, but in this case, it is intentional. After the program runs, the generated profile (a FHIR StructureDefinition ) will be found in ~/cimpl/shr-cli/out/fhir/profiles/ . StructureDefinition s are verbose, and this one clocks in at several hundred lines. A friendlier view is created when we create an implementation guide (IG). To do this, we use the existing FHIR implementation guide (IG) publisher .","title":"CIMPL 6.0 'Hello World' Tutorial"},{"location":"cimpl6Tutorial_helloWorld/#ig-generation-with-a-proxy-server","text":"Note: If your organization uses a proxy server, you'll need to explicitly declare a few options. If your organization does not use a proxy server, you can skip ahead to IG Generation . On Windows: java %JAVA_OPTS% -Xms4g -Xmx8g -jar out/fhir/guide/org.hl7.fhir.igpublisher.jar -ig out/fhir/guide/ig.json Note: users have reported issues with running the IG publisher on windows behind a proxy. Please try to run the IG publisher without connecting to a proxy On Linux/MacOS: java $JAVA_OPTS -Xms4g -Xmx8g -jar out/fhir/guide/org.hl7.fhir.igpublisher.jar -ig out/fhir/guide/ig.json","title":"IG Generation with a Proxy Server"},{"location":"cimpl6Tutorial_helloWorld/#ig-generation-without-a-proxy-server","text":"To generate the IG, run: cd ~/cimpl/shr-cli yarn run ig:publish Note : If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. The generated profile page will be located at ~/cimpl/shr-cli/out/fhir/guide/output/StructureDefinition-hello-HelloWorld.html . Open this page in your favorite web browser. Note: the IG is automatically branded as part of the Standard Health Record (SHR). We are working on \u201cde-branding\u201d the IG, so please ignore the SHR references for now. You should see a FHIR profile that looks like a traditional FHIR Implementation Guide . For a more comprehensive understanding of the CIMPL grammar and how to use it for your project, continue to the Tutorial .","title":"IG Generation (without a Proxy Server)"},{"location":"cimpl6UserGuide/","text":"CIMPL Authoring The purpose of this guide is to educate people about many different aspects of creating CIMPL models and its supporting utilities. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Reference documentation . Table Of Contents CIMPL Authoring Authoring Environment Setting up the VSCode Authoring Navigating a CIMPL Model within VSCode Using CIMPL to create FHIR-based Models An Approach to CIMPL Modeling for FHIR Mapping to FHIR Specifying FHIR \"MustSupport\" Elements Embedding FHIR Examples in the IG IG Publisher Output Support Authoring Environment Any text editor can be used to write CIMPL grammar. However, VSCode editor is recommended to take advantage of custom-developed to better navigate CIMPL constructs. Setting up the VSCode Authoring Note: VSCode UI screenshots in this section were taken from a MacOS environment. While the overall functionality is the same across supported OS platforms, installation and configuration specifics might differ. Reference the VSCode documentation pertinent to your OS platform. Download the VSCode editor . Open VSCode and search for the extension vscode-lang-cimpl . The figure below shows where to find VSCode extensions. Navigating a CIMPL Model within VSCode Elements properties can be previewed in the following ways: hovering over the element. placing the cursor on the element text and right-clicking option Peek Definition placing the cursor on the element text and right-clicking option Go to Definition Hovering over the element: Using Peek Definition : Using Go to Definition : Using CIMPL to create FHIR-based Models With the environment now configured, we now turn our attention to how to create a clinical model. CIMPL is designed to be modular and extensible, allowing for the reuse of other logical models, and inheriting its properties. The figure below illustrates this notion with some existing CIMPL-authored models. An Approach to CIMPL Modeling for FHIR Keeping in mind that CIMPL is primarily a way to create logical models with the capability to \"model-once, translate-many\", it is advised that the modeler first consider several requirements-gathering and specification activities noted below as a best practice instead of immediately jumping into its representation in FHIR: define the use case behind the creation of a model. create a high-level conceptual model which addresses your defined use case and can be easily understood by both technical and clinical communities. list the data elements, cardinality, and potential value sets involved (if the data type is a coded element). create the logical model in CIMPL which aligns with the high-level conceptual model and data elements noted in the previous steps. create FHIR mappings from the logical model to its equivalent FHIR resource and attributes, noting which elements you've defined in your logical model will be extensions. generate the FHIR Implementation Guide. create FHIR examples for each of the key profiles which define your IG and configure them within the CIMPL authoring environment so that they are validated by the FHIR IG Publisher. Mapping to FHIR Logical model elements are mapped to FHIR by creating and editing map files. As a best practice, CIMPL map files must have the _map.txt naming convention. Each map file should start with the following 3 lines: Grammar: Map 6.0 Namespace: data element group name Target: fhir target version Where: namespace name is the name of the grouping of elements that you have identified. fhir target version is a choice of FHIR_DSTU_2, FHIR_STU_3, or FHIR_R4 Specifying FHIR \"MustSupport\" Elements FHIR specifies a \"MustSupport\" boolean flag which allows a profile to indicates that a reference implementation must be able to process the existence of particular element in a FHIR instance and display it if contents are available. MustSupport is contextual and could vary with depending on the reference implementation. CIMPL subsequently created a separate file so that MustSupport of elements are at the IG configuration level through a Content Profile file. Content profile files are text files which use the following convention: <Content Profile Name>-cp.txt Where <Content Profile Name> is by convention the same name as the IG Configuration JSON file. The content profile filename must end in \" -cp.txt \". For example, the two file name examples of a CIMPL configuration and its respective content profile are show below: Configuration filename: myCIMPLConfiguration-ig.json Content Profile filename: myCIMPLConfiguration-cp.txt Embedding FHIR Examples in the IG Pre-requisite: the author has already created a FHIR JSON or xml. Configuring FHIR examples to appear in the generated IG involves the following steps: Create a folder which will contain your FHIR examples Modify the CIMPL configuration file to specify the folder containing your examples The folder created can be any name, as long as it is specified within the CIMPL configuration file. The folder location is specified using the \"examples:\" parameter in the CIMPL configuration file. This is illustrated in the figure below: IG Publisher Output By default, the FHIR IG Publisher will perform validation checks on the StructureDefinition of specified FHIR profiles, value sets, and examples which reference any base resources or FHIR profiles. An output of these checks are found in the CIMPL output, qa.html . An example QA output is shown in the figure below: Support Questions on using CIMPL and its toolchain can be addressed on the HL7 Zulip chat channel #cimpl Report any issues on one of the following GitHub repositories: Related to modeling of CIMPL constructs or its FHIR-based classes: https://github.com/standardhealth/shr_spec/issues Related to running the CIMPL shr-cli compiler, CIMPL export configuration files, or generating the FHIR Implementation Guide (IG): https://github.com/standardhealth/shr-cli/issues","title":"CIMPL Authoring"},{"location":"cimpl6UserGuide/#cimpl-authoring","text":"The purpose of this guide is to educate people about many different aspects of creating CIMPL models and its supporting utilities. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Reference documentation . Table Of Contents CIMPL Authoring Authoring Environment Setting up the VSCode Authoring Navigating a CIMPL Model within VSCode Using CIMPL to create FHIR-based Models An Approach to CIMPL Modeling for FHIR Mapping to FHIR Specifying FHIR \"MustSupport\" Elements Embedding FHIR Examples in the IG IG Publisher Output Support","title":"CIMPL Authoring"},{"location":"cimpl6UserGuide/#authoring-environment","text":"Any text editor can be used to write CIMPL grammar. However, VSCode editor is recommended to take advantage of custom-developed to better navigate CIMPL constructs.","title":"Authoring Environment"},{"location":"cimpl6UserGuide/#setting-up-the-vscode-authoring","text":"Note: VSCode UI screenshots in this section were taken from a MacOS environment. While the overall functionality is the same across supported OS platforms, installation and configuration specifics might differ. Reference the VSCode documentation pertinent to your OS platform. Download the VSCode editor . Open VSCode and search for the extension vscode-lang-cimpl . The figure below shows where to find VSCode extensions.","title":"Setting up the VSCode Authoring"},{"location":"cimpl6UserGuide/#navigating-a-cimpl-model-within-vscode","text":"Elements properties can be previewed in the following ways: hovering over the element. placing the cursor on the element text and right-clicking option Peek Definition placing the cursor on the element text and right-clicking option Go to Definition Hovering over the element: Using Peek Definition : Using Go to Definition :","title":"Navigating a CIMPL Model within VSCode"},{"location":"cimpl6UserGuide/#using-cimpl-to-create-fhir-based-models","text":"With the environment now configured, we now turn our attention to how to create a clinical model. CIMPL is designed to be modular and extensible, allowing for the reuse of other logical models, and inheriting its properties. The figure below illustrates this notion with some existing CIMPL-authored models.","title":"Using CIMPL to create FHIR-based Models"},{"location":"cimpl6UserGuide/#an-approach-to-cimpl-modeling-for-fhir","text":"Keeping in mind that CIMPL is primarily a way to create logical models with the capability to \"model-once, translate-many\", it is advised that the modeler first consider several requirements-gathering and specification activities noted below as a best practice instead of immediately jumping into its representation in FHIR: define the use case behind the creation of a model. create a high-level conceptual model which addresses your defined use case and can be easily understood by both technical and clinical communities. list the data elements, cardinality, and potential value sets involved (if the data type is a coded element). create the logical model in CIMPL which aligns with the high-level conceptual model and data elements noted in the previous steps. create FHIR mappings from the logical model to its equivalent FHIR resource and attributes, noting which elements you've defined in your logical model will be extensions. generate the FHIR Implementation Guide. create FHIR examples for each of the key profiles which define your IG and configure them within the CIMPL authoring environment so that they are validated by the FHIR IG Publisher.","title":"An Approach to CIMPL Modeling for FHIR"},{"location":"cimpl6UserGuide/#mapping-to-fhir","text":"Logical model elements are mapped to FHIR by creating and editing map files. As a best practice, CIMPL map files must have the _map.txt naming convention. Each map file should start with the following 3 lines: Grammar: Map 6.0 Namespace: data element group name Target: fhir target version Where: namespace name is the name of the grouping of elements that you have identified. fhir target version is a choice of FHIR_DSTU_2, FHIR_STU_3, or FHIR_R4","title":"Mapping to FHIR"},{"location":"cimpl6UserGuide/#specifying-fhir-mustsupport-elements","text":"FHIR specifies a \"MustSupport\" boolean flag which allows a profile to indicates that a reference implementation must be able to process the existence of particular element in a FHIR instance and display it if contents are available. MustSupport is contextual and could vary with depending on the reference implementation. CIMPL subsequently created a separate file so that MustSupport of elements are at the IG configuration level through a Content Profile file. Content profile files are text files which use the following convention: <Content Profile Name>-cp.txt Where <Content Profile Name> is by convention the same name as the IG Configuration JSON file. The content profile filename must end in \" -cp.txt \". For example, the two file name examples of a CIMPL configuration and its respective content profile are show below: Configuration filename: myCIMPLConfiguration-ig.json Content Profile filename: myCIMPLConfiguration-cp.txt","title":"Specifying FHIR \"MustSupport\" Elements"},{"location":"cimpl6UserGuide/#embedding-fhir-examples-in-the-ig","text":"Pre-requisite: the author has already created a FHIR JSON or xml. Configuring FHIR examples to appear in the generated IG involves the following steps: Create a folder which will contain your FHIR examples Modify the CIMPL configuration file to specify the folder containing your examples The folder created can be any name, as long as it is specified within the CIMPL configuration file. The folder location is specified using the \"examples:\" parameter in the CIMPL configuration file. This is illustrated in the figure below:","title":"Embedding FHIR Examples in the IG"},{"location":"cimpl6UserGuide/#ig-publisher-output","text":"By default, the FHIR IG Publisher will perform validation checks on the StructureDefinition of specified FHIR profiles, value sets, and examples which reference any base resources or FHIR profiles. An output of these checks are found in the CIMPL output, qa.html . An example QA output is shown in the figure below:","title":"IG Publisher Output"},{"location":"cimpl6UserGuide/#support","text":"Questions on using CIMPL and its toolchain can be addressed on the HL7 Zulip chat channel #cimpl Report any issues on one of the following GitHub repositories: Related to modeling of CIMPL constructs or its FHIR-based classes: https://github.com/standardhealth/shr_spec/issues Related to running the CIMPL shr-cli compiler, CIMPL export configuration files, or generating the FHIR Implementation Guide (IG): https://github.com/standardhealth/shr-cli/issues","title":"Support"},{"location":"cimplInstall/","text":"CIMPL Setup and Installation Table of Contents CIMPL Setup and Installation Background Windows Installation Instructions Windows Proxy Setup Supporting Software Node.js for Windows Yarn for Windows Yarn Proxy Setup Git for Windows Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool Windows Java Installation Windows Jekyll Installation macOS Installation Instructions Terminal Proxy Setup Supporting Software Node.js for macOS Homebrew Yarn for macOS Git for macOS Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool MacOS Java Installation MacOS Jekyll Installation Background CIMPL (and, by extension, the shr-cli tool) is a text-based tool that requires its users to understand and use your operating system's command line . If you are uncomfortable with using the command line, try this short introduction . Windows Installation Instructions Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: Read the instructions thoroughly . Follow instructions in order , without skipping around. Pay attention to variables (like your organization's proxy) that you may need to replace. Windows Proxy Setup Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server, you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: setx HTTP_PROXY http://your.proxy.org setx HTTPS_PROXY https://your.proxy.org setx http_proxy http://your.proxy.org setx https_proxy https://your.proxy.org setx proxy http://your.proxy.org setx JAVA_OPTS \"-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80\" Open a windows command prompt Copy and paste the modified code block (with your organization's proxy server) into the command prompt Close and re-open your command prompt to make sure those settings take effect Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server. Supporting Software Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code . Node.js for Windows The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Yarn for Windows Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. It is recommended that CIMPL developers download and install the stable version of Yarn . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Yarn Proxy Setup Note: If your organization uses a proxy server, replace http://your.proxy.org with your organization's proxy server in the following code block: yarn config set proxy http://your.proxy.org yarn config set strict-ssl false ...then run the modified code block (with your organization's proxy server) in the command prompt Git for Windows Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the shr-cli tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . Download the installation package for Git for Windows and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete). This will install a few applications, but the most useful for CIMPL development will be the 'Git Bash' application. This opens a command-line prompt which emulates the use of git on a Unix-based system (e.g., Linux or macOS). Most CIMPL developers use Unix-based systems, so you may want to use 'Git Bash' for working with CIMPL instead of the standard Windows command line. There are many tutorials online about the use of git. Users that are new to Unix or bash may find this video introduction to Git Bash helpful. You should also set up git so that any changes you make to the codebase are properly identified (replacing the name and email placeholders with your name and email): git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\" Git Proxy Setup Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open a windows command prompt Copy and paste that code block (with your organization's proxy server) into the command prompt Learning Git If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/ Visual Studio Code Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . You can use the default options in the installer file, but some developers find it helpful to check these checkboxes during the installation wizard: * Add \"Open with Code\" action to Windows Explorer file context menu * Add \"Open with Code\" action to Windows Explorer directory context menu * Register Code as an editor for supported file types Proxy Setup Note: If your organization uses a proxy server, you'll need to set this up in the VSCode settings. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: * Open Visual Studio Code * Open the User Settings menu (File -> Preferences -> Settings in the menu bar or Ctrl + , ) * Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: * Save the changes (Using File -> Save in the menu bar or Ctrl + S ) * Exit and re-open Visual Studio Code to make sure the settings take effect CIMPL Extension Setup CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: * Open the extensions menu (Using View -> Extensions in the menu bar, Ctrl + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) * By default, the extensions are filtered by @sort:installs . Replace this with cimpl * Look for the vscode-language-cimpl extension and click the Install button * When the installation has completed, click the Reload button SHR-CLI Tool With the supporting software installed, you can move on to installing the actual shr-cli tool. Open 'Git Bash' (not the windows command prompt) and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the shr-cli tool and places it in the ~/cimpl/shr-cli directory. To set up the shr-cli tool, run: cd ~/cimpl/shr-cli yarn FHIR IG Generation Tool The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly. Windows Java Installation The IG publisher is primarily written in java and requires JRE version 8. To install JRE: * Go to the Java SE Runtime Environment 8 Downloads page * Click the 'Accept License Agreement' radio button * Download the most recent JRE 8 installer for your operating system Windows Jekyll Installation Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. Use the Windows Installation Instructions for Jekyll : * Download RubyInstaller and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) * After clicking 'Finish', a command prompt should open asking about an MSYS2 base installation . Press Enter to continue. * When that installation is complete, open a new command prompt from the Windows start menu and type: gem install jekyll bundler Check to see that Jekyll is installed using: jekyll -v You should see the following: jekyll X.X.X ...where X.X.X is the latest Jekyll version number. If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example. macOS Installation Instructions Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: * Read the instructions thoroughly * Follow instructions in order , without skipping around * Pay attention to variables (like your organization's proxy) that you may need to replace Terminal Proxy Setup Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server and you use the standard Terminal app for macOS , you will need to set up environment variables before proceeding. * Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: echo \"export http_proxy=http://your.proxy.org:80 export https_proxy=http://your.proxy.org:80 export HTTP_PROXY=http://your.proxy.org:80 export HTTPS_PROXY=http://your.proxy.org:80 export JAVA_OPTS='-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 \\ -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 \\ -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80'\" >> ~/.bash_profile;\\ source ~/.bash_profile Open Terminal Copy and paste the modified code block (with your organization's proxy server) into the terminal Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server. Supporting Software Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code . Node.js for macOS The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Homebrew Homebrew is a package manager for macOS which will allow us to install several other applications. To install homebrew, enter the following in a terminal window: /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Note: During the installation, you may be asked if you want to install 'OSX Developer Tools'. If this occurs, answer 'yes'. Yarn for macOS Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. With homebrew installed, yarn can be installed by entering the following in a terminal window: brew install yarn Git for macOS Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the shr-cli tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . With homebrew installed, git can be installed by entering the following in a terminal window: brew install git You should also set up git so that any changes you make to the codebase are properly identified. Replace the name and email placeholders with your name and email : git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\" Git Proxy Setup Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open Terminal Copy and paste that code block (with your organization's proxy server) into the terminal Learning Git If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/ Visual Studio Code Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . Proxy Setup Note: If your organization uses a proxy server, you will need to add some proxy settings to Visual Studio Code. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: * Open Visual Studio Code * Open the User Settings menu (Code -> Preferences -> Settings in the menu bar or Command + , ) * Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: * Save the changes (Using File -> Save in the menu bar or Command + S ) * Exit and re-open Visual Studio Code to make sure the settings take effect CIMPL Extension Setup CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: * Open the extensions menu (Using View -> Extensions in the menu bar, Command + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) * By default, the extensions are filtered by @sort:installs . Replace this with cimpl * Look for the vscode-language-cimpl extension and click the Install button * When the installation has completed, click the Reload button SHR-CLI Tool With the supporting software installed, you can move on to installing the actual shr-cli tool. Open a terminal window and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the shr-cli tool and places it in the ~/cimpl/shr-cli directory. To set up the shr-cli tool, run: cd ~/cimpl/shr-cli yarn Note: If you encounter error unable to get local issuer certificate , run the following command in terminal: yarn config set strict-ssl false ...and then re-run yarn using: yarn FHIR IG Generation Tool The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly. MacOS Java Installation The IG publisher is primarily written in java and requires JRE version 8. To install JRE: * Go to the Java SE Runtime Environment 8 Downloads page * Click the 'Accept License Agreement' radio button * Download the most recent JRE 8 installer for your operating system MacOS Jekyll Installation Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. If you don't know if the xcode developer tools are installed, run the following command: xcode-select --install Install the latest version of Ruby: brew install ruby When ruby is finished installing, run the following: gem install bundler jekyll NOTE: If your system requires sudo to gem install bundler and jekyll, use the following command to preserve environment variables when using sudo : sudo -E gem install bundler jekyl If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example.","title":"CIMPL Setup and Installation"},{"location":"cimplInstall/#cimpl-setup-and-installation","text":"Table of Contents CIMPL Setup and Installation Background Windows Installation Instructions Windows Proxy Setup Supporting Software Node.js for Windows Yarn for Windows Yarn Proxy Setup Git for Windows Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool Windows Java Installation Windows Jekyll Installation macOS Installation Instructions Terminal Proxy Setup Supporting Software Node.js for macOS Homebrew Yarn for macOS Git for macOS Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool MacOS Java Installation MacOS Jekyll Installation","title":"CIMPL Setup and Installation"},{"location":"cimplInstall/#background","text":"CIMPL (and, by extension, the shr-cli tool) is a text-based tool that requires its users to understand and use your operating system's command line . If you are uncomfortable with using the command line, try this short introduction .","title":"Background"},{"location":"cimplInstall/#windows-installation-instructions","text":"Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: Read the instructions thoroughly . Follow instructions in order , without skipping around. Pay attention to variables (like your organization's proxy) that you may need to replace.","title":"Windows Installation Instructions"},{"location":"cimplInstall/#windows-proxy-setup","text":"Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server, you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: setx HTTP_PROXY http://your.proxy.org setx HTTPS_PROXY https://your.proxy.org setx http_proxy http://your.proxy.org setx https_proxy https://your.proxy.org setx proxy http://your.proxy.org setx JAVA_OPTS \"-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80\" Open a windows command prompt Copy and paste the modified code block (with your organization's proxy server) into the command prompt Close and re-open your command prompt to make sure those settings take effect Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server.","title":"Windows Proxy Setup"},{"location":"cimplInstall/#supporting-software","text":"Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code .","title":"Supporting Software"},{"location":"cimplInstall/#nodejs-for-windows","text":"The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Node.js for Windows"},{"location":"cimplInstall/#yarn-for-windows","text":"Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. It is recommended that CIMPL developers download and install the stable version of Yarn . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Yarn for Windows"},{"location":"cimplInstall/#yarn-proxy-setup","text":"Note: If your organization uses a proxy server, replace http://your.proxy.org with your organization's proxy server in the following code block: yarn config set proxy http://your.proxy.org yarn config set strict-ssl false ...then run the modified code block (with your organization's proxy server) in the command prompt","title":"Yarn Proxy Setup"},{"location":"cimplInstall/#git-for-windows","text":"Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the shr-cli tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . Download the installation package for Git for Windows and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete). This will install a few applications, but the most useful for CIMPL development will be the 'Git Bash' application. This opens a command-line prompt which emulates the use of git on a Unix-based system (e.g., Linux or macOS). Most CIMPL developers use Unix-based systems, so you may want to use 'Git Bash' for working with CIMPL instead of the standard Windows command line. There are many tutorials online about the use of git. Users that are new to Unix or bash may find this video introduction to Git Bash helpful. You should also set up git so that any changes you make to the codebase are properly identified (replacing the name and email placeholders with your name and email): git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\"","title":"Git for Windows"},{"location":"cimplInstall/#git-proxy-setup","text":"Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open a windows command prompt Copy and paste that code block (with your organization's proxy server) into the command prompt","title":"Git Proxy Setup"},{"location":"cimplInstall/#learning-git","text":"If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/","title":"Learning Git"},{"location":"cimplInstall/#visual-studio-code","text":"Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . You can use the default options in the installer file, but some developers find it helpful to check these checkboxes during the installation wizard: * Add \"Open with Code\" action to Windows Explorer file context menu * Add \"Open with Code\" action to Windows Explorer directory context menu * Register Code as an editor for supported file types","title":"Visual Studio Code"},{"location":"cimplInstall/#proxy-setup","text":"Note: If your organization uses a proxy server, you'll need to set this up in the VSCode settings. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: * Open Visual Studio Code * Open the User Settings menu (File -> Preferences -> Settings in the menu bar or Ctrl + , ) * Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: * Save the changes (Using File -> Save in the menu bar or Ctrl + S ) * Exit and re-open Visual Studio Code to make sure the settings take effect","title":"Proxy Setup"},{"location":"cimplInstall/#cimpl-extension-setup","text":"CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: * Open the extensions menu (Using View -> Extensions in the menu bar, Ctrl + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) * By default, the extensions are filtered by @sort:installs . Replace this with cimpl * Look for the vscode-language-cimpl extension and click the Install button * When the installation has completed, click the Reload button","title":"CIMPL Extension Setup"},{"location":"cimplInstall/#shr-cli-tool","text":"With the supporting software installed, you can move on to installing the actual shr-cli tool. Open 'Git Bash' (not the windows command prompt) and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the shr-cli tool and places it in the ~/cimpl/shr-cli directory. To set up the shr-cli tool, run: cd ~/cimpl/shr-cli yarn","title":"SHR-CLI Tool"},{"location":"cimplInstall/#fhir-ig-generation-tool","text":"The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly.","title":"FHIR IG Generation Tool"},{"location":"cimplInstall/#windows-java-installation","text":"The IG publisher is primarily written in java and requires JRE version 8. To install JRE: * Go to the Java SE Runtime Environment 8 Downloads page * Click the 'Accept License Agreement' radio button * Download the most recent JRE 8 installer for your operating system","title":"Windows Java Installation"},{"location":"cimplInstall/#windows-jekyll-installation","text":"Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. Use the Windows Installation Instructions for Jekyll : * Download RubyInstaller and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) * After clicking 'Finish', a command prompt should open asking about an MSYS2 base installation . Press Enter to continue. * When that installation is complete, open a new command prompt from the Windows start menu and type: gem install jekyll bundler Check to see that Jekyll is installed using: jekyll -v You should see the following: jekyll X.X.X ...where X.X.X is the latest Jekyll version number. If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example.","title":"Windows Jekyll Installation"},{"location":"cimplInstall/#macos-installation-instructions","text":"Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: * Read the instructions thoroughly * Follow instructions in order , without skipping around * Pay attention to variables (like your organization's proxy) that you may need to replace","title":"macOS Installation Instructions"},{"location":"cimplInstall/#terminal-proxy-setup","text":"Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server and you use the standard Terminal app for macOS , you will need to set up environment variables before proceeding. * Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: echo \"export http_proxy=http://your.proxy.org:80 export https_proxy=http://your.proxy.org:80 export HTTP_PROXY=http://your.proxy.org:80 export HTTPS_PROXY=http://your.proxy.org:80 export JAVA_OPTS='-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 \\ -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 \\ -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80'\" >> ~/.bash_profile;\\ source ~/.bash_profile Open Terminal Copy and paste the modified code block (with your organization's proxy server) into the terminal Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server.","title":"Terminal Proxy Setup"},{"location":"cimplInstall/#supporting-software_1","text":"Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code .","title":"Supporting Software"},{"location":"cimplInstall/#nodejs-for-macos","text":"The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Node.js for macOS"},{"location":"cimplInstall/#homebrew","text":"Homebrew is a package manager for macOS which will allow us to install several other applications. To install homebrew, enter the following in a terminal window: /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Note: During the installation, you may be asked if you want to install 'OSX Developer Tools'. If this occurs, answer 'yes'.","title":"Homebrew"},{"location":"cimplInstall/#yarn-for-macos","text":"Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. With homebrew installed, yarn can be installed by entering the following in a terminal window: brew install yarn","title":"Yarn for macOS"},{"location":"cimplInstall/#git-for-macos","text":"Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the shr-cli tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . With homebrew installed, git can be installed by entering the following in a terminal window: brew install git You should also set up git so that any changes you make to the codebase are properly identified. Replace the name and email placeholders with your name and email : git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\"","title":"Git for macOS"},{"location":"cimplInstall/#git-proxy-setup_1","text":"Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open Terminal Copy and paste that code block (with your organization's proxy server) into the terminal","title":"Git Proxy Setup"},{"location":"cimplInstall/#learning-git_1","text":"If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/","title":"Learning Git"},{"location":"cimplInstall/#visual-studio-code_1","text":"Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage .","title":"Visual Studio Code"},{"location":"cimplInstall/#proxy-setup_1","text":"Note: If your organization uses a proxy server, you will need to add some proxy settings to Visual Studio Code. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: * Open Visual Studio Code * Open the User Settings menu (Code -> Preferences -> Settings in the menu bar or Command + , ) * Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: * Save the changes (Using File -> Save in the menu bar or Command + S ) * Exit and re-open Visual Studio Code to make sure the settings take effect","title":"Proxy Setup"},{"location":"cimplInstall/#cimpl-extension-setup_1","text":"CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: * Open the extensions menu (Using View -> Extensions in the menu bar, Command + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) * By default, the extensions are filtered by @sort:installs . Replace this with cimpl * Look for the vscode-language-cimpl extension and click the Install button * When the installation has completed, click the Reload button","title":"CIMPL Extension Setup"},{"location":"cimplInstall/#shr-cli-tool_1","text":"With the supporting software installed, you can move on to installing the actual shr-cli tool. Open a terminal window and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the shr-cli tool and places it in the ~/cimpl/shr-cli directory. To set up the shr-cli tool, run: cd ~/cimpl/shr-cli yarn Note: If you encounter error unable to get local issuer certificate , run the following command in terminal: yarn config set strict-ssl false ...and then re-run yarn using: yarn","title":"SHR-CLI Tool"},{"location":"cimplInstall/#fhir-ig-generation-tool_1","text":"The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly.","title":"FHIR IG Generation Tool"},{"location":"cimplInstall/#macos-java-installation","text":"The IG publisher is primarily written in java and requires JRE version 8. To install JRE: * Go to the Java SE Runtime Environment 8 Downloads page * Click the 'Accept License Agreement' radio button * Download the most recent JRE 8 installer for your operating system","title":"MacOS Java Installation"},{"location":"cimplInstall/#macos-jekyll-installation","text":"Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. If you don't know if the xcode developer tools are installed, run the following command: xcode-select --install Install the latest version of Ruby: brew install ruby When ruby is finished installing, run the following: gem install bundler jekyll NOTE: If your system requires sudo to gem install bundler and jekyll, use the following command to preserve environment variables when using sudo : sudo -E gem install bundler jekyl If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example.","title":"MacOS Jekyll Installation"},{"location":"cimplReleaseNotes/","text":"CIMPL Release Notes Note: \"This documentation is in the process of being further expanded and is an actively updating document.\" CIMPL Release Notes CIMPL 6.0 CIMPL 5.0 CIMPL 6.0 Release Date : June 2019 CIMPL 6.0 contains a number of significant changes to both syntax and its base classes which support translation to FHIR. CIMPL 5.0 Release Date: 2017","title":"CIMPL Release Notes"},{"location":"cimplReleaseNotes/#cimpl-release-notes","text":"Note: \"This documentation is in the process of being further expanded and is an actively updating document.\" CIMPL Release Notes CIMPL 6.0 CIMPL 5.0","title":"CIMPL Release Notes"},{"location":"cimplReleaseNotes/#cimpl-60","text":"Release Date : June 2019 CIMPL 6.0 contains a number of significant changes to both syntax and its base classes which support translation to FHIR.","title":"CIMPL 6.0"},{"location":"cimplReleaseNotes/#cimpl-50","text":"Release Date: 2017","title":"CIMPL 5.0"}]}