{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CIMPL Project CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and declarative, with tools to produce FHIR Profiles, Implementation Guides, data dictionaries, and other documentation. Table of Contents Installation - Installing and configuring the CIMPL development environment. CIMPL Tutorials CIMPL HelloWorld Tutorial - a very simple tutorial which creates a FHIR Implementation Guide (IG). CIMPL Detailed Tutorial - Walkthrough example of how to author a detailed clinical model using CIMPL 6.0 grammar. CIMPL User Guides CIMPL Authoring - A guide on authoring within the CIMPL development environment. CIMPL Class Library (aka Objective FHIR) - An overview of the base classes provided with CIMPL. CIMPL Reference Manuals CIMPL Language Reference Manual - A detailed reference of CIMPL data primitives and syntax. The current version of CIMPL Grammar is CIMPL 6.0. CIMPL Tooling Reference Manual - A detailed description of the command line interface (CLI), auxiliary files, options, and configuration to produce a FHIR IG.","title":"![](img_cimpl/cimpl-logo.png) CIMPL Project"},{"location":"#cimpl-project","text":"CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and declarative, with tools to produce FHIR Profiles, Implementation Guides, data dictionaries, and other documentation.","title":"CIMPL Project"},{"location":"#table-of-contents","text":"Installation - Installing and configuring the CIMPL development environment. CIMPL Tutorials CIMPL HelloWorld Tutorial - a very simple tutorial which creates a FHIR Implementation Guide (IG). CIMPL Detailed Tutorial - Walkthrough example of how to author a detailed clinical model using CIMPL 6.0 grammar. CIMPL User Guides CIMPL Authoring - A guide on authoring within the CIMPL development environment. CIMPL Class Library (aka Objective FHIR) - An overview of the base classes provided with CIMPL. CIMPL Reference Manuals CIMPL Language Reference Manual - A detailed reference of CIMPL data primitives and syntax. The current version of CIMPL Grammar is CIMPL 6.0. CIMPL Tooling Reference Manual - A detailed description of the command line interface (CLI), auxiliary files, options, and configuration to produce a FHIR IG.","title":"Table of Contents"},{"location":"about/","text":"About CIMPL CIMPL was created by the MITRE Corporation . CIMPL is open source and free for public use. If you have questions, comments, or need help, please contact the CIMPL team on the CIMPL FHIR chat channel , or log an issue on the CIMPL Jira Issue Tracker . We can help your clinical modeling project! MITRE provides services to help non-profits develop open-source detailed clinical models. MITRE's FHIR team can provide informatics, modeling, terminology, HL7 standardization, and clinical resources to facilitate FHIR development. For an example of MITRE's work, see the mCODE Implementation Guide .","title":"About CIMPL"},{"location":"about/#about-cimpl","text":"CIMPL was created by the MITRE Corporation . CIMPL is open source and free for public use. If you have questions, comments, or need help, please contact the CIMPL team on the CIMPL FHIR chat channel , or log an issue on the CIMPL Jira Issue Tracker . We can help your clinical modeling project! MITRE provides services to help non-profits develop open-source detailed clinical models. MITRE's FHIR team can provide informatics, modeling, terminology, HL7 standardization, and clinical resources to facilitate FHIR development. For an example of MITRE's work, see the mCODE Implementation Guide .","title":"About CIMPL"},{"location":"cimpl6Authoring/","text":"CIMPL Authoring The purpose of this guide is to educate people about many different aspects of creating CIMPL models and its supporting utilities. If you're looking for a quick introduction to CIMPL and SHR-CLI environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Language Reference documentation . Table Of Contents CIMPL Authoring Authoring Environment Setting up the VSCode Authoring Navigating a CIMPL Model within VSCode Using CIMPL to Create FHIR-based Models Mapping to FHIR Specifying FHIR \"MustSupport\" Elements Embedding FHIR Examples in the IG FHIR IG Publisher Output Support Appendix A: An Approach to CIMPL Modeling for FHIR Authoring Environment Any text editor can be used to write CIMPL grammar. However, VSCode editor is recommended to take advantage of custom-developed to better navigate CIMPL constructs. Setting up the VSCode Authoring Note: VSCode UI screenshots in this section were taken from a MacOS environment. While the overall functionality is the same across supported OS platforms, installation and configuration specifics might differ. Reference the VSCode documentation pertinent to your OS platform. Download the VSCode editor . Open VSCode and search for the extension vscode-lang-cimpl . The figure below shows where to find VSCode extensions. Navigating a CIMPL Model within VSCode Elements properties can be previewed in the following ways: Hovering over the element : This provides a drop-down list of an element's property names and cardinality, if available. Placing the cursor on the element text and right-clicking option Peek Definition : This will display a drop-down window with a preview of the definition. The name and location of the file will be displayed although the entire file will not be opened. Placing the cursor on the element text and right-clicking option Go to Definition : This will redirect the author to location of the definition, opening the file for display if it's not in the same location where it is referenced. Hovering over the element: Using Peek Definition : Using Go to Definition : Using CIMPL to Create FHIR-based Models CIMPL is designed to be modular and extensible, allowing for the reuse of other logical models, and inheriting its properties. The figure below illustrates this notion. The modeling author has multiple ways in CIMPL to represent FHIR profiles: Define all of the customized resource attributes you need from scratch ( \"Clean slate\" ) - In this approach, the modeling author already knows which FHIR base resources they will be customize, and just define the element constraints or extensions in the FHIR profile. Leverage CIMPL's \"ObjectiveFHIR\" (OBF) base FHIR models - In this approach, the modeling author will define their profile and specify a Parent class from the ObjectiveFHIR elements. Reference the ObjectiveFHIR User Guide for details. Each profiling specification approach has advantages and disadvantages. The CIMPL \"clean slate\" authoring approach might be beneficial when prototyping models containing only small number of profiles with minimal repetition of elements. However, as the number of customizations increase, maintenance becomes more cumbersome and difficult to keep consistent between FHIR profiles. On the other hand, using ObjectiveFHIR (OBF) base FHIR models has the significant benefits which include but are not limited to: saves the modeling author time in mapping common elements to its equivalent FHIR attribute. ensures consistency in the representation of commonly used attributes in different FHIR resources. The user must however invest time to understand the ObjectiveFHIR logical model. Also, ObjectiveFHIR does not comprehensively support all FHIR resources, especially the new ones in R4 which have a low maturity level. Mapping to FHIR Logical model elements are mapped to FHIR by creating and editing map files. As a best practice, CIMPL map files must have the _map.txt naming convention. Each map file should start with the following 3 lines: Grammar: Map mapping_grammar_version Namespace: data element group name Target: fhir target version Where: mapping_grammar_version is the version number for parsing the contents of the map file. The current version is 5.1. data element group name is the name of the grouping of elements that you have identified. fhir target version is a choice of FHIR_DSTU_2, FHIR_STU_3, or FHIR_R4 The snippet below shows an example: Grammar: Map 5.1 Namespace: shr.core Target: FHIR_R4 Specifying FHIR \"MustSupport\" Elements FHIR specifies a \"MustSupport\" boolean flag which allows a profile to indicate that a reference implementation must be able to process the existence of particular element in a FHIR instance and display it if contents are available. MustSupport is contextual and could vary depending on the reference implementation. CIMPL uses a separate file so that MustSupport elements are at the IG configuration level through a Content Profile file. Content Profile files are text files which use the following convention: ig-<Content Profile Name>-cp.txt Where <Content Profile Name> is by convention the same name as the IG Configuration JSON file. For example, the two file name examples of a CIMPL Configuration File and its respective Content Profile are show below: Configuration filename: ig-myCIMPLConfiguration-config.json Content Profile filename: ig-myCIMPLConfiguration-cp.txt Embedding FHIR Examples in the IG Pre-requisite: the author has already created a FHIR example in JSON or XML format. Configuring FHIR examples to appear in the generated IG involves the following steps: Create a folder which will contain your FHIR examples Modify the CIMPL configuration file to specify the folder containing your examples The folder created can be any name, as long as it is specified within the CIMPL configuration file. The folder location is specified using the \"examples:\" parameter in the CIMPL configuration file. This is illustrated in the figure below: FHIR IG Publisher Output The final step in the IG creation process is to run the FHIR IG Publisher . This tool is maintained and owned by HL7 FHIR. At a command prompt, use one of the 2 options: Option 1 ( if the defaults were used in running SHR-CLI ): yarn run ig: publish Option 2 ( if not using defaults and specifying a directory in running SHR-CLI ): java -Xms4g -Xmx8g -jar < directory specified when running shr-cli >/fhir/guide/org.hl7.fhir.publisher.jar -ig < directory specified when running shr-cli >/fhir/guide/ig.json By default, the FHIR IG Publisher will perform validation checks on the StructureDefinition of specified FHIR profiles, value sets, and examples which reference any base resources or FHIR profiles. An output of these checks are found in the CIMPL output, qa.html . An example QA output is shown in the figure below: Support Questions on using CIMPL and its toolchain can be addressed on the HL7 Zulip chat channel #cimpl Report any issues on one of the following GitHub repositories: Related to running the SHR-CLI compiler, configuration files, or generating the FHIR Implementation Guide (IG): https://standardhealthrecord.atlassian.net/projects/CIMPL/issues Related to CIMPL base classes (Objective FHIR): https://standardhealthrecord.atlassian.net/projects/SHRM/issues Appendix A: An Approach to CIMPL Modeling for FHIR Keeping in mind that CIMPL is primarily a way to create logical models with the capability to \"model-once, translate-many\", the modeling author should consider requirements-gathering and high level modeling steps. While one approach is proposed below, the modeling author is not limited to following these steps and might find better approaches to creating detailed clinical models. Define the use cases behind the creation of a model. Create a high-level conceptual model which addresses your defined use case and can be easily understood by both technical and clinical communities. Create a data dictionary listing the data elements, cardinality, and potential value sets involved if the data type is a coded element. This provides a convenient summary for implmenters presented in a way that can be understood by non-technical subject matter experts involved in defining the use cases more than the model's design and implementation. Create the logical model in CIMPL which aligns with the high-level conceptual model and data elements noted in the previous steps. Create FHIR mappings from the logical model to its equivalent FHIR resource and attributes, noting which elements you've defined in your logical model will be extensions. Generate the FHIR Implementation Guide. Create FHIR examples for each of the key profiles which define your IG and configure them within the CIMPL authoring environment so that they are validated by the FHIR IG Publisher.","title":"CIMPL Authoring"},{"location":"cimpl6Authoring/#cimpl-authoring","text":"The purpose of this guide is to educate people about many different aspects of creating CIMPL models and its supporting utilities. If you're looking for a quick introduction to CIMPL and SHR-CLI environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Language Reference documentation . Table Of Contents CIMPL Authoring Authoring Environment Setting up the VSCode Authoring Navigating a CIMPL Model within VSCode Using CIMPL to Create FHIR-based Models Mapping to FHIR Specifying FHIR \"MustSupport\" Elements Embedding FHIR Examples in the IG FHIR IG Publisher Output Support Appendix A: An Approach to CIMPL Modeling for FHIR","title":"CIMPL Authoring"},{"location":"cimpl6Authoring/#authoring-environment","text":"Any text editor can be used to write CIMPL grammar. However, VSCode editor is recommended to take advantage of custom-developed to better navigate CIMPL constructs.","title":"Authoring Environment"},{"location":"cimpl6Authoring/#setting-up-the-vscode-authoring","text":"Note: VSCode UI screenshots in this section were taken from a MacOS environment. While the overall functionality is the same across supported OS platforms, installation and configuration specifics might differ. Reference the VSCode documentation pertinent to your OS platform. Download the VSCode editor . Open VSCode and search for the extension vscode-lang-cimpl . The figure below shows where to find VSCode extensions.","title":"Setting up the VSCode Authoring"},{"location":"cimpl6Authoring/#navigating-a-cimpl-model-within-vscode","text":"Elements properties can be previewed in the following ways: Hovering over the element : This provides a drop-down list of an element's property names and cardinality, if available. Placing the cursor on the element text and right-clicking option Peek Definition : This will display a drop-down window with a preview of the definition. The name and location of the file will be displayed although the entire file will not be opened. Placing the cursor on the element text and right-clicking option Go to Definition : This will redirect the author to location of the definition, opening the file for display if it's not in the same location where it is referenced. Hovering over the element: Using Peek Definition : Using Go to Definition :","title":"Navigating a CIMPL Model within VSCode"},{"location":"cimpl6Authoring/#using-cimpl-to-create-fhir-based-models","text":"CIMPL is designed to be modular and extensible, allowing for the reuse of other logical models, and inheriting its properties. The figure below illustrates this notion. The modeling author has multiple ways in CIMPL to represent FHIR profiles: Define all of the customized resource attributes you need from scratch ( \"Clean slate\" ) - In this approach, the modeling author already knows which FHIR base resources they will be customize, and just define the element constraints or extensions in the FHIR profile. Leverage CIMPL's \"ObjectiveFHIR\" (OBF) base FHIR models - In this approach, the modeling author will define their profile and specify a Parent class from the ObjectiveFHIR elements. Reference the ObjectiveFHIR User Guide for details. Each profiling specification approach has advantages and disadvantages. The CIMPL \"clean slate\" authoring approach might be beneficial when prototyping models containing only small number of profiles with minimal repetition of elements. However, as the number of customizations increase, maintenance becomes more cumbersome and difficult to keep consistent between FHIR profiles. On the other hand, using ObjectiveFHIR (OBF) base FHIR models has the significant benefits which include but are not limited to: saves the modeling author time in mapping common elements to its equivalent FHIR attribute. ensures consistency in the representation of commonly used attributes in different FHIR resources. The user must however invest time to understand the ObjectiveFHIR logical model. Also, ObjectiveFHIR does not comprehensively support all FHIR resources, especially the new ones in R4 which have a low maturity level.","title":"Using CIMPL to Create FHIR-based Models"},{"location":"cimpl6Authoring/#mapping-to-fhir","text":"Logical model elements are mapped to FHIR by creating and editing map files. As a best practice, CIMPL map files must have the _map.txt naming convention. Each map file should start with the following 3 lines: Grammar: Map mapping_grammar_version Namespace: data element group name Target: fhir target version Where: mapping_grammar_version is the version number for parsing the contents of the map file. The current version is 5.1. data element group name is the name of the grouping of elements that you have identified. fhir target version is a choice of FHIR_DSTU_2, FHIR_STU_3, or FHIR_R4 The snippet below shows an example: Grammar: Map 5.1 Namespace: shr.core Target: FHIR_R4","title":"Mapping to FHIR"},{"location":"cimpl6Authoring/#specifying-fhir-mustsupport-elements","text":"FHIR specifies a \"MustSupport\" boolean flag which allows a profile to indicate that a reference implementation must be able to process the existence of particular element in a FHIR instance and display it if contents are available. MustSupport is contextual and could vary depending on the reference implementation. CIMPL uses a separate file so that MustSupport elements are at the IG configuration level through a Content Profile file. Content Profile files are text files which use the following convention: ig-<Content Profile Name>-cp.txt Where <Content Profile Name> is by convention the same name as the IG Configuration JSON file. For example, the two file name examples of a CIMPL Configuration File and its respective Content Profile are show below: Configuration filename: ig-myCIMPLConfiguration-config.json Content Profile filename: ig-myCIMPLConfiguration-cp.txt","title":"Specifying FHIR \"MustSupport\" Elements"},{"location":"cimpl6Authoring/#embedding-fhir-examples-in-the-ig","text":"Pre-requisite: the author has already created a FHIR example in JSON or XML format. Configuring FHIR examples to appear in the generated IG involves the following steps: Create a folder which will contain your FHIR examples Modify the CIMPL configuration file to specify the folder containing your examples The folder created can be any name, as long as it is specified within the CIMPL configuration file. The folder location is specified using the \"examples:\" parameter in the CIMPL configuration file. This is illustrated in the figure below:","title":"Embedding FHIR Examples in the IG"},{"location":"cimpl6Authoring/#fhir-ig-publisher-output","text":"The final step in the IG creation process is to run the FHIR IG Publisher . This tool is maintained and owned by HL7 FHIR. At a command prompt, use one of the 2 options: Option 1 ( if the defaults were used in running SHR-CLI ): yarn run ig: publish Option 2 ( if not using defaults and specifying a directory in running SHR-CLI ): java -Xms4g -Xmx8g -jar < directory specified when running shr-cli >/fhir/guide/org.hl7.fhir.publisher.jar -ig < directory specified when running shr-cli >/fhir/guide/ig.json By default, the FHIR IG Publisher will perform validation checks on the StructureDefinition of specified FHIR profiles, value sets, and examples which reference any base resources or FHIR profiles. An output of these checks are found in the CIMPL output, qa.html . An example QA output is shown in the figure below:","title":"FHIR IG Publisher Output"},{"location":"cimpl6Authoring/#support","text":"Questions on using CIMPL and its toolchain can be addressed on the HL7 Zulip chat channel #cimpl Report any issues on one of the following GitHub repositories: Related to running the SHR-CLI compiler, configuration files, or generating the FHIR Implementation Guide (IG): https://standardhealthrecord.atlassian.net/projects/CIMPL/issues Related to CIMPL base classes (Objective FHIR): https://standardhealthrecord.atlassian.net/projects/SHRM/issues","title":"Support"},{"location":"cimpl6Authoring/#appendix-a-an-approach-to-cimpl-modeling-for-fhir","text":"Keeping in mind that CIMPL is primarily a way to create logical models with the capability to \"model-once, translate-many\", the modeling author should consider requirements-gathering and high level modeling steps. While one approach is proposed below, the modeling author is not limited to following these steps and might find better approaches to creating detailed clinical models. Define the use cases behind the creation of a model. Create a high-level conceptual model which addresses your defined use case and can be easily understood by both technical and clinical communities. Create a data dictionary listing the data elements, cardinality, and potential value sets involved if the data type is a coded element. This provides a convenient summary for implmenters presented in a way that can be understood by non-technical subject matter experts involved in defining the use cases more than the model's design and implementation. Create the logical model in CIMPL which aligns with the high-level conceptual model and data elements noted in the previous steps. Create FHIR mappings from the logical model to its equivalent FHIR resource and attributes, noting which elements you've defined in your logical model will be extensions. Generate the FHIR Implementation Guide. Create FHIR examples for each of the key profiles which define your IG and configure them within the CIMPL authoring environment so that they are validated by the FHIR IG Publisher.","title":"Appendix A: An Approach to CIMPL Modeling for FHIR"},{"location":"cimpl6LanguageReference/","text":"CIMPL 6.0 Language Reference Note: This documentation is a draft. This is a comprehensive guide to CIMPL 6.0 syntax. If you're looking for a quick introduction to CIMPL and SHR-CLI environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial . Table of Contents CIMPL 6.0 Language Reference Overview CIMPL Versioning Namespaces File Types Naming Conventions File Names Namespace Names Class Names Fully Qualified Names Value Set Names Local Code Names Reserved Words Whitespace Comments Primitives Concept Codes Keywords Abstract CodeSystem Concept Description Element Entry Grammar Group Namespace Parent Path Property Uses Value ValueSet CIMPL Paths Dot Notation Entries Terminate Paths Bracket Notation for Value Choices Path Example Constraints Cardinality Constraint Fixed Value Constraint Append Constraint Substitute Constraint Value Set Binding Constraint Includes Constraint Only Constraint Class File Class File Example Class File Header Class Definitions Class Type and Name Declaration Properties and Values Naming Recommendations Value Set File Value Set File Example Value Set File Header Value Set Definition Explicit Codes Implicit Codes Map File Inheritance of Mapping Rules Mapping CIMPL Primitives to FHIR Map File Example Map File Header Setting the Mapping Target Mapping Properties Mapping to References Placement of Extensions Special Mapping Statements fix constrain Slicing Slicing Rules Declaring a Discriminator Slice Strategy Moving the Slice Location Appendix A: Changes from CIMPL 5.x Overview CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a specially-designed language for defining clinical information models. It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles, extensions and implementation guides (IG). Because it is a language , written in text statements, CIMPL encourages distributed, team-based development using conventional source-code control tools such as Github. CIMPL provides tooling that enables you to define a model once, and publish that model to multiple versions of FHIR. CIMPL Versioning CIMPL follows the semantic versioning convention (MAJOR.MINOR.PATCH). MAJOR: A major release has significant new functionality and potentially, grammar changes or other non-backward-compatible changes. MINOR: Contains new or modified features, while maintaining backwards compatability within the major version. PATCH: Contains minor updates and bug fixes, while maintaining backwards compatability within the major version. CIMPL is currently on major version 6. For a full change log, see the Release Notes . Namespaces CIMPL organizes information into namespaces. A namespace is conventionally denoted by the authoring organization or project name, and the broad category of elements the namespace defines, delineated by a period. Namespaces must begin with a lowercase character. For example: Namespace: onco.core Note: The organization or project name is recommended but not required (e.g., Namespace: lab is also allowed). File Types Model information in CIMPL is stored in the following three file types: Class files (.txt): contain definitions of CIMPL classes, which map to FHIR profiles and extensions. Value Set files (.txt): contain definitions of value sets defined in the namespace. Map files (.txt): contain information on how the CIMPL models relate to FHIR resources, profiles, and elements. Each namespace will typically have one or more class files, and if needed, a value set and map file. Naming Conventions File Names File names must begin with lower case and typically include the namespace: Class files: namespace.txt or namespace_something.txt Value Set files: namespace_vs.txt or namespace_something_vs.txt Mapping files: namespace_map.txt or namespace_something_map.txt Any periods in the namespace should be replaced by underscores. For example, a namespace called odh.occupation , the recommended value set file name is odh_occupation_vs.txt . The something is useful when you want to break up the contents of a single namespace into multiple files, for example: obf_action.txt obf_finding.txt Note: obf stands for Objective FHIR , a set of classes provided with CIMPL that can help you create FHIR profiles. For more information, see Objective FHIR Overview Additional files for configuring and producing FHIR implementation guides (IGs), and their naming conventions include: Configuration files: ig-igname-config.json Content profile files: ig-igname-cp.json IG examples: ignameExampleName.json IG HTML pages: anyName.html Namespace Names Best practice is to follow the naming convention pattern of organization.domain or project.domain (followed by subdomains if necessary). Example Purpose obf.lab Laboratory profiles belonging to Objective FHIR odh Occupational Data for Health onco.core Core namespace for oncology-related profiles Class Names Elements, Groups and Entries are conventionally defined in PascalCase . For example: * Element: DetectionTime * Group: Dosage * Entry: AdverseEvent Note: Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter. Fully Qualified Names CIMPL does not support duplicate class names within a single namespace. However, the same name may occur in different namespaces. In the case of naming collisions due to an included namespace in Uses , you have to refer to the class by its fully qualified name (FQN). The FQN is a combination of the element's namespace and its declared name (through concatenation delimited by a period). For example, the element CancerCondition in the namespace onco.core has the following FQN: onco.core.CancerCondition FQNs are only required in case of naming collisions between namespaces. Value Set Names Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: Value Set names must begin with an uppercase letter. Local Code Names Within a custom value set, the individual codes (denoted by # symbol) are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or Other Radiation Source\" #swimming_pool \"Swimming Pool\" Reserved Words CIMPL has a number of reserved words and phrases that are part of CIMPL's grammar (e.g., boolean , or , from , maps to ). For a complete list of reserved words, refer to the ANTLR4 grammar . Whitespace Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 6.0 Namespace: myExampleNamespace is equivalent to this: Grammar: DataElement 6.0 Namespace: myExampleNamespace Comments CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */ Primitives Primitives are data types, distinguished by starting with lower case letter. CIMPL defines the following primitive data types. With the exception of concept (a simplified representation of code, Coding, and CodeableConcept), the primitive types in CIMPL align with FHIR: concept boolean integer string decimal uri base64Binary instant date dateTime time oid id markdown unsignedInt positiveInt xhtml Note: CIMPL does not have an explicit \"Reference\" type. References are determined during the mapping process. Concept Codes CIMPL uses a single primitive type, concept to represent coded terms from controlled vocabularies. A concept combines three elements: code system, code, and optional display text. The grammar for specifying concepts is: SYSTEM#code \"Display text\" For example: SCT#363346000 \"Malignant neoplastic disease (disorder)\" ICD10CM#C004 \"Malignant neoplasm of lower lip, inner aspect\" The SYSTEM is an alias for a canonical URI that represents a controlled vocabulary. Aliases must be declared in the file header using the CodeSystem keyword . You cannot use the canonical URI directly in the concept grammar. Unlike FHIR, CIMPL does not differentiate between code, Coding, and CodeableConcept. See Mapping Concept Codes for information on how CIMPL maps concept to these FHIR types. Note: Future versions of CIMPL will expand concept to include the code system version. Keywords Keywords are used to make various declarations. Keywords always appear at the beginning of a line and are followed by a colon. Keyword Summary: Keyword Purpose File Type(s) Abstract Declare an non-instantiable class Class CodeSystem Define a code system alias Class, Value Set Concept Express the meaning of a class Class Description Provide a human-readable description Class, Value Set Element Declare lowest-level (elemental) model building block Class Entry Declare a stand-alone class Class Grammar Define how a file should be parsed All Group Declare mid-level, non-stand-alone model building block Class Namespace Associate a file with a namespace All Parent Specify inheritance Class Path Alias long URLs Class, Value Set Property Define an attribute in a class Class Uses Import namespace(s) Class Value Define data type(s) of Elements Class ValueSet Define a value set Value Set Abstract The Abstract keyword is used to declare a new Abstract class. Abstract classes are identical to Entries, except they are not instantiable. For details, see Class File . Example: Abstract: ActionStatement CodeSystem The CodeSystem keyword provides an alias or shorthand for the canonical URI of a code system. You must define a code system alias before you can use codes from that system in constraints or value sets. By convention, the alias should be be UPPER CASE, although the tooling does allow for numbers and hyphens after the first upper case letter. Examples: CodeSystem: LNC = http://loinc.org CodeSystem: SCT = http://snomed.info/sct Concept The Concept keyword (not to be confused with the concept primitive ) establishes the meaning of a class in terms of a code (or codes) from controlled vocabularies. Assigning a concept allows the meaning of the class to be understood without inferring it from the class name. If multiple concept codes are used, they should appear as a comma-separated list. This keyword is optional. Examples: Concept: MTH#C3858779 \"Security classification\" Description The Description keyword is used for a narrative that defines the namespace, class, or value set. Example: Description: \"Oncology data elements that broadly apply to most cancer cases.\" Note: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.) Element The Element keyword is used to declare a new class of type Element, the lowest-level building block in CIMPL. For details, see Class File . Example: Element: EvidenceType Entry The Entry keyword is used to declare a new stand-alone class, analogous to a Resource or Profile in FHIR. For details, see Class File . Example: Entry: GenomicsReport Grammar The Grammar keyword defines how the file is to be parsed. The grammar declaration must be the first line in each CIMPL file. File Type Required First Line Current Version # Class Grammar: DataElement #.# 6.0 Value Set Grammar: ValueSet #.# 5.1 Map Grammar: Map #.# 5.1 Note: no space in ValueSet The version details the MAJOR and MINOR version of the grammar the file was written for. The grammar version is typically not the same as the CIMPL release. Generally, the major version of the Grammar matches the major version number of CIMPL, however, at the time of the CIMPL 6.0 release, the ValueSet and Map grammar remain at 5.1. Group The Group keyword is used to declare a building block comprised of one or more properties, similar to a complex data type in FHIR. For details, see Class File . Example: Group: Dosage Namespace The Namespace keyword defines the association of the file with a namespace, and is required in DataElement , ValueSet and Map files. The namespace can be any number of lowercase period-delimited words. Examples: Namespace: odh Namespace: onco.core Note: While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens. Parent Through the Parent keyword, CIMPL provides a mechanism for basing a class on another class, the child inheriting all properties and constraints from the parent. The child class can then extend information inherited from the parent by adding additional properties and applying additional constraints. Additionally, mappings are inherited alongside properties. At most one parent class can be specified. The Parent declaration is optional There are restrictions on which building blocks can inherit from other building blocks. The rules can be summarized as like inherits from like : Building Block Can Inherit From Element Element Group Group Entry Abstract or Entry Abstract Abstract Note: Although the CIMPL 6.0 tooling does not currently enforce these inheritance rules, they will be enforced in future releases. You are strongly encouraged to comply to these rules, and refactor any definitions ported from CIMPL 5.x that do not comply. Example: Parent: LaboratoryObservation Path The Path keyword allows for abbreviations of long URLs. This functionality is completely optional, but it is provided to make authoring easier. By convention, the alias should be be an all UPPER CASE word, although the tooling does allow for numbers and hyphens after the first letter. Example: Path: FHIR = http://hl7.org/fhir/ValueSet Property Classes based on Group, Entry, and Abstract are composed of one or more properties (called fields or attributes in object-oriented programming). A property can be any Element, Group, or Entry, but never a primitive. Each property must have a specified cardinality range, represented as min..max , indicating the number of repeats of the property. The Property keyword cannot be used in Elements. In the following example, StudyArm has four properties: Name , Type , Comment and ResearchStudy . Name is singular and required, Type is optional and repeating, and Comment is singular and optional: Group: StudyArm Description: \"Refers to participant(s) in a clinical trial assigned to receive specific interventions according to a protocol.\" Property: Name 1..1 Property: Type 0..* Property: Comment 0..1 Property: ResearchStudy 1..1 A property that refers to an Entry (such as ResearchStudy, above) is implicitly a reference (pointer) to an instance of that Entry, rather than implying the Entry is \"in-lined\" into the class. Note: CIMPL 5.0 Grammar use of the keyword ref() is now obsolete. Uses The Uses keyword appears in the Class file and provides a comma-separated list of the namespaces imported to the current namespace. This keyword allows you to use the classes and value sets defined in other namespaces. The list order has no effect. Examples: Uses: obf.datatype Uses: obf.datatype, obf, onco.core Value Value represents the data type(s) an Element can accept. This keyword can only be used when defining an Element. Each Element must have exactly one Value , although the value itself can be a choice of several data types. Value choices can be Primitives , Elements , Groups , or Entries . A value may be inherited and constrained in the child class. Examples: Element: DetectionTime Description: \"The date on which the condition was first observed.\" Value: dateTime Element: ExpectedPerformanceTime Description: \"When an action should be performed.\" Value: dateTime or TimePeriod or Timing Element: SubstanceOrCode Description: \"A code or substance reference identifying the ingredient.\" Value: concept or Substance or Medication Although in general, constraints cannot be applied to a property or value at the same time the item is defined, you are allowed to bind a value set to a concept value choice at the same time the value is defined, as follows: Element: IsPrimaryTumor Description: \"Whether the tumor is the original or first tumor in the body, for a particular cancer.\" Value: concept from YesNoUnknownVS (required) For more information on binding, see Value Set Binding Constraint . Note: CIMPL 5.0 Grammar associating a cardinality to a Value is now obsolete. ValueSet Defines the name of a value set defined inside CIMPL (references to external value sets are also allowed). By convention, all value sets should be Pascal case, start with the name of the corresponding concept-type Element that is being bound to the value set, and end with VS . Example: ValueSet: ProposedStatusVS CIMPL Paths CIMPL provides grammar that allows you to refer to any part of a CIMPL class, regardless of nesting. This section outlines CIMPL Path Grammar, which is used in constraints and mapping . Dot Notation Dot notation is used to denote nested properties. The path lists the properties in order, separated by a dot (.) For example, if Patient has a ContactPoint , and ContactPoint has a Priority , then the path to Priority is Patient.ContactPoint.Priority . Entries Terminate Paths An Entry can appear in a path only as its final element. Paths represent nested containment within one class, and Entries are independent objects. Paths cannot \"hop\" from one Entry to another. For example, Procedure has a Patient property, and while Procedure.Patient is a valid path, Procedure.Patient.gender is not. The former path can be used to set the cardinality of Patient within the Procedure class, but the latter would (illegally) constrain an attribute within Patient from inside Procedure . Bracket Notation for Value Choices Values can offer a choice of data types . Bracket notation is used to refer to a particular value choice. Bracket notation must always be used when an Element is part of a CIMPL path. How value choices appear in paths depends on whether the path appears with an Element definition or not. Inside an: Refer to the Value choices as: Element Value[choice] Entry or Group ElementName[choice] Example: Entry: Procedure Property: Priority 0..1 Priority[concept] = SCT#394849002 \"High Priority\" // not Value[concept] Element: Priority Value: integer or concept Value[concept] from PriorityVS (required) // not Priority[concept] Note: The requirement in CIMPL 6.0 to use bracket notation even when the value has only one choice is a change from CIMPL 5. Path Example Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Group: Location Description: \"Location of the landmark\" Property: Code 0..1 Property: Laterality 0..1 Property: Orientation 0..1 Element: Distance Description: \"How far the body location of interest is from the given landmark.\" Value: Quantity Element: Direction Description: \"The direction from the landmark to the body location of interest.\" Value: ClockFaceDirection or AnatomicalDirection Element: ClockFaceDirection Description: \"A direction indicated by o'clock position or degrees relative to 12 o'clock.\" Value: concept or Angle Group: Quantity Description: \"A quantity with units.\" Property: Number 0..1 Property: Comparator 0..1 Property: Units 0..1 This example assumes all paths begin at Landmark. Path to Path Direction Landmark.Direction Laterality Landmark.Location.Laterality ClockFaceDirection Landmark.Direction[ClockFaceDirection] Angle Landmark.Direction[ClockFaceDirection][Angle] Units Landmark.Distance[Quantity].Units A reliable method to create a CIMPL path is to first view it as a dot path, then bracket any part of the path that is a Value, and finally, remove the dot before each left (open) bracket. Here's an example of that process, for the path from Landmark to Units: Find the path: Landmark to Distance , Distance to Quantity , Quantity to Units . Reduce to dot path: Landmark.Distance.Quantity.Units Bracket each Value: Landmark.Distance.[Quantity].Units Remove dot before left (open) bracket: Landmark.Distance[Quantity].Units Constraints Constraints are a way to shape a general model for a particular purpose. Properties, values, and value choices can be constrained. Constraint targets can be be top-level or deeply nested (the latter referred to using CIMPL paths ), inherited or locally-defined. Unlike keyword declarations, constraint statements do not begin with a keyword. Most constraint statements have three parts: The subject of the constraint A reserved word or phrase indicating the type of constraint The constraint value being applied Here are several examples of this pattern: Example Subject Reserved word Value applied IsPrimaryTumor = true IsPrimaryTumor = true Specimen substitute TumorSpecimen Specimen substitute TumorSpecimen BodyLocation from BodyLocationVS BodyLocation from BodyLocationVS LanguageUsed 0..1 LanguageUsed (implicit) 0..1 Here is a summary of constraints supported in CIMPL 6: To do this.. Use this Keyword or Symbol Applies to Narrow cardinality {min}..{max} Property Assign a fixed value = Property or Value[Choice] Append a fixed value to an array += Array Property Narrow a data type substitute Property or Value[Choice] Bind a value set from Property or Value[Choice] Slice an array includes Array Property Narrow choices for a value only Value Cardinality Constraint Cardinality defines the number of repeats that can exist for a property. Cardinality is specified using FHIR syntax, {min}..{max}, where the first integer indicates the minimum repeats (0 implying optional), and the second digit expresses the upper bound on the number of repeats. To express no upper bound, a * is used. When constraining cardinality, you can only narrow the previously declared cardinality. The cardinality constraint only applies to properties. Declaration Constraint Subsequent Constraint Property: LanguageUsed 0..* LanguageUsed 0..1 LanguageUsed 0..0 Property: GovernmentIssuedID 0..* GovernmentIssuedID 1..* GovernmentIssuedID 1..1 Property: Status 1..1 Status 0..1 invalid Note: By constraining a property to 0..0, you effectively remove the property. Use 0..0 with caution, because if an instance does include that property, the instance will fail validation and may be rejected. Fixed Value Constraint The = operator fixes a property to a specific value (e.g., a specific concept, boolean, string, integer, decimal, or URL). The assigned value must be consistent with the defined data type, and is always a primitive. Fixed value constraints apply to properties and value choices. Example Syntax Fix a code to a property ObservationCode = LNC#82810-3 Fix a boolean value to a property IsPrimaryTumor = true Fix a code to a value choice Value[concept] = SCT#233613009 \"Pneumonia\" Fix the units associated with a Quantity value choice Value[Quantity].Units = UCUM#cm Fix a code to a value Value = SCT#233613009 \"Pneumonia\" invalid Notes: Bracket notation must always be used when applying a constraint to a value choice, even if the value has only one choice . This is a change from CIMPL 5. CIMPL allows fixed concept values to be overridden in child classes. Although this seems to violate the notion that constraints should get progressively tighter in subclasses, it is necessary when narrowing the meaning of a class characterized by a concept code. For example, the class Pneumonia , with fixed code, SCT#233604007 , may have a child, Fungal Pneumonia , with fixed code SCT#233613009 , the latter overriding the former. CIMPL will assume, without checking, that the code describing the child class has more constrained semantics than the code it replaces. Fixing numerical types and strings (including URLs) is not yet supported, although this feature is planned. If you only need to fix a value code for one particular mapping (one version of FHIR, for example), do so using the fix keyword in the mapping file. Append Constraint The append ( += ) operator appends a fixed concept to a property array whose value is concept . You can use the += operation repeatedly on the same array, limited only be the cardinality of the array. The append operator can only be applied to repeating properties. For example, you would use += to insert a particular Social Security Number (SSN) or Driver's License number into an array of identifiers (in contrast, includes would be used to require the array contain one or more SSNs, without specifying a particular SSN.) Example Syntax Insert \"Behavior\" into Category array Category += LNC#54511-1 \"Behavior\" Add \"Social History\" to same array Category += OBSCAT#social-history \"Social History\" Note: Appending other primitive types is not yet supported, although this feature is planned. Substitute Constraint The substitute keyword constrains the data type of a property. The new data type that is substituted for the original must be a subclass of the original data type. Example Syntax Constrain the property Specimen to be a TumorSpecimen Specimen substitute TumorSpecimen note: TumorSpecimen must be a subclass of Specimen Constrain a value choice of type Quantity to SimpleQuantity Value[Quantity] substitute SimpleQuantity note: SimpleQuantity is a subclass of Quantity Value Set Binding Constraint Binding is the process of associating a concept with a set of possible values. Binding uses the keyword from . The object of a binding must be an Element whose value is a concept. The value set that is being bound can be a value set defined in CIMPL or a canonical URL external to CIMPL. CIMPL uses the same binding strengths as FHIR , namely: required (strongest) indicates that the code must come from the specified value set. extensible indicates that the code must come from the specified set if the value set contains a relevant code ; otherwise a code outside the value set may be chosen. preferred indicates that the code should ideally come from the specified value set, but codes outside the value set may also be chosen. example (weakest) indicates that the code may come from anywhere; the specified value set is for example purposes only. The following rules apply to binding in CIMPL 6: If no binding strength is specified, the binding is assumed to be required . When further constraining an existing binding, the binding strength can stay the same or be made tighter (e.g., replacing an preferred binding with an extensible or required binding), but never loosened. Constraining may leave the binding strength the same and change the value set instead. However, certain changes permitted in CIMPL may violate FHIR profiling principles . In particular, FHIR will permit a required value set to be replaced by another required value set only if the codes in the new value set are a subset of the codes in the original value set. For extensible bindings, the new value set can contain codes not in the existing value set, but additional codes SHOULD NOT have the same meaning as existing codes in the base value set. Example Syntax Required binding of a Property (property is an Element with concept data type) ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (required) Required binding of a Property (by default) ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical Extensible binding of a Property ReasonCode from ReasonCodeVS (extensible) Preferred binding of a Property BodyLocation from BodyLocationVS (preferred) Required binding of a Value Choice that is a concept Value[concept] from http://hl7.org/fhir/ValueSet/condition-clinical (required) Required binding of a Value Choice that is an Element whose value is a concept Value[ClinicalStatus] from http://hl7.org/fhir/ValueSet/condition-clinical (required) Includes Constraint The includes constraint is used to specify that a repeating property (array) should contain a certain class or classes. FHIR refers to this as slicing . In CIMPL, it is a simple matter of saying an array includes certain types of elements. The includes statement has several requirements: The elements included in the array must conform to the data type of the array. For example, if the array is Identifier 0..* , the items included in the array must inherit from Identifier. Cardinality of each inclusion must be specified, and must fit the cardinality of the array. For example, if the array property has a finite maximum cardinality, you cannot include an element with cardinality 0..*. The keyword includes is repeated for each item the array should contain. The includes constraint does not apply to Values. Here is an example: Property: Measurement 0..* // the array property ... Measurement includes TumorLength 1..1 includes TumorWidth 0..1 includes TumorDepth 0..1 TumorLength, TumorWidth, and TumorDepth all must inherit from Measurement, because Measurement is the array property being sliced. Optionally, the second statement can be written on separate lines (since CIMPL is whitespace insensitive): Measurement includes TumorLength 1..1 includes TumorWidth 0..1 includes TumorDepth 0..1 Here is another example: Property: Identifier 1..* // the array property ... Identifier includes NationalProviderIdentifier 0..1 includes TaxIdentificationNumber 0..1 In this case, either NationalProviderIdentifier or TaxIdentificationNumber must be present, even though both are individually optional, because of the 1..* cardinality on Identifier. Note: When using includes , special mapping syntax is required. See Slicing . Only Constraint Values can have multiple data types. Use the only constraint in an Element to narrow the choice of data types. The only constraint can only be applied to a Value that has multiple choices. The grammar of only constraints varies depending on whether the constraint appears in an Element, or another type of Class. Example: Element: Priority Value: integer or concept Inside Class... Grammar Element Value only integer Entry or Group Priority only integer Note: CIMPL currently does not support narrowing a choice to a more limited choice, for example, narrowing a choice of three types to two types. This feature is planned. Class File Class files contain definitions of the information model. Class File Example Here is an abbreviated example of a class file: Grammar: DataElement 6.0 Namespace: obf.lab Description: \"Profiles of laboratory tests and panels.\" Uses: datatype, obf CodeSystem: LNC = http://loinc.org CodeSystem: UCUM = http://unitsofmeasure.org Abstract: SimpleQuantLabWithRequiredUnits Parent: SimpleQuantitativeLaboratoryObservation Description: \"Laboratory tests that must be reported with units.\" DataValue 1..1 DataValue only QuantityWithRequiredUnits DataAbsentReason 0..0 Group: QuantityWithRequiredUnits Parent: Quantity Description: \"A quantity with that requires a coded unit of measure.\" Units 1..1 Entry: GlobulinMCncPtSerQnCalculatedLabObs Parent: SimpleQuantLabWithRequiredUnits Description: \"Globulin [Mass/\u200bvolume] in Serum by calculation\" Code = LNC#10834-0 \"Globulin [Mass/\u200bvolume] in Serum by calculation\" DataValue[Quantity].Units from EquivalentUnitsVS-g-per-L (required) Class File Header The elements of the class file header are (in order): Grammar (required) Namespace (required) Description (recommended; once per namespace) Uses (optional; as needed) CodeSystem (optional; as needed) Path (optional) For a further description, see Keywords . Note: Uses imports namespaces whose classes can be used as if they were locally defined. However, if a class name in an imported namespace collides with a local class name, you must refer to that element by its fully qualified name . Class Definitions Following the header, the class file contains a number of class definitions. The order of definitions does not matter. Each class definition has contains declarations. The first declaration must be Class type and Name. Subsequent declarations can be in any order. Follow the links for further explanation of each item: Class Type and Name Declaration (required) Parent Declaration (optional) Concept Declaration (optional) Description (optional but highly recommended) Property Declarations (for Entry, Abstract and Group) or Value Declaration (for Element) (optional, but typically present) Constraint statements (optional) Class Type and Name Declaration The first line of all class definitions is a keyword representing the type of building block, followed by a descriptive name you choose. Class names must be unique within a given namespace. CIMPL provides four types of building blocks: Building Block Description Has... Analogous FHIR Type Element The lowest-level building block, representing a property-value pair. Value Property or simple extension Group A building block comprised of other building blocks, specifically, other Groups, Elements, and Entries. Properties Backbone element or complex extension Entry A building block representing a group of related information, complete enough to support stand-alone interpretation. Properties Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Properties none Properties and Values When defining classes, bear in mind that an Element has exactly one Value field and no Property fields, whereas, a Group , Entry , or Abstract can have multiple Property fields but cannot have a Value field. Furthermore, a Property cannot have choices, but a Value can. These differences are illustrated in this example: Element: ExpectedPerformanceTime Description: \"When an action should be performed.\" Value: dateTime or TimePeriod or Timing Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Summary: Keyword Appears in How Many Times? Has Cardinality? Has Choices? Can be a... Value Element Exactly Once No Yes (optionally) primitive, Element, Group, or Entry Property Group , Entry , or Abstract Zero or more Yes No Element, Group, or Entry Naming Recommendations All classes in CIMPL, from Elements to Entries, are reusable outside of their original context. To promote reuse, try to choose names that are self-explanatory and context-independent. For example, a property named Text is too vague, whereas DisplayText and InstructionText are more self-explanatory and may be completely understandable when placed into a specific context. However, an overly-specific name like AddressDisplayText could inhibit reuse because it affixes the context of an address to the concept of a display text. Value Set File The value set files are used to define custom value sets and codes when existing value set sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient, and a new value set must be defined. Value Set File Example A (truncated) example value set file is shown below: Grammar: ValueSet 5.1 Namespace: onco.core CodeSystem: SCT = http://snomed.info/sct CodeSystem: ICD10CM = http://hl7.org/fhir/sid/icd-10-cm ValueSet: CancerDiseaseStatusEvidenceTypeVS Description: \"The type of evidence backing up the clinical determination of cancer progression.\" SCT#363679005 \"Imaging (procedure)\" SCT#252416005 \"Histopathology test (procedure)\" SCT#711015009 \"Assessment of symptom control (procedure)\" SCT#5880005 \"Physical examination procedure (procedure)\" SCT#250724005 \"Tumor marker measurement (procedure)\" SCT#386344002 \"Laboratory data interpretation (procedure)\" ValueSet: SecondaryCancerDisorderVS Description: \"Types of secondary malignant neoplastic disease\" Includes codes descending from SCT#128462008 \"Secondary malignant neoplastic disease (disorder)\" ICD10CM#C7B00 \"Secondary carcinoid tumors, unspecified site\" ICD10CM#C7B01 \"Secondary carcinoid tumors of distant lymph nodes\" ICD10CM#C7B02 \"Secondary carcinoid tumors of liver\" ICD10CM#C7B03 \"Secondary carcinoid tumors of bone\" ICD10CM#C7B04 \"Secondary carcinoid tumors of peritoneum\" Value Set File Header Grammar and Namespace are required keywords in a Value Set file header. One or more CodeSystem will be needed. For a further description, see Keywords . Value Set Definition Following the header, the Value Set file contains a number of value set definitions. The order of definitions does not matter. Each definition follows a set sequence of declarations. Follow the links for further explanation of each item: Value Set Declaration (required) Description (optional but highly recommended) Code Declarations (optional) Includes Codes statements (optional) Explicit Codes Explicit code declarations are used to add specific codes to a value set. Codes can either be locally-defined, or selected from external code systems, such as the CAP#29915 example, in which 29915 is an existing code within the CAP code system. If the code is defined locally, the value set name serves as the code system. For the syntax of concept codes, see Concept Codes . Type Example Locally-defined code #proposed \"The proposal has been proposed, but not accepted or rejected.\" Externally-defined code CAP#29915 \"None/Negative\" Implicit Codes Implicit code declarations are used to add sets of codes to a value set, in particular, from hierarchically-defined code systems. At present, the only hierarchical system supported is SNOMED-CT. There are three variants involving the Includes codes phrase: Phrase Example Result Includes codes from Includes codes from MDR Value set contains all codes from MDR code system Includes codes descending from Includes codes descending from SCT#105590001 Value set contains SCT#1055900001 and all codes below it in the SNOMED-CT hierarchy and not descending from Includes codes descending from SCT#363346000 \"Malignant neoplastic disease\" and not descending from SCT#128462008 \"Secondary malignant neoplastic disease\" Value set contains SCT#363346000 and all codes below it in the SNOMED-CT hierarchy, except code SCT#128462008 and all codes below it Map File Map files control how classes defined in CIMPL are expressed as FHIR profiles. Map files are FHIR-version dependent. Currently, you can map to FHIR DSTU 2, STU 3, R4. If you use the supplied Objective FHIR base classes , you many not need to create a map file. Inheritance of Mapping Rules Maps are defined in a series of mapping rules. A powerful feature of CIMPL is that mapping rules are inherited. If your class inherits from a parent class that already is mapped, you do not need to create a new map for your class. However, if you you want specify mappings for new properties, or override the inherited map, you may do so. The inheritance of mapping rules follows the class hierarchy. If there is no map for a class or attribute, CIMPL tooling automatically looks to the parent class to try and find a mapping. The first mapping rule found will be applied. If no mapping rule is found for a Property defined in CIMPL, a FHIR extension will be created. If no mapping is found for an Entry , that Entry will be mapped to the Basic resource . In general, mapping to Basic is not recommended because it has no inherent semantic meaning for implementers. Mapping CIMPL Primitives to FHIR CIMPL follows somewhat flexible rules on how CIMPL primitives map to FHIR. For example, a unsignedInt in CIMPL can map to an integer type in FHIR (since every unsignedInt is an integer, there is no loss of information). However, mappings that lose information, such as integer in CIMPL to unsignedInt in FHIR, generally will trigger mapping errors. An exception is that CIMPL concept is allowed to map to FHIR code . The following table shows the acceptable mappings between CIMPL and FHIR: CIMPL Primitive Can map to FHIR... concept code, Coding, CodableConcept boolean boolean, code integer integer, Quantity string string decimal decimal uri uri base64Binary base64Binary instant instant date date dateTime dateTime, date, instant time time oid oid id id markdown markdown, string unsignedInt unsignedInt, integer, Quantity positiveInt positiveInt, unsignedInt, integer, Quantity xtml xtml Map File Example Grammar: Map 5.1 Namespace: obf Target: FHIR_STU_3 Dosage maps to Dosage: DoseSequenceNumber maps to sequence InstructionText maps to text InstructionCode maps to additionalInstruction PatientInstruction maps to patientInstruction Timing maps to timing AsNeeded maps to asNeeded[x] AdministrationSite maps to site RouteIntoBody maps to route Method maps to method DoseAndRate.DoseAmount maps to dose[x] DoseAndRate.DoseRate maps to rate[x] MaxDosePerPeriod maps to maxDosePerPeriod MaxDosePerAdministration maps to maxDosePerAdministration MaxDosePerLifetime maps to maxDosePerLifetime MedicationStatement maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-medicationstatement: Identifier maps to identifier MedicationBasedOn maps to basedOn MedicationStatementPartOf maps to partOf CareContext maps to context Status maps to status StatusReason maps to extension Category maps to category MedicationCodeOrReference maps to medication[x] OccurrenceTimeOrPeriod maps to effective[x] StatementDateTime maps to dateAsserted MedicationInformationSource maps to informationSource SubjectOfRecord maps to subject SupportingInformation maps to derivedFrom fix taken to #y constrain reasonNotTaken to 0..0 constrain dosage to 0..1 ReasonCode maps to reasonCode MedicationReasonReference maps to reasonReference Annotation maps to note Dosage maps to dosage Map File Header The header of a map file must include a Grammar , Namespace , and Target keywords. The Target keyword gives the version of FHIR that the CIMPL model is mapped to, either FHIR_DSTU_2 , FHIR_STU_3 , or FHIR_R4 . For a further description of the header keywords, see Keywords . Setting the Mapping Target Each block in a mapping file begins with a statement that establishes a resource, profile, or complex data type that is the target for the mapping. In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in the target output. The mapping target can be a FHIR resource or profile that is part of the target FHIR release version. The initial statement in each mapping block must end with a colon (:). CIMPL Building Block FHIR Target Example Entry Resource SocialHistoryObservation maps to Observation: Entry Profile LaboratoryObservation maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-observationresults: Group Complex Datatype Timing maps to Timing: Mapping Properties After the first line, the remainder of the block consists of statements that map CIMPL properties to FHIR elements. Each statement begins with a CIMPL path , followed by the phrase maps to , and ending with the target FHIR path. With FHIR as the target output, the right-hand side of the map statement can point to any field on a FHIR resource, including: Fields that are at the root of the resource (e.g., maritalStatus ) Fields that are child elements of root elements on the resource (e.g., reaction.substance ) Fields that have a choice of data types (e.g., multipleBirth[x].boolean ) Fields that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity ) Fields that support FHIR Reference() types. CIMPL type FHIR type Example Property element MaritalStatus maps to maritalStatus Property extension Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity Path element Value.ActiveFlag maps to active Path path AdverseReaction.AllergenIrritant maps to reaction.substance Value choice element BodySiteOrCode.concept maps to bodySite Note: The mapping grammar is still at version 5.1, so the bracketed value syntax cannot be used in paths. This is why the above example uses BodySiteOrCode.concept rather than BodySiteOrCode[concept] . Mapping to References FHIR resources and profiles require an explicit Reference() indicator when referring to another resource or profile. In CIMPL, whenever a property is an Entry, that property is mapped as a reference in FHIR. There is no need to create an explicit Reference() . Example: CIMPL Definition Corresponding FHIR Property: Encounter 0..1 encounter: 0..1 Reference(Encounter) Placement of Extensions As mentioned above, if no mapping rule is found for a property, an extension will be automatically created. By default, the extension will be a top-level element in the FHIR profile. Sometimes you may want the extension to appear in a different place, perhaps inside a nested element. To put the extension precisely where you want it, you can map to FHIR paths that include extension . Here's an example involving AdverseEvent: PotentialCause.CauseCategory maps to suspectEntity.extension This rule will create an extension named CauseCategory under AdverseEvent.suspectEntity. Note that rules such as this: DetectionTime maps to extension leave the default behavior unchanged, and are not required. However, they can be used to document the intent to create an extension. Special Mapping Statements fix fix allows FHIR fields to be assigned a value. Note that it is the FHIR resource that is getting the value, not the CIMPL class. This enables you to fix a FHIR value without having to change the class definition, which would affect all potential mappings. This also allows you to fix FHIR values for properties that have no corresponding property in the CIMPL definition. Example: fix status to #completed constrain constrain allows users to constrain the cardinality of FHIR elements. Note that it is the FHIR resource that is getting the constraint, not the CIMPL class. The cardinality is expressed in {min}..{max} form. Keyword Example constrain constrain explanation to 0..1 Slicing When fields are allowed to repeat on a target model (e.g., have cardinality with an upper bound greater than 1), it is common practice to specify which CIMPL elements are mapped to instances of that repeated field on the target model. This process is called slicing . For example, the FHIR Task resource allows for an arbitrary number of input fields to be added. To ensure that each input field is uniquely addressable by a parsing engine, those inputs need to be differentiated by a discriminator . See the FHIR documentation for more detail about slicing and discriminators . Slicing Rules Slicing is used when there is a variation of how an individual element is represented and a need to model it as a sub-list. An example of this is the FHIR Blood Pressure profile , which can be considered an observation with two components which are identical in structure other than their represented code. In CIMPL, slicing rules are specified in the map file. Four reserved phrases are used in conjunction to specify the slice: slice on (required) slice on type (optional) slice strategy (optional) slice at (optional) Examples of their usage in a statement are shown below: Phrase Example slice on / slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) slice on / slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) slice on Laterality maps to qualifier (slice on = concept) Declaring a Discriminator Discriminators are used to indicate how each slice can be distinguished from the others. FHIR requires discriminators to uniquely identify the slice to which an instance of data belongs. To perform any slicing, a discriminator path needs to be declared, using slice on followed by the discriminator path. This is the path to the property whose data identifies the slice in which an instance belongs. FHIR also requires a discriminator type to be indicated. By default, CIMPL will use the value discriminator type, but a different discriminator type can be declared using slice on type followed by one of the following FHIR-defined discriminator types: Discriminator Type Definition value The slices have different values in the nominated element exists The slices are differentiated by the presence or absence of the nominated element pattern The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x] type The slices are differentiated by type of the nominated element to a specified profile profile The slices are differentiated by conformance of the nominated element to a specified profile (not recommended) Slice Strategy The slice_strategy indicates how the CIMPL property should map to slices in the target FHIR property. The default slice strategy adds a single slice, corresponding to the CIMPL type, in the target FHIR array. To map a CIMPL property with includes constraints such that each included CIMPL type becomes a slice in the target FHIR array, specify slice strategy = includes . Reserved Phrase Example slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) In the above example, each included ObservationComponent subtype will create a new slice in the FHIR component array. Each slice is distinguished by the value at the path component.code.coding.code . Moving the Slice Location If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Reserved Phrase Example slice at Members.Observation maps to related.target (slice at = related; slice on = type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occurring at related.target . Instead, the slice at = related ensures that the slicing is occurring at the related element. Appendix A: Changes from CIMPL 5.x For those who have created detailed models using CIMPL 5.0, there have been significant grammar changes to CIMPL 6.0. The table below summarizes these changes: Change Type Change Description CIMPL 5.0 Example CIMPL 6.0 Example Section New keyword only eliminates all value choices except one None FindingResult only concept Only Constraint New keyword Property is required to define properties for an Entry or Element. 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword Replace EntryElement keyword replaced by Entry EntryElement: CourseOfTreatmentPerformed Entry: CourseOfTreatmentPerformed Element Keyword Replace Based on keyword replaced by Parent Based on: Observation Parent: Observation Parent Keyword Syntax change Cardinality is specified after the property or class name 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword , Cardinality Constraint Replace is constraint for fixed values replaced by = FindingTopicCode is LNC#48676-1 FindingTopicCode = LNC#48676-1 Field Constraints Replace substitution of a more specific element derived from a parent element using is type keyword replaced by substitute . Specimen is type BreastSpecimen Specimen substitute BreastSpecimen Substitute Replace code , Coding , and CodeableConcept are replaced by a new primitive concept Value: CodeableConcept from AttributionCategoryVS Value: concept from AttributionCategoryVS Primitives Replace must be , should be , could be , and if covered value set constraints are obsolete and replaced by (required) , (preferred) , (extensible) , and (example) Type from BreastSpecimenTypeVS if covered Type from BreastSpecimenTypeVS (extensible) Value Set Binding Constraint Replace ref() is now obsolete. value is type replaced by substitute and bracket notation denoting value choices SourceSpecimen value is type ref(BreastSpecimen) SourceSpecimen[Specimen] substitute BreastSpecimen Mapping to References","title":"CIMPL 6.0 Language Reference"},{"location":"cimpl6LanguageReference/#cimpl-60-language-reference","text":"Note: This documentation is a draft. This is a comprehensive guide to CIMPL 6.0 syntax. If you're looking for a quick introduction to CIMPL and SHR-CLI environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial . Table of Contents CIMPL 6.0 Language Reference Overview CIMPL Versioning Namespaces File Types Naming Conventions File Names Namespace Names Class Names Fully Qualified Names Value Set Names Local Code Names Reserved Words Whitespace Comments Primitives Concept Codes Keywords Abstract CodeSystem Concept Description Element Entry Grammar Group Namespace Parent Path Property Uses Value ValueSet CIMPL Paths Dot Notation Entries Terminate Paths Bracket Notation for Value Choices Path Example Constraints Cardinality Constraint Fixed Value Constraint Append Constraint Substitute Constraint Value Set Binding Constraint Includes Constraint Only Constraint Class File Class File Example Class File Header Class Definitions Class Type and Name Declaration Properties and Values Naming Recommendations Value Set File Value Set File Example Value Set File Header Value Set Definition Explicit Codes Implicit Codes Map File Inheritance of Mapping Rules Mapping CIMPL Primitives to FHIR Map File Example Map File Header Setting the Mapping Target Mapping Properties Mapping to References Placement of Extensions Special Mapping Statements fix constrain Slicing Slicing Rules Declaring a Discriminator Slice Strategy Moving the Slice Location Appendix A: Changes from CIMPL 5.x","title":"CIMPL 6.0 Language Reference"},{"location":"cimpl6LanguageReference/#overview","text":"CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a specially-designed language for defining clinical information models. It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles, extensions and implementation guides (IG). Because it is a language , written in text statements, CIMPL encourages distributed, team-based development using conventional source-code control tools such as Github. CIMPL provides tooling that enables you to define a model once, and publish that model to multiple versions of FHIR.","title":"Overview"},{"location":"cimpl6LanguageReference/#cimpl-versioning","text":"CIMPL follows the semantic versioning convention (MAJOR.MINOR.PATCH). MAJOR: A major release has significant new functionality and potentially, grammar changes or other non-backward-compatible changes. MINOR: Contains new or modified features, while maintaining backwards compatability within the major version. PATCH: Contains minor updates and bug fixes, while maintaining backwards compatability within the major version. CIMPL is currently on major version 6. For a full change log, see the Release Notes .","title":"CIMPL Versioning"},{"location":"cimpl6LanguageReference/#namespaces","text":"CIMPL organizes information into namespaces. A namespace is conventionally denoted by the authoring organization or project name, and the broad category of elements the namespace defines, delineated by a period. Namespaces must begin with a lowercase character. For example: Namespace: onco.core Note: The organization or project name is recommended but not required (e.g., Namespace: lab is also allowed).","title":"Namespaces"},{"location":"cimpl6LanguageReference/#file-types","text":"Model information in CIMPL is stored in the following three file types: Class files (.txt): contain definitions of CIMPL classes, which map to FHIR profiles and extensions. Value Set files (.txt): contain definitions of value sets defined in the namespace. Map files (.txt): contain information on how the CIMPL models relate to FHIR resources, profiles, and elements. Each namespace will typically have one or more class files, and if needed, a value set and map file.","title":"File Types"},{"location":"cimpl6LanguageReference/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"cimpl6LanguageReference/#file-names","text":"File names must begin with lower case and typically include the namespace: Class files: namespace.txt or namespace_something.txt Value Set files: namespace_vs.txt or namespace_something_vs.txt Mapping files: namespace_map.txt or namespace_something_map.txt Any periods in the namespace should be replaced by underscores. For example, a namespace called odh.occupation , the recommended value set file name is odh_occupation_vs.txt . The something is useful when you want to break up the contents of a single namespace into multiple files, for example: obf_action.txt obf_finding.txt Note: obf stands for Objective FHIR , a set of classes provided with CIMPL that can help you create FHIR profiles. For more information, see Objective FHIR Overview Additional files for configuring and producing FHIR implementation guides (IGs), and their naming conventions include: Configuration files: ig-igname-config.json Content profile files: ig-igname-cp.json IG examples: ignameExampleName.json IG HTML pages: anyName.html","title":"File Names"},{"location":"cimpl6LanguageReference/#namespace-names","text":"Best practice is to follow the naming convention pattern of organization.domain or project.domain (followed by subdomains if necessary). Example Purpose obf.lab Laboratory profiles belonging to Objective FHIR odh Occupational Data for Health onco.core Core namespace for oncology-related profiles","title":"Namespace Names"},{"location":"cimpl6LanguageReference/#class-names","text":"Elements, Groups and Entries are conventionally defined in PascalCase . For example: * Element: DetectionTime * Group: Dosage * Entry: AdverseEvent Note: Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter.","title":"Class Names"},{"location":"cimpl6LanguageReference/#fully-qualified-names","text":"CIMPL does not support duplicate class names within a single namespace. However, the same name may occur in different namespaces. In the case of naming collisions due to an included namespace in Uses , you have to refer to the class by its fully qualified name (FQN). The FQN is a combination of the element's namespace and its declared name (through concatenation delimited by a period). For example, the element CancerCondition in the namespace onco.core has the following FQN: onco.core.CancerCondition FQNs are only required in case of naming collisions between namespaces.","title":"Fully Qualified Names"},{"location":"cimpl6LanguageReference/#value-set-names","text":"Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: Value Set names must begin with an uppercase letter.","title":"Value Set Names"},{"location":"cimpl6LanguageReference/#local-code-names","text":"Within a custom value set, the individual codes (denoted by # symbol) are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or Other Radiation Source\" #swimming_pool \"Swimming Pool\"","title":"Local Code Names"},{"location":"cimpl6LanguageReference/#reserved-words","text":"CIMPL has a number of reserved words and phrases that are part of CIMPL's grammar (e.g., boolean , or , from , maps to ). For a complete list of reserved words, refer to the ANTLR4 grammar .","title":"Reserved Words"},{"location":"cimpl6LanguageReference/#whitespace","text":"Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 6.0 Namespace: myExampleNamespace is equivalent to this: Grammar: DataElement 6.0 Namespace: myExampleNamespace","title":"Whitespace"},{"location":"cimpl6LanguageReference/#comments","text":"CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */","title":"Comments"},{"location":"cimpl6LanguageReference/#primitives","text":"Primitives are data types, distinguished by starting with lower case letter. CIMPL defines the following primitive data types. With the exception of concept (a simplified representation of code, Coding, and CodeableConcept), the primitive types in CIMPL align with FHIR: concept boolean integer string decimal uri base64Binary instant date dateTime time oid id markdown unsignedInt positiveInt xhtml Note: CIMPL does not have an explicit \"Reference\" type. References are determined during the mapping process.","title":"Primitives"},{"location":"cimpl6LanguageReference/#concept-codes","text":"CIMPL uses a single primitive type, concept to represent coded terms from controlled vocabularies. A concept combines three elements: code system, code, and optional display text. The grammar for specifying concepts is: SYSTEM#code \"Display text\" For example: SCT#363346000 \"Malignant neoplastic disease (disorder)\" ICD10CM#C004 \"Malignant neoplasm of lower lip, inner aspect\" The SYSTEM is an alias for a canonical URI that represents a controlled vocabulary. Aliases must be declared in the file header using the CodeSystem keyword . You cannot use the canonical URI directly in the concept grammar. Unlike FHIR, CIMPL does not differentiate between code, Coding, and CodeableConcept. See Mapping Concept Codes for information on how CIMPL maps concept to these FHIR types. Note: Future versions of CIMPL will expand concept to include the code system version.","title":"Concept Codes"},{"location":"cimpl6LanguageReference/#keywords","text":"Keywords are used to make various declarations. Keywords always appear at the beginning of a line and are followed by a colon. Keyword Summary: Keyword Purpose File Type(s) Abstract Declare an non-instantiable class Class CodeSystem Define a code system alias Class, Value Set Concept Express the meaning of a class Class Description Provide a human-readable description Class, Value Set Element Declare lowest-level (elemental) model building block Class Entry Declare a stand-alone class Class Grammar Define how a file should be parsed All Group Declare mid-level, non-stand-alone model building block Class Namespace Associate a file with a namespace All Parent Specify inheritance Class Path Alias long URLs Class, Value Set Property Define an attribute in a class Class Uses Import namespace(s) Class Value Define data type(s) of Elements Class ValueSet Define a value set Value Set","title":"Keywords"},{"location":"cimpl6LanguageReference/#abstract","text":"The Abstract keyword is used to declare a new Abstract class. Abstract classes are identical to Entries, except they are not instantiable. For details, see Class File . Example: Abstract: ActionStatement","title":"Abstract"},{"location":"cimpl6LanguageReference/#codesystem","text":"The CodeSystem keyword provides an alias or shorthand for the canonical URI of a code system. You must define a code system alias before you can use codes from that system in constraints or value sets. By convention, the alias should be be UPPER CASE, although the tooling does allow for numbers and hyphens after the first upper case letter. Examples: CodeSystem: LNC = http://loinc.org CodeSystem: SCT = http://snomed.info/sct","title":"CodeSystem"},{"location":"cimpl6LanguageReference/#concept","text":"The Concept keyword (not to be confused with the concept primitive ) establishes the meaning of a class in terms of a code (or codes) from controlled vocabularies. Assigning a concept allows the meaning of the class to be understood without inferring it from the class name. If multiple concept codes are used, they should appear as a comma-separated list. This keyword is optional. Examples: Concept: MTH#C3858779 \"Security classification\"","title":"Concept"},{"location":"cimpl6LanguageReference/#description","text":"The Description keyword is used for a narrative that defines the namespace, class, or value set. Example: Description: \"Oncology data elements that broadly apply to most cancer cases.\" Note: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.)","title":"Description"},{"location":"cimpl6LanguageReference/#element","text":"The Element keyword is used to declare a new class of type Element, the lowest-level building block in CIMPL. For details, see Class File . Example: Element: EvidenceType","title":"Element"},{"location":"cimpl6LanguageReference/#entry","text":"The Entry keyword is used to declare a new stand-alone class, analogous to a Resource or Profile in FHIR. For details, see Class File . Example: Entry: GenomicsReport","title":"Entry"},{"location":"cimpl6LanguageReference/#grammar","text":"The Grammar keyword defines how the file is to be parsed. The grammar declaration must be the first line in each CIMPL file. File Type Required First Line Current Version # Class Grammar: DataElement #.# 6.0 Value Set Grammar: ValueSet #.# 5.1 Map Grammar: Map #.# 5.1 Note: no space in ValueSet The version details the MAJOR and MINOR version of the grammar the file was written for. The grammar version is typically not the same as the CIMPL release. Generally, the major version of the Grammar matches the major version number of CIMPL, however, at the time of the CIMPL 6.0 release, the ValueSet and Map grammar remain at 5.1.","title":"Grammar"},{"location":"cimpl6LanguageReference/#group","text":"The Group keyword is used to declare a building block comprised of one or more properties, similar to a complex data type in FHIR. For details, see Class File . Example: Group: Dosage","title":"Group"},{"location":"cimpl6LanguageReference/#namespace","text":"The Namespace keyword defines the association of the file with a namespace, and is required in DataElement , ValueSet and Map files. The namespace can be any number of lowercase period-delimited words. Examples: Namespace: odh Namespace: onco.core Note: While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens.","title":"Namespace"},{"location":"cimpl6LanguageReference/#parent","text":"Through the Parent keyword, CIMPL provides a mechanism for basing a class on another class, the child inheriting all properties and constraints from the parent. The child class can then extend information inherited from the parent by adding additional properties and applying additional constraints. Additionally, mappings are inherited alongside properties. At most one parent class can be specified. The Parent declaration is optional There are restrictions on which building blocks can inherit from other building blocks. The rules can be summarized as like inherits from like : Building Block Can Inherit From Element Element Group Group Entry Abstract or Entry Abstract Abstract Note: Although the CIMPL 6.0 tooling does not currently enforce these inheritance rules, they will be enforced in future releases. You are strongly encouraged to comply to these rules, and refactor any definitions ported from CIMPL 5.x that do not comply. Example: Parent: LaboratoryObservation","title":"Parent"},{"location":"cimpl6LanguageReference/#path","text":"The Path keyword allows for abbreviations of long URLs. This functionality is completely optional, but it is provided to make authoring easier. By convention, the alias should be be an all UPPER CASE word, although the tooling does allow for numbers and hyphens after the first letter. Example: Path: FHIR = http://hl7.org/fhir/ValueSet","title":"Path"},{"location":"cimpl6LanguageReference/#property","text":"Classes based on Group, Entry, and Abstract are composed of one or more properties (called fields or attributes in object-oriented programming). A property can be any Element, Group, or Entry, but never a primitive. Each property must have a specified cardinality range, represented as min..max , indicating the number of repeats of the property. The Property keyword cannot be used in Elements. In the following example, StudyArm has four properties: Name , Type , Comment and ResearchStudy . Name is singular and required, Type is optional and repeating, and Comment is singular and optional: Group: StudyArm Description: \"Refers to participant(s) in a clinical trial assigned to receive specific interventions according to a protocol.\" Property: Name 1..1 Property: Type 0..* Property: Comment 0..1 Property: ResearchStudy 1..1 A property that refers to an Entry (such as ResearchStudy, above) is implicitly a reference (pointer) to an instance of that Entry, rather than implying the Entry is \"in-lined\" into the class. Note: CIMPL 5.0 Grammar use of the keyword ref() is now obsolete.","title":"Property"},{"location":"cimpl6LanguageReference/#uses","text":"The Uses keyword appears in the Class file and provides a comma-separated list of the namespaces imported to the current namespace. This keyword allows you to use the classes and value sets defined in other namespaces. The list order has no effect. Examples: Uses: obf.datatype Uses: obf.datatype, obf, onco.core","title":"Uses"},{"location":"cimpl6LanguageReference/#value","text":"Value represents the data type(s) an Element can accept. This keyword can only be used when defining an Element. Each Element must have exactly one Value , although the value itself can be a choice of several data types. Value choices can be Primitives , Elements , Groups , or Entries . A value may be inherited and constrained in the child class. Examples: Element: DetectionTime Description: \"The date on which the condition was first observed.\" Value: dateTime Element: ExpectedPerformanceTime Description: \"When an action should be performed.\" Value: dateTime or TimePeriod or Timing Element: SubstanceOrCode Description: \"A code or substance reference identifying the ingredient.\" Value: concept or Substance or Medication Although in general, constraints cannot be applied to a property or value at the same time the item is defined, you are allowed to bind a value set to a concept value choice at the same time the value is defined, as follows: Element: IsPrimaryTumor Description: \"Whether the tumor is the original or first tumor in the body, for a particular cancer.\" Value: concept from YesNoUnknownVS (required) For more information on binding, see Value Set Binding Constraint . Note: CIMPL 5.0 Grammar associating a cardinality to a Value is now obsolete.","title":"Value"},{"location":"cimpl6LanguageReference/#valueset","text":"Defines the name of a value set defined inside CIMPL (references to external value sets are also allowed). By convention, all value sets should be Pascal case, start with the name of the corresponding concept-type Element that is being bound to the value set, and end with VS . Example: ValueSet: ProposedStatusVS","title":"ValueSet"},{"location":"cimpl6LanguageReference/#cimpl-paths","text":"CIMPL provides grammar that allows you to refer to any part of a CIMPL class, regardless of nesting. This section outlines CIMPL Path Grammar, which is used in constraints and mapping .","title":"CIMPL Paths"},{"location":"cimpl6LanguageReference/#dot-notation","text":"Dot notation is used to denote nested properties. The path lists the properties in order, separated by a dot (.) For example, if Patient has a ContactPoint , and ContactPoint has a Priority , then the path to Priority is Patient.ContactPoint.Priority .","title":"Dot Notation"},{"location":"cimpl6LanguageReference/#entries-terminate-paths","text":"An Entry can appear in a path only as its final element. Paths represent nested containment within one class, and Entries are independent objects. Paths cannot \"hop\" from one Entry to another. For example, Procedure has a Patient property, and while Procedure.Patient is a valid path, Procedure.Patient.gender is not. The former path can be used to set the cardinality of Patient within the Procedure class, but the latter would (illegally) constrain an attribute within Patient from inside Procedure .","title":"Entries Terminate Paths"},{"location":"cimpl6LanguageReference/#bracket-notation-for-value-choices","text":"Values can offer a choice of data types . Bracket notation is used to refer to a particular value choice. Bracket notation must always be used when an Element is part of a CIMPL path. How value choices appear in paths depends on whether the path appears with an Element definition or not. Inside an: Refer to the Value choices as: Element Value[choice] Entry or Group ElementName[choice] Example: Entry: Procedure Property: Priority 0..1 Priority[concept] = SCT#394849002 \"High Priority\" // not Value[concept] Element: Priority Value: integer or concept Value[concept] from PriorityVS (required) // not Priority[concept] Note: The requirement in CIMPL 6.0 to use bracket notation even when the value has only one choice is a change from CIMPL 5.","title":"Bracket Notation for Value Choices"},{"location":"cimpl6LanguageReference/#path-example","text":"Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Group: Location Description: \"Location of the landmark\" Property: Code 0..1 Property: Laterality 0..1 Property: Orientation 0..1 Element: Distance Description: \"How far the body location of interest is from the given landmark.\" Value: Quantity Element: Direction Description: \"The direction from the landmark to the body location of interest.\" Value: ClockFaceDirection or AnatomicalDirection Element: ClockFaceDirection Description: \"A direction indicated by o'clock position or degrees relative to 12 o'clock.\" Value: concept or Angle Group: Quantity Description: \"A quantity with units.\" Property: Number 0..1 Property: Comparator 0..1 Property: Units 0..1 This example assumes all paths begin at Landmark. Path to Path Direction Landmark.Direction Laterality Landmark.Location.Laterality ClockFaceDirection Landmark.Direction[ClockFaceDirection] Angle Landmark.Direction[ClockFaceDirection][Angle] Units Landmark.Distance[Quantity].Units A reliable method to create a CIMPL path is to first view it as a dot path, then bracket any part of the path that is a Value, and finally, remove the dot before each left (open) bracket. Here's an example of that process, for the path from Landmark to Units: Find the path: Landmark to Distance , Distance to Quantity , Quantity to Units . Reduce to dot path: Landmark.Distance.Quantity.Units Bracket each Value: Landmark.Distance.[Quantity].Units Remove dot before left (open) bracket: Landmark.Distance[Quantity].Units","title":"Path Example"},{"location":"cimpl6LanguageReference/#constraints","text":"Constraints are a way to shape a general model for a particular purpose. Properties, values, and value choices can be constrained. Constraint targets can be be top-level or deeply nested (the latter referred to using CIMPL paths ), inherited or locally-defined. Unlike keyword declarations, constraint statements do not begin with a keyword. Most constraint statements have three parts: The subject of the constraint A reserved word or phrase indicating the type of constraint The constraint value being applied Here are several examples of this pattern: Example Subject Reserved word Value applied IsPrimaryTumor = true IsPrimaryTumor = true Specimen substitute TumorSpecimen Specimen substitute TumorSpecimen BodyLocation from BodyLocationVS BodyLocation from BodyLocationVS LanguageUsed 0..1 LanguageUsed (implicit) 0..1 Here is a summary of constraints supported in CIMPL 6: To do this.. Use this Keyword or Symbol Applies to Narrow cardinality {min}..{max} Property Assign a fixed value = Property or Value[Choice] Append a fixed value to an array += Array Property Narrow a data type substitute Property or Value[Choice] Bind a value set from Property or Value[Choice] Slice an array includes Array Property Narrow choices for a value only Value","title":"Constraints"},{"location":"cimpl6LanguageReference/#cardinality-constraint","text":"Cardinality defines the number of repeats that can exist for a property. Cardinality is specified using FHIR syntax, {min}..{max}, where the first integer indicates the minimum repeats (0 implying optional), and the second digit expresses the upper bound on the number of repeats. To express no upper bound, a * is used. When constraining cardinality, you can only narrow the previously declared cardinality. The cardinality constraint only applies to properties. Declaration Constraint Subsequent Constraint Property: LanguageUsed 0..* LanguageUsed 0..1 LanguageUsed 0..0 Property: GovernmentIssuedID 0..* GovernmentIssuedID 1..* GovernmentIssuedID 1..1 Property: Status 1..1 Status 0..1 invalid Note: By constraining a property to 0..0, you effectively remove the property. Use 0..0 with caution, because if an instance does include that property, the instance will fail validation and may be rejected.","title":"Cardinality Constraint"},{"location":"cimpl6LanguageReference/#fixed-value-constraint","text":"The = operator fixes a property to a specific value (e.g., a specific concept, boolean, string, integer, decimal, or URL). The assigned value must be consistent with the defined data type, and is always a primitive. Fixed value constraints apply to properties and value choices. Example Syntax Fix a code to a property ObservationCode = LNC#82810-3 Fix a boolean value to a property IsPrimaryTumor = true Fix a code to a value choice Value[concept] = SCT#233613009 \"Pneumonia\" Fix the units associated with a Quantity value choice Value[Quantity].Units = UCUM#cm Fix a code to a value Value = SCT#233613009 \"Pneumonia\" invalid Notes: Bracket notation must always be used when applying a constraint to a value choice, even if the value has only one choice . This is a change from CIMPL 5. CIMPL allows fixed concept values to be overridden in child classes. Although this seems to violate the notion that constraints should get progressively tighter in subclasses, it is necessary when narrowing the meaning of a class characterized by a concept code. For example, the class Pneumonia , with fixed code, SCT#233604007 , may have a child, Fungal Pneumonia , with fixed code SCT#233613009 , the latter overriding the former. CIMPL will assume, without checking, that the code describing the child class has more constrained semantics than the code it replaces. Fixing numerical types and strings (including URLs) is not yet supported, although this feature is planned. If you only need to fix a value code for one particular mapping (one version of FHIR, for example), do so using the fix keyword in the mapping file.","title":"Fixed Value Constraint"},{"location":"cimpl6LanguageReference/#append-constraint","text":"The append ( += ) operator appends a fixed concept to a property array whose value is concept . You can use the += operation repeatedly on the same array, limited only be the cardinality of the array. The append operator can only be applied to repeating properties. For example, you would use += to insert a particular Social Security Number (SSN) or Driver's License number into an array of identifiers (in contrast, includes would be used to require the array contain one or more SSNs, without specifying a particular SSN.) Example Syntax Insert \"Behavior\" into Category array Category += LNC#54511-1 \"Behavior\" Add \"Social History\" to same array Category += OBSCAT#social-history \"Social History\" Note: Appending other primitive types is not yet supported, although this feature is planned.","title":"Append Constraint"},{"location":"cimpl6LanguageReference/#substitute-constraint","text":"The substitute keyword constrains the data type of a property. The new data type that is substituted for the original must be a subclass of the original data type. Example Syntax Constrain the property Specimen to be a TumorSpecimen Specimen substitute TumorSpecimen note: TumorSpecimen must be a subclass of Specimen Constrain a value choice of type Quantity to SimpleQuantity Value[Quantity] substitute SimpleQuantity note: SimpleQuantity is a subclass of Quantity","title":"Substitute Constraint"},{"location":"cimpl6LanguageReference/#value-set-binding-constraint","text":"Binding is the process of associating a concept with a set of possible values. Binding uses the keyword from . The object of a binding must be an Element whose value is a concept. The value set that is being bound can be a value set defined in CIMPL or a canonical URL external to CIMPL. CIMPL uses the same binding strengths as FHIR , namely: required (strongest) indicates that the code must come from the specified value set. extensible indicates that the code must come from the specified set if the value set contains a relevant code ; otherwise a code outside the value set may be chosen. preferred indicates that the code should ideally come from the specified value set, but codes outside the value set may also be chosen. example (weakest) indicates that the code may come from anywhere; the specified value set is for example purposes only. The following rules apply to binding in CIMPL 6: If no binding strength is specified, the binding is assumed to be required . When further constraining an existing binding, the binding strength can stay the same or be made tighter (e.g., replacing an preferred binding with an extensible or required binding), but never loosened. Constraining may leave the binding strength the same and change the value set instead. However, certain changes permitted in CIMPL may violate FHIR profiling principles . In particular, FHIR will permit a required value set to be replaced by another required value set only if the codes in the new value set are a subset of the codes in the original value set. For extensible bindings, the new value set can contain codes not in the existing value set, but additional codes SHOULD NOT have the same meaning as existing codes in the base value set. Example Syntax Required binding of a Property (property is an Element with concept data type) ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (required) Required binding of a Property (by default) ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical Extensible binding of a Property ReasonCode from ReasonCodeVS (extensible) Preferred binding of a Property BodyLocation from BodyLocationVS (preferred) Required binding of a Value Choice that is a concept Value[concept] from http://hl7.org/fhir/ValueSet/condition-clinical (required) Required binding of a Value Choice that is an Element whose value is a concept Value[ClinicalStatus] from http://hl7.org/fhir/ValueSet/condition-clinical (required)","title":"Value Set Binding Constraint"},{"location":"cimpl6LanguageReference/#includes-constraint","text":"The includes constraint is used to specify that a repeating property (array) should contain a certain class or classes. FHIR refers to this as slicing . In CIMPL, it is a simple matter of saying an array includes certain types of elements. The includes statement has several requirements: The elements included in the array must conform to the data type of the array. For example, if the array is Identifier 0..* , the items included in the array must inherit from Identifier. Cardinality of each inclusion must be specified, and must fit the cardinality of the array. For example, if the array property has a finite maximum cardinality, you cannot include an element with cardinality 0..*. The keyword includes is repeated for each item the array should contain. The includes constraint does not apply to Values. Here is an example: Property: Measurement 0..* // the array property ... Measurement includes TumorLength 1..1 includes TumorWidth 0..1 includes TumorDepth 0..1 TumorLength, TumorWidth, and TumorDepth all must inherit from Measurement, because Measurement is the array property being sliced. Optionally, the second statement can be written on separate lines (since CIMPL is whitespace insensitive): Measurement includes TumorLength 1..1 includes TumorWidth 0..1 includes TumorDepth 0..1 Here is another example: Property: Identifier 1..* // the array property ... Identifier includes NationalProviderIdentifier 0..1 includes TaxIdentificationNumber 0..1 In this case, either NationalProviderIdentifier or TaxIdentificationNumber must be present, even though both are individually optional, because of the 1..* cardinality on Identifier. Note: When using includes , special mapping syntax is required. See Slicing .","title":"Includes Constraint"},{"location":"cimpl6LanguageReference/#only-constraint","text":"Values can have multiple data types. Use the only constraint in an Element to narrow the choice of data types. The only constraint can only be applied to a Value that has multiple choices. The grammar of only constraints varies depending on whether the constraint appears in an Element, or another type of Class. Example: Element: Priority Value: integer or concept Inside Class... Grammar Element Value only integer Entry or Group Priority only integer Note: CIMPL currently does not support narrowing a choice to a more limited choice, for example, narrowing a choice of three types to two types. This feature is planned.","title":"Only Constraint"},{"location":"cimpl6LanguageReference/#class-file","text":"Class files contain definitions of the information model.","title":"Class File"},{"location":"cimpl6LanguageReference/#class-file-example","text":"Here is an abbreviated example of a class file: Grammar: DataElement 6.0 Namespace: obf.lab Description: \"Profiles of laboratory tests and panels.\" Uses: datatype, obf CodeSystem: LNC = http://loinc.org CodeSystem: UCUM = http://unitsofmeasure.org Abstract: SimpleQuantLabWithRequiredUnits Parent: SimpleQuantitativeLaboratoryObservation Description: \"Laboratory tests that must be reported with units.\" DataValue 1..1 DataValue only QuantityWithRequiredUnits DataAbsentReason 0..0 Group: QuantityWithRequiredUnits Parent: Quantity Description: \"A quantity with that requires a coded unit of measure.\" Units 1..1 Entry: GlobulinMCncPtSerQnCalculatedLabObs Parent: SimpleQuantLabWithRequiredUnits Description: \"Globulin [Mass/\u200bvolume] in Serum by calculation\" Code = LNC#10834-0 \"Globulin [Mass/\u200bvolume] in Serum by calculation\" DataValue[Quantity].Units from EquivalentUnitsVS-g-per-L (required)","title":"Class File Example"},{"location":"cimpl6LanguageReference/#class-file-header","text":"The elements of the class file header are (in order): Grammar (required) Namespace (required) Description (recommended; once per namespace) Uses (optional; as needed) CodeSystem (optional; as needed) Path (optional) For a further description, see Keywords . Note: Uses imports namespaces whose classes can be used as if they were locally defined. However, if a class name in an imported namespace collides with a local class name, you must refer to that element by its fully qualified name .","title":"Class File Header"},{"location":"cimpl6LanguageReference/#class-definitions","text":"Following the header, the class file contains a number of class definitions. The order of definitions does not matter. Each class definition has contains declarations. The first declaration must be Class type and Name. Subsequent declarations can be in any order. Follow the links for further explanation of each item: Class Type and Name Declaration (required) Parent Declaration (optional) Concept Declaration (optional) Description (optional but highly recommended) Property Declarations (for Entry, Abstract and Group) or Value Declaration (for Element) (optional, but typically present) Constraint statements (optional)","title":"Class Definitions"},{"location":"cimpl6LanguageReference/#class-type-and-name-declaration","text":"The first line of all class definitions is a keyword representing the type of building block, followed by a descriptive name you choose. Class names must be unique within a given namespace. CIMPL provides four types of building blocks: Building Block Description Has... Analogous FHIR Type Element The lowest-level building block, representing a property-value pair. Value Property or simple extension Group A building block comprised of other building blocks, specifically, other Groups, Elements, and Entries. Properties Backbone element or complex extension Entry A building block representing a group of related information, complete enough to support stand-alone interpretation. Properties Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Properties none","title":"Class Type and Name Declaration"},{"location":"cimpl6LanguageReference/#properties-and-values","text":"When defining classes, bear in mind that an Element has exactly one Value field and no Property fields, whereas, a Group , Entry , or Abstract can have multiple Property fields but cannot have a Value field. Furthermore, a Property cannot have choices, but a Value can. These differences are illustrated in this example: Element: ExpectedPerformanceTime Description: \"When an action should be performed.\" Value: dateTime or TimePeriod or Timing Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Summary: Keyword Appears in How Many Times? Has Cardinality? Has Choices? Can be a... Value Element Exactly Once No Yes (optionally) primitive, Element, Group, or Entry Property Group , Entry , or Abstract Zero or more Yes No Element, Group, or Entry","title":"Properties and Values"},{"location":"cimpl6LanguageReference/#naming-recommendations","text":"All classes in CIMPL, from Elements to Entries, are reusable outside of their original context. To promote reuse, try to choose names that are self-explanatory and context-independent. For example, a property named Text is too vague, whereas DisplayText and InstructionText are more self-explanatory and may be completely understandable when placed into a specific context. However, an overly-specific name like AddressDisplayText could inhibit reuse because it affixes the context of an address to the concept of a display text.","title":"Naming Recommendations"},{"location":"cimpl6LanguageReference/#value-set-file","text":"The value set files are used to define custom value sets and codes when existing value set sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient, and a new value set must be defined.","title":"Value Set File"},{"location":"cimpl6LanguageReference/#value-set-file-example","text":"A (truncated) example value set file is shown below: Grammar: ValueSet 5.1 Namespace: onco.core CodeSystem: SCT = http://snomed.info/sct CodeSystem: ICD10CM = http://hl7.org/fhir/sid/icd-10-cm ValueSet: CancerDiseaseStatusEvidenceTypeVS Description: \"The type of evidence backing up the clinical determination of cancer progression.\" SCT#363679005 \"Imaging (procedure)\" SCT#252416005 \"Histopathology test (procedure)\" SCT#711015009 \"Assessment of symptom control (procedure)\" SCT#5880005 \"Physical examination procedure (procedure)\" SCT#250724005 \"Tumor marker measurement (procedure)\" SCT#386344002 \"Laboratory data interpretation (procedure)\" ValueSet: SecondaryCancerDisorderVS Description: \"Types of secondary malignant neoplastic disease\" Includes codes descending from SCT#128462008 \"Secondary malignant neoplastic disease (disorder)\" ICD10CM#C7B00 \"Secondary carcinoid tumors, unspecified site\" ICD10CM#C7B01 \"Secondary carcinoid tumors of distant lymph nodes\" ICD10CM#C7B02 \"Secondary carcinoid tumors of liver\" ICD10CM#C7B03 \"Secondary carcinoid tumors of bone\" ICD10CM#C7B04 \"Secondary carcinoid tumors of peritoneum\"","title":"Value Set File Example"},{"location":"cimpl6LanguageReference/#value-set-file-header","text":"Grammar and Namespace are required keywords in a Value Set file header. One or more CodeSystem will be needed. For a further description, see Keywords .","title":"Value Set File Header"},{"location":"cimpl6LanguageReference/#value-set-definition","text":"Following the header, the Value Set file contains a number of value set definitions. The order of definitions does not matter. Each definition follows a set sequence of declarations. Follow the links for further explanation of each item: Value Set Declaration (required) Description (optional but highly recommended) Code Declarations (optional) Includes Codes statements (optional)","title":"Value Set Definition"},{"location":"cimpl6LanguageReference/#explicit-codes","text":"Explicit code declarations are used to add specific codes to a value set. Codes can either be locally-defined, or selected from external code systems, such as the CAP#29915 example, in which 29915 is an existing code within the CAP code system. If the code is defined locally, the value set name serves as the code system. For the syntax of concept codes, see Concept Codes . Type Example Locally-defined code #proposed \"The proposal has been proposed, but not accepted or rejected.\" Externally-defined code CAP#29915 \"None/Negative\"","title":"Explicit Codes"},{"location":"cimpl6LanguageReference/#implicit-codes","text":"Implicit code declarations are used to add sets of codes to a value set, in particular, from hierarchically-defined code systems. At present, the only hierarchical system supported is SNOMED-CT. There are three variants involving the Includes codes phrase: Phrase Example Result Includes codes from Includes codes from MDR Value set contains all codes from MDR code system Includes codes descending from Includes codes descending from SCT#105590001 Value set contains SCT#1055900001 and all codes below it in the SNOMED-CT hierarchy and not descending from Includes codes descending from SCT#363346000 \"Malignant neoplastic disease\" and not descending from SCT#128462008 \"Secondary malignant neoplastic disease\" Value set contains SCT#363346000 and all codes below it in the SNOMED-CT hierarchy, except code SCT#128462008 and all codes below it","title":"Implicit Codes"},{"location":"cimpl6LanguageReference/#map-file","text":"Map files control how classes defined in CIMPL are expressed as FHIR profiles. Map files are FHIR-version dependent. Currently, you can map to FHIR DSTU 2, STU 3, R4. If you use the supplied Objective FHIR base classes , you many not need to create a map file.","title":"Map File"},{"location":"cimpl6LanguageReference/#inheritance-of-mapping-rules","text":"Maps are defined in a series of mapping rules. A powerful feature of CIMPL is that mapping rules are inherited. If your class inherits from a parent class that already is mapped, you do not need to create a new map for your class. However, if you you want specify mappings for new properties, or override the inherited map, you may do so. The inheritance of mapping rules follows the class hierarchy. If there is no map for a class or attribute, CIMPL tooling automatically looks to the parent class to try and find a mapping. The first mapping rule found will be applied. If no mapping rule is found for a Property defined in CIMPL, a FHIR extension will be created. If no mapping is found for an Entry , that Entry will be mapped to the Basic resource . In general, mapping to Basic is not recommended because it has no inherent semantic meaning for implementers.","title":"Inheritance of Mapping Rules"},{"location":"cimpl6LanguageReference/#mapping-cimpl-primitives-to-fhir","text":"CIMPL follows somewhat flexible rules on how CIMPL primitives map to FHIR. For example, a unsignedInt in CIMPL can map to an integer type in FHIR (since every unsignedInt is an integer, there is no loss of information). However, mappings that lose information, such as integer in CIMPL to unsignedInt in FHIR, generally will trigger mapping errors. An exception is that CIMPL concept is allowed to map to FHIR code . The following table shows the acceptable mappings between CIMPL and FHIR: CIMPL Primitive Can map to FHIR... concept code, Coding, CodableConcept boolean boolean, code integer integer, Quantity string string decimal decimal uri uri base64Binary base64Binary instant instant date date dateTime dateTime, date, instant time time oid oid id id markdown markdown, string unsignedInt unsignedInt, integer, Quantity positiveInt positiveInt, unsignedInt, integer, Quantity xtml xtml","title":"Mapping CIMPL Primitives to FHIR"},{"location":"cimpl6LanguageReference/#map-file-example","text":"Grammar: Map 5.1 Namespace: obf Target: FHIR_STU_3 Dosage maps to Dosage: DoseSequenceNumber maps to sequence InstructionText maps to text InstructionCode maps to additionalInstruction PatientInstruction maps to patientInstruction Timing maps to timing AsNeeded maps to asNeeded[x] AdministrationSite maps to site RouteIntoBody maps to route Method maps to method DoseAndRate.DoseAmount maps to dose[x] DoseAndRate.DoseRate maps to rate[x] MaxDosePerPeriod maps to maxDosePerPeriod MaxDosePerAdministration maps to maxDosePerAdministration MaxDosePerLifetime maps to maxDosePerLifetime MedicationStatement maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-medicationstatement: Identifier maps to identifier MedicationBasedOn maps to basedOn MedicationStatementPartOf maps to partOf CareContext maps to context Status maps to status StatusReason maps to extension Category maps to category MedicationCodeOrReference maps to medication[x] OccurrenceTimeOrPeriod maps to effective[x] StatementDateTime maps to dateAsserted MedicationInformationSource maps to informationSource SubjectOfRecord maps to subject SupportingInformation maps to derivedFrom fix taken to #y constrain reasonNotTaken to 0..0 constrain dosage to 0..1 ReasonCode maps to reasonCode MedicationReasonReference maps to reasonReference Annotation maps to note Dosage maps to dosage","title":"Map File Example"},{"location":"cimpl6LanguageReference/#map-file-header","text":"The header of a map file must include a Grammar , Namespace , and Target keywords. The Target keyword gives the version of FHIR that the CIMPL model is mapped to, either FHIR_DSTU_2 , FHIR_STU_3 , or FHIR_R4 . For a further description of the header keywords, see Keywords .","title":"Map File Header"},{"location":"cimpl6LanguageReference/#setting-the-mapping-target","text":"Each block in a mapping file begins with a statement that establishes a resource, profile, or complex data type that is the target for the mapping. In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in the target output. The mapping target can be a FHIR resource or profile that is part of the target FHIR release version. The initial statement in each mapping block must end with a colon (:). CIMPL Building Block FHIR Target Example Entry Resource SocialHistoryObservation maps to Observation: Entry Profile LaboratoryObservation maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-observationresults: Group Complex Datatype Timing maps to Timing:","title":"Setting the Mapping Target"},{"location":"cimpl6LanguageReference/#mapping-properties","text":"After the first line, the remainder of the block consists of statements that map CIMPL properties to FHIR elements. Each statement begins with a CIMPL path , followed by the phrase maps to , and ending with the target FHIR path. With FHIR as the target output, the right-hand side of the map statement can point to any field on a FHIR resource, including: Fields that are at the root of the resource (e.g., maritalStatus ) Fields that are child elements of root elements on the resource (e.g., reaction.substance ) Fields that have a choice of data types (e.g., multipleBirth[x].boolean ) Fields that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity ) Fields that support FHIR Reference() types. CIMPL type FHIR type Example Property element MaritalStatus maps to maritalStatus Property extension Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity Path element Value.ActiveFlag maps to active Path path AdverseReaction.AllergenIrritant maps to reaction.substance Value choice element BodySiteOrCode.concept maps to bodySite Note: The mapping grammar is still at version 5.1, so the bracketed value syntax cannot be used in paths. This is why the above example uses BodySiteOrCode.concept rather than BodySiteOrCode[concept] .","title":"Mapping Properties"},{"location":"cimpl6LanguageReference/#mapping-to-references","text":"FHIR resources and profiles require an explicit Reference() indicator when referring to another resource or profile. In CIMPL, whenever a property is an Entry, that property is mapped as a reference in FHIR. There is no need to create an explicit Reference() . Example: CIMPL Definition Corresponding FHIR Property: Encounter 0..1 encounter: 0..1 Reference(Encounter)","title":"Mapping to References"},{"location":"cimpl6LanguageReference/#placement-of-extensions","text":"As mentioned above, if no mapping rule is found for a property, an extension will be automatically created. By default, the extension will be a top-level element in the FHIR profile. Sometimes you may want the extension to appear in a different place, perhaps inside a nested element. To put the extension precisely where you want it, you can map to FHIR paths that include extension . Here's an example involving AdverseEvent: PotentialCause.CauseCategory maps to suspectEntity.extension This rule will create an extension named CauseCategory under AdverseEvent.suspectEntity. Note that rules such as this: DetectionTime maps to extension leave the default behavior unchanged, and are not required. However, they can be used to document the intent to create an extension.","title":"Placement of Extensions"},{"location":"cimpl6LanguageReference/#special-mapping-statements","text":"","title":"Special Mapping Statements"},{"location":"cimpl6LanguageReference/#fix","text":"fix allows FHIR fields to be assigned a value. Note that it is the FHIR resource that is getting the value, not the CIMPL class. This enables you to fix a FHIR value without having to change the class definition, which would affect all potential mappings. This also allows you to fix FHIR values for properties that have no corresponding property in the CIMPL definition. Example: fix status to #completed","title":"fix"},{"location":"cimpl6LanguageReference/#constrain","text":"constrain allows users to constrain the cardinality of FHIR elements. Note that it is the FHIR resource that is getting the constraint, not the CIMPL class. The cardinality is expressed in {min}..{max} form. Keyword Example constrain constrain explanation to 0..1","title":"constrain"},{"location":"cimpl6LanguageReference/#slicing","text":"When fields are allowed to repeat on a target model (e.g., have cardinality with an upper bound greater than 1), it is common practice to specify which CIMPL elements are mapped to instances of that repeated field on the target model. This process is called slicing . For example, the FHIR Task resource allows for an arbitrary number of input fields to be added. To ensure that each input field is uniquely addressable by a parsing engine, those inputs need to be differentiated by a discriminator . See the FHIR documentation for more detail about slicing and discriminators .","title":"Slicing"},{"location":"cimpl6LanguageReference/#slicing-rules","text":"Slicing is used when there is a variation of how an individual element is represented and a need to model it as a sub-list. An example of this is the FHIR Blood Pressure profile , which can be considered an observation with two components which are identical in structure other than their represented code. In CIMPL, slicing rules are specified in the map file. Four reserved phrases are used in conjunction to specify the slice: slice on (required) slice on type (optional) slice strategy (optional) slice at (optional) Examples of their usage in a statement are shown below: Phrase Example slice on / slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) slice on / slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) slice on Laterality maps to qualifier (slice on = concept)","title":"Slicing Rules"},{"location":"cimpl6LanguageReference/#declaring-a-discriminator","text":"Discriminators are used to indicate how each slice can be distinguished from the others. FHIR requires discriminators to uniquely identify the slice to which an instance of data belongs. To perform any slicing, a discriminator path needs to be declared, using slice on followed by the discriminator path. This is the path to the property whose data identifies the slice in which an instance belongs. FHIR also requires a discriminator type to be indicated. By default, CIMPL will use the value discriminator type, but a different discriminator type can be declared using slice on type followed by one of the following FHIR-defined discriminator types: Discriminator Type Definition value The slices have different values in the nominated element exists The slices are differentiated by the presence or absence of the nominated element pattern The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x] type The slices are differentiated by type of the nominated element to a specified profile profile The slices are differentiated by conformance of the nominated element to a specified profile (not recommended)","title":"Declaring a Discriminator"},{"location":"cimpl6LanguageReference/#slice-strategy","text":"The slice_strategy indicates how the CIMPL property should map to slices in the target FHIR property. The default slice strategy adds a single slice, corresponding to the CIMPL type, in the target FHIR array. To map a CIMPL property with includes constraints such that each included CIMPL type becomes a slice in the target FHIR array, specify slice strategy = includes . Reserved Phrase Example slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) In the above example, each included ObservationComponent subtype will create a new slice in the FHIR component array. Each slice is distinguished by the value at the path component.code.coding.code .","title":"Slice Strategy"},{"location":"cimpl6LanguageReference/#moving-the-slice-location","text":"If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Reserved Phrase Example slice at Members.Observation maps to related.target (slice at = related; slice on = type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occurring at related.target . Instead, the slice at = related ensures that the slicing is occurring at the related element.","title":"Moving the Slice Location"},{"location":"cimpl6LanguageReference/#appendix-a-changes-from-cimpl-5x","text":"For those who have created detailed models using CIMPL 5.0, there have been significant grammar changes to CIMPL 6.0. The table below summarizes these changes: Change Type Change Description CIMPL 5.0 Example CIMPL 6.0 Example Section New keyword only eliminates all value choices except one None FindingResult only concept Only Constraint New keyword Property is required to define properties for an Entry or Element. 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword Replace EntryElement keyword replaced by Entry EntryElement: CourseOfTreatmentPerformed Entry: CourseOfTreatmentPerformed Element Keyword Replace Based on keyword replaced by Parent Based on: Observation Parent: Observation Parent Keyword Syntax change Cardinality is specified after the property or class name 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword , Cardinality Constraint Replace is constraint for fixed values replaced by = FindingTopicCode is LNC#48676-1 FindingTopicCode = LNC#48676-1 Field Constraints Replace substitution of a more specific element derived from a parent element using is type keyword replaced by substitute . Specimen is type BreastSpecimen Specimen substitute BreastSpecimen Substitute Replace code , Coding , and CodeableConcept are replaced by a new primitive concept Value: CodeableConcept from AttributionCategoryVS Value: concept from AttributionCategoryVS Primitives Replace must be , should be , could be , and if covered value set constraints are obsolete and replaced by (required) , (preferred) , (extensible) , and (example) Type from BreastSpecimenTypeVS if covered Type from BreastSpecimenTypeVS (extensible) Value Set Binding Constraint Replace ref() is now obsolete. value is type replaced by substitute and bracket notation denoting value choices SourceSpecimen value is type ref(BreastSpecimen) SourceSpecimen[Specimen] substitute BreastSpecimen Mapping to References","title":"Appendix A: Changes from CIMPL 5.x"},{"location":"cimpl6ObjectiveFHIR/","text":"CIMPL Class Library (aka Objective FHIR) Note: This documentation is in draft form. This is an introductory guide to CIMPL's class library: Objective FHIR Version 1.0 . The Guide assumes some knowledge of CIMPL. If you're looking for more information on CIMPL, see the CIMPL 6 Tutorial , the CIMPL Authoring , or the CIMPL 6 Language Reference Manual . Table of Contents CIMPL Class Library (aka Objective FHIR) Overview Philosophy Meta-Model Mapping to FHIR Coverage Subclassing Subclassing, Part 2 Comparison Between Profiling Tools Key Concepts Data Types Naming OBF Actors OBF Event Times Building Blocks Class Hierarchy Resource, Domain Resource, Metadata Information Item EntityOrRole Clinical Statement Future Appendix: Relationship to Other Initiatives Overview Objective FHIR (\"OBF\") is an object-oriented abstraction of FHIR. It provides modelers a way to define a detailed clinical information model by subclassing, extending, and constraining a pre-existing class library. These classes can then be translated automatically into FHIR profiles, FHIR Implementation Guides, data dictionaries, schemas, and other assets, using a choice of the three major FHIR versions: DSTU 2, STU 3, and R4. OBF serves as the base class library for the Clinical Information Modeling and Profiling Language (CIMPL). Use of OBF with CIMPL is optional, but recommended. \"blank slate\" use of CIMPL is also possible and appropriate for some projects. ( TO DO: Move discussion of Blank Slate approach to here ) Philosophy OBF classes resemble FHIR R4, but differ in carefully considered ways that increase consistency and reusability of the resulting models and profiles. Objective FHIR allows data structures of all sorts to be reused. This means that individual data elements and frequently-occurring structures can be defined once and used repeatedly. Objective FHIR addresses one of the most frequent criticisms of FHIR, namely, its lack of consistency . FHIR not only uses different names for equivalent things in different resources, but sometimes, entirely different modeling approaches. This is almost certainly the result of having resources managed by separate HL7 work groups. OBF creates a layer that smooths over many of these differences, not for aesthetic or theoretical reasons, but to make the whole framework easier to learn, enable greater code reuse, and most importantly, to make the resulting clinical models more interoperable . OBF also insulates modelers from differences between FHIR versions. The OBF classes are based on FHIR R4, but the same content is mapped to DSTU 2 and STU 3. This means you can model once and publish the same content across multiple FHIR versions. Meta-Model Objective FHIR has been developed using the Clinical Information Modeling and Profiling Language (CIMPL). CIMPL is a powerful, FHIR-aware, high-level language for creating clinical models. Expressing the model in CIMPL means that Objective FHIR models can automatically be turned into FHIR Profiles, Implementation Guides, data dictionaries, and other useful artifacts, across multiple FHIR versions. Conceptually, there is nothing that prevents the same model from be expressed in other formalisms, some of which are mentioned in the Appendix . However, OBF with CIMPL is a complete, proven, ready-made solution that has created rich FHIR content, such as the mCODE Implementation Guide . Mapping to FHIR One of the significant benefits of the OBF framework, compared to using CIMPL tabula rasa , is that mapping to FHIR has already been done for you. In most cases, any model you create will be mapped to FHIR without additional effort. The only exceptions are when you create a new class that doesn't inherit from a pre-mapped OBF class (rare), override a previous mapping (very rare), or add an extension to a pre-mapped class that requires mapping to a nested extension (even more rare). Coverage Not all FHIR R4 resources are covered by Objective FHIR. We are working to expand the coverage. The model documentation is the best source to determine if OBF covers your needs. If you need additional class coverage for your project, please contact the project team . Subclassing To continue the scenario above, suppose you want a more specific concept of OccurrencePeriod applied to a surgical procedure. In this case, we can subclass: Element: SurgicalProcedureOccurrencePeriod Parent: OccurrencePeriod Description: The period of time for a surgery, from the first incision time to the last incision close time, as defined by https://manual.jointcommission.org/releases/archive/TJC2010B/DataElem0127.html. The structure and content of OccurrenceTime is inherited by the new class (cardinalities, data type, the fact that the start time must be less than the end time, etc.), so repeating that information is unnecessary. Don't repeat yourself (DRY) is a major benefit of inheritance. The DRY principle is stated as \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system\". Subclassing, Part 2 The previous example is trivial, but almost everything you do in OBF will involve creating new classes from existing ones. Here's a more involved example: Entry: GenomicsReport Parent: DiagnosticReport Description: \"Genetic analysis summary report. The report may include one or more tests, with two distinct test types... (truncated)\" Property: SpecimenType 0..1 Property: RegionStudied 0..* Code from https://www.ncbi.nlm.nih.gov/gtr (preferred) Category 1..1 Category = DS#GE \"Genetics\" Observation includes GeneticVariantFound 0..* includes GeneticVariantTested 0..* SpecimenType from GeneticSpecimenTypeVS (extensible) Although the purpose of this guide is not to teach CIMPL, this is worth pulling apart: The first two lines create the class GenomicsReport , based on DiagnosticReport . Entry is a CIMPL building block that roughly corresponds to a FHIR resource, and Parent obviously identifies the parent class. Following the Description , two new properties (with cardinalities) are introduced: SpecimenType and RegionStudied . Using CIMPL, you don't fuss with extensions -- that will happen automatically when the class is mapped to FHIR. After the keyword section, there is a series of constraint statements. Without delving into details, these statements say: The Code identifying the report should preferably come from the Genetic Test Registry . The Category will occur exactly once, and will be fixed to the code GE (Genetics) drawn from a code system aliased to DS (mapped elsewhere to http://terminology.hl7.org/CodeSystem/v2-0074 ). The Observation attribute should include zero or more GeneticVariantFound observations and zero or more GeneticVariantTested observations. The includes statement is the way CIMPL slices arrays. Finally, the SpecimenType, which we've just added as a new class property, is extensibly bound to the value set GeneticSpecimenTypeVS . We now have a general-purpose genomics report. We can use this class in the form of a FHIR profile, or use it as a parent for defining more specific genomics reports, perhaps AncestryDotComGenomicsReport . Comparison Between Profiling Tools In FHIR terms, subclassing is akin to profiling profiles, which can be achieved in a number of tools, notably Forge and Trifolia . Both these tools are extremely well-done, and supported by commercial entities. Forge and Trifolia are essentially graphical user interfaces on top of StructureDefinitions, the low-level \"assembly language\" of FHIR. By contrast, CIMPL is like a high-level programming language. Experience has shown that creating and maintaining a complex project is much easier when you use a language, compared to a visual editor. That's why programming languages are almost always text-based, while visual programming has had comparatively little uptake. Even Unified Modeling Language (UML) - a model-diagramming standard that has been around for decades - is fraught with portability problems , despite having its own exchange format, XMI . As stated by Thomas Beale , \"Architects these days tend to limit their use of UML to package diagrams and a few illustrative class diagrams, while developers tend to go straight to code or use tools that pretty-print extracted textual forms of software such as swagger and apiary.\" (emphasis added). CIMPL takes the latter approach, producing a variety of explanatory and implementable assets generated from CIMPL code, rather than vice versa. When clinical modeling projects grow to a certain size, activities increasingly revolve around repeatedly revisiting, revising, refactoring, and renaming. As a text language, CIMPL allows you to do global search and replace, which will become your new BFF . Using text also enables meaningful source code control. CIMPL files can be hosted in Github, which gives model developers the ability distribute work across multiple branches, compare changes (with meaningful diffs), and automatically merge contributions, allowing projects to scale in ways that visual editors can't support. Key Concepts Data Types The primitive types used in OBF are those defined in CIMPL, which correspond one-to-one with FHIR primitives, except for the way CIMPL handles coded types . Complex data types in OBF are also the same as FHIR R4. They are found in the obf.datatype namespace. Since complex types like Quantity are ubiquitous, you will almost certainly need to import the obf.datatype into your namespace. This is done using the Uses keyword. Naming Attribute names in OBF may differ from FHIR names. When they do so, it is usually to make the meaning of the attribute more explicit. OBF names are meant to be meaningful outside of the context of a single class. For example, the FHIR attribute Encounter.period is not entirely self-explanatory, especially when period is considered alone, outside of the context provided by Encounter . To be more reusable, OBF uses the name OccurrencePeriod . Coupled with a different event, such as a procedure, the renamed attribute's meaning is more clear. Although an attribute name is rarely a sufficient definition, OBF moves the needle in that direction. OBF Actors Name Description SubjectOfRecord Identifies the person whose clinical record contains the information. The SubjectOfRecord is often the same as the Patient or Subject, but in some cases, the subject of information (called the FocalSubject ) may be different than the SubjectOfRecord. InformationSource The originator or source of the information or request: a practitioner, patient, related person, organization, an algorithm, device, etc. Author The actor who created the item and it responsible for the content (regardless of the information source or who recorded it). If only the author is given, it is assumed the author is the information source and the recorder. FocalSubject The person or entity that the information in this resource relates to, if different than the person of record. Participant An actor (usually a Practitioner, Patient, or Organization but potentially a device or other entity) that participates in a healthcare task or activity. The participant is not necessarily the performer of the action. Performer The actor that carried out the observation or action. Note: Currently, OBF doesn't include the information recorder among the key actors. The recorder is the actor who physically enters the information, as opposed to creating or being responsible for the information. Author is occasionally mapped to a FHIR attribute named recorder when it is apparent that the resource designers assumed the author and recorder are the same. OBF Event Times Name Description CreationDateTime The point in time when an ancillary item (such as a report or image) was created. OccurrenceTimeOrPeriod The time or period when the event occurred. StatementDateTime The time when the documentation of an event, action, or situation was created. RelevantTime The time or time period that the statement addresses, not necessarily when the information is gathered. LastUpdated The last time a record was updated. Building Blocks OBF classes fall into one of four categories, which are the building blocks of CIMPL: Building Block Description Inherits from Analogous FHIR Type Element The lowest-level building block, representing a property-value pair. Element Property or simple extension Group A building block comprised of other building blocks, specifically, other Groups, Elements, and Entries. Group Backbone element or complex extension Entry A building block representing a group of related information, complete enough to support stand-alone interpretation. Entry or Abstract Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Abstract none Class Hierarchy In this section, we describe the overall organization and some key classes in Objective FHIR. A pared-down view of the OBF hierarchy is shown below. For full details of each class, please refer to the OBF model documentation . The purpose of the hierarchy is two-fold: 1) To define properties uniformly across multiple classes. For example, almost every FHIR resource should have an author, but many don't, and those that do use a variety of different names . It shouldn't be left up to individual resources, managed by different work groups, to each define author themselves. Inevitably, they will define it differently, or forget entirely, as FHIR R4 shows. Inheriting from a common parent prevents that. 1) To provide a set of ready-made classes that users can extend. An example is QuantitativeLaboratoryObservation , based on Observation . FHIR's approach to uniformity is to define certain patterns, such as the request pattern . However, FHIR stops short of actually implementing these patterns across resources. Implementations can't assume all requests have the same core properties, and can't write generic methods for processing requests. Instead, each type of request must be implemented as a one-off. Resource, Domain Resource, Metadata At the top of the OBF hierarchy are the classes Resource and DomainResource. They involve the Metadata group. These classes align with FHIR. Information Item InformationItem includes definitional items, value set definitions, questionnaire, research study, entities such as locations and organizations, people, financial information, etc. While InformationItem has no attributes itself, it serves as a conceptual grouper for things that exist in the clinical world that are not statements about a patient's health or healthcare. EntityOrRole This branch of the hierarchy, which splits into Entity and Role, represent the potential actors in healthcare scenarios. Entities include organizations, locations, devices, medications, and other \"things\", physical and conceptual. Roles are patient, practitioner, related person, and research subject. FHIR models these resources by conflating the role with the person playing the role. Although this is not the optimal model, OBF continues that practice, just to make OBF more obvious to FHIR users. Earlier versions of OBF modeled a person separately from the role(s) that person could play. Clinical Statement ClinicalStatement provides properties and behaviors common to entries in a medical record. This class also allows for common representation of simple data provenance elements: SubjectOfRecord , CareContext ( Encounter or EpisodeOfCare ), and StatementDateTime . Below ClinicalStatement are two classes, SituationStatement and ActionStatement : SituationStatements covers many types of descriptive information, including opinions, evaluations, laboratory results, genomic data, and social information. ActionStatements covers requested and performed actions, such as prescribing and taking medications, performing procedures, requesting a service. Future Current work is focused on using the classes defined in Objective FHIR directly in implementations, leveraging automatically generated Javascript classes and methods that, at runtime, translate FHIR resources to and from the logical model classes. This would allow implementers to use object oriented programming in much more powerful ways than available in native FHIR, with its flat class structure and complex extension representations. Appendix: Relationship to Other Initiatives Conceptually, Objective FHIR could be expressed in other modeling frameworks, besides CIMPL. Some of the potential frameworks include: Unified Modeling Language (UML) for structure coupled with Object Constraint Language (OCL) for constraint representation. The Federal Health Information Model initiative (FHIM) has conducted some experiments using Model-Driven Health Tools to try and convert UML/OCL models into FHIR profiles. Basic Meta-Model (BMM) for class hierarchy, coupled with Archetype Description Language (ADL) for constraint representation. BMM/ADL has been used in openEHR . Claude Nanjo of University of Utah has conducted some experiments to try to convert ADL/BMM models into FHIR profiles. Clinical Element Models . CEMs are being used to produce some Clinical Information Modeling Initiative (CIMI) FHIR Implementation Guides . Essential parts of CEM-related tooling are internal to Intermountain Healthcare. Objective FHIR is an open source project , and we welcome contributions.","title":"CIMPL Class Library (aka Objective FHIR)"},{"location":"cimpl6ObjectiveFHIR/#cimpl-class-library-aka-objective-fhir","text":"Note: This documentation is in draft form. This is an introductory guide to CIMPL's class library: Objective FHIR Version 1.0 . The Guide assumes some knowledge of CIMPL. If you're looking for more information on CIMPL, see the CIMPL 6 Tutorial , the CIMPL Authoring , or the CIMPL 6 Language Reference Manual . Table of Contents CIMPL Class Library (aka Objective FHIR) Overview Philosophy Meta-Model Mapping to FHIR Coverage Subclassing Subclassing, Part 2 Comparison Between Profiling Tools Key Concepts Data Types Naming OBF Actors OBF Event Times Building Blocks Class Hierarchy Resource, Domain Resource, Metadata Information Item EntityOrRole Clinical Statement Future Appendix: Relationship to Other Initiatives","title":"CIMPL Class Library (aka Objective FHIR)"},{"location":"cimpl6ObjectiveFHIR/#overview","text":"Objective FHIR (\"OBF\") is an object-oriented abstraction of FHIR. It provides modelers a way to define a detailed clinical information model by subclassing, extending, and constraining a pre-existing class library. These classes can then be translated automatically into FHIR profiles, FHIR Implementation Guides, data dictionaries, schemas, and other assets, using a choice of the three major FHIR versions: DSTU 2, STU 3, and R4. OBF serves as the base class library for the Clinical Information Modeling and Profiling Language (CIMPL). Use of OBF with CIMPL is optional, but recommended. \"blank slate\" use of CIMPL is also possible and appropriate for some projects. ( TO DO: Move discussion of Blank Slate approach to here )","title":"Overview"},{"location":"cimpl6ObjectiveFHIR/#philosophy","text":"OBF classes resemble FHIR R4, but differ in carefully considered ways that increase consistency and reusability of the resulting models and profiles. Objective FHIR allows data structures of all sorts to be reused. This means that individual data elements and frequently-occurring structures can be defined once and used repeatedly. Objective FHIR addresses one of the most frequent criticisms of FHIR, namely, its lack of consistency . FHIR not only uses different names for equivalent things in different resources, but sometimes, entirely different modeling approaches. This is almost certainly the result of having resources managed by separate HL7 work groups. OBF creates a layer that smooths over many of these differences, not for aesthetic or theoretical reasons, but to make the whole framework easier to learn, enable greater code reuse, and most importantly, to make the resulting clinical models more interoperable . OBF also insulates modelers from differences between FHIR versions. The OBF classes are based on FHIR R4, but the same content is mapped to DSTU 2 and STU 3. This means you can model once and publish the same content across multiple FHIR versions.","title":"Philosophy"},{"location":"cimpl6ObjectiveFHIR/#meta-model","text":"Objective FHIR has been developed using the Clinical Information Modeling and Profiling Language (CIMPL). CIMPL is a powerful, FHIR-aware, high-level language for creating clinical models. Expressing the model in CIMPL means that Objective FHIR models can automatically be turned into FHIR Profiles, Implementation Guides, data dictionaries, and other useful artifacts, across multiple FHIR versions. Conceptually, there is nothing that prevents the same model from be expressed in other formalisms, some of which are mentioned in the Appendix . However, OBF with CIMPL is a complete, proven, ready-made solution that has created rich FHIR content, such as the mCODE Implementation Guide .","title":"Meta-Model"},{"location":"cimpl6ObjectiveFHIR/#mapping-to-fhir","text":"One of the significant benefits of the OBF framework, compared to using CIMPL tabula rasa , is that mapping to FHIR has already been done for you. In most cases, any model you create will be mapped to FHIR without additional effort. The only exceptions are when you create a new class that doesn't inherit from a pre-mapped OBF class (rare), override a previous mapping (very rare), or add an extension to a pre-mapped class that requires mapping to a nested extension (even more rare).","title":"Mapping to FHIR"},{"location":"cimpl6ObjectiveFHIR/#coverage","text":"Not all FHIR R4 resources are covered by Objective FHIR. We are working to expand the coverage. The model documentation is the best source to determine if OBF covers your needs. If you need additional class coverage for your project, please contact the project team .","title":"Coverage"},{"location":"cimpl6ObjectiveFHIR/#subclassing","text":"To continue the scenario above, suppose you want a more specific concept of OccurrencePeriod applied to a surgical procedure. In this case, we can subclass: Element: SurgicalProcedureOccurrencePeriod Parent: OccurrencePeriod Description: The period of time for a surgery, from the first incision time to the last incision close time, as defined by https://manual.jointcommission.org/releases/archive/TJC2010B/DataElem0127.html. The structure and content of OccurrenceTime is inherited by the new class (cardinalities, data type, the fact that the start time must be less than the end time, etc.), so repeating that information is unnecessary. Don't repeat yourself (DRY) is a major benefit of inheritance. The DRY principle is stated as \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system\".","title":"Subclassing"},{"location":"cimpl6ObjectiveFHIR/#subclassing-part-2","text":"The previous example is trivial, but almost everything you do in OBF will involve creating new classes from existing ones. Here's a more involved example: Entry: GenomicsReport Parent: DiagnosticReport Description: \"Genetic analysis summary report. The report may include one or more tests, with two distinct test types... (truncated)\" Property: SpecimenType 0..1 Property: RegionStudied 0..* Code from https://www.ncbi.nlm.nih.gov/gtr (preferred) Category 1..1 Category = DS#GE \"Genetics\" Observation includes GeneticVariantFound 0..* includes GeneticVariantTested 0..* SpecimenType from GeneticSpecimenTypeVS (extensible) Although the purpose of this guide is not to teach CIMPL, this is worth pulling apart: The first two lines create the class GenomicsReport , based on DiagnosticReport . Entry is a CIMPL building block that roughly corresponds to a FHIR resource, and Parent obviously identifies the parent class. Following the Description , two new properties (with cardinalities) are introduced: SpecimenType and RegionStudied . Using CIMPL, you don't fuss with extensions -- that will happen automatically when the class is mapped to FHIR. After the keyword section, there is a series of constraint statements. Without delving into details, these statements say: The Code identifying the report should preferably come from the Genetic Test Registry . The Category will occur exactly once, and will be fixed to the code GE (Genetics) drawn from a code system aliased to DS (mapped elsewhere to http://terminology.hl7.org/CodeSystem/v2-0074 ). The Observation attribute should include zero or more GeneticVariantFound observations and zero or more GeneticVariantTested observations. The includes statement is the way CIMPL slices arrays. Finally, the SpecimenType, which we've just added as a new class property, is extensibly bound to the value set GeneticSpecimenTypeVS . We now have a general-purpose genomics report. We can use this class in the form of a FHIR profile, or use it as a parent for defining more specific genomics reports, perhaps AncestryDotComGenomicsReport .","title":"Subclassing, Part 2"},{"location":"cimpl6ObjectiveFHIR/#comparison-between-profiling-tools","text":"In FHIR terms, subclassing is akin to profiling profiles, which can be achieved in a number of tools, notably Forge and Trifolia . Both these tools are extremely well-done, and supported by commercial entities. Forge and Trifolia are essentially graphical user interfaces on top of StructureDefinitions, the low-level \"assembly language\" of FHIR. By contrast, CIMPL is like a high-level programming language. Experience has shown that creating and maintaining a complex project is much easier when you use a language, compared to a visual editor. That's why programming languages are almost always text-based, while visual programming has had comparatively little uptake. Even Unified Modeling Language (UML) - a model-diagramming standard that has been around for decades - is fraught with portability problems , despite having its own exchange format, XMI . As stated by Thomas Beale , \"Architects these days tend to limit their use of UML to package diagrams and a few illustrative class diagrams, while developers tend to go straight to code or use tools that pretty-print extracted textual forms of software such as swagger and apiary.\" (emphasis added). CIMPL takes the latter approach, producing a variety of explanatory and implementable assets generated from CIMPL code, rather than vice versa. When clinical modeling projects grow to a certain size, activities increasingly revolve around repeatedly revisiting, revising, refactoring, and renaming. As a text language, CIMPL allows you to do global search and replace, which will become your new BFF . Using text also enables meaningful source code control. CIMPL files can be hosted in Github, which gives model developers the ability distribute work across multiple branches, compare changes (with meaningful diffs), and automatically merge contributions, allowing projects to scale in ways that visual editors can't support.","title":"Comparison Between Profiling Tools"},{"location":"cimpl6ObjectiveFHIR/#key-concepts","text":"","title":"Key Concepts"},{"location":"cimpl6ObjectiveFHIR/#data-types","text":"The primitive types used in OBF are those defined in CIMPL, which correspond one-to-one with FHIR primitives, except for the way CIMPL handles coded types . Complex data types in OBF are also the same as FHIR R4. They are found in the obf.datatype namespace. Since complex types like Quantity are ubiquitous, you will almost certainly need to import the obf.datatype into your namespace. This is done using the Uses keyword.","title":"Data Types"},{"location":"cimpl6ObjectiveFHIR/#naming","text":"Attribute names in OBF may differ from FHIR names. When they do so, it is usually to make the meaning of the attribute more explicit. OBF names are meant to be meaningful outside of the context of a single class. For example, the FHIR attribute Encounter.period is not entirely self-explanatory, especially when period is considered alone, outside of the context provided by Encounter . To be more reusable, OBF uses the name OccurrencePeriod . Coupled with a different event, such as a procedure, the renamed attribute's meaning is more clear. Although an attribute name is rarely a sufficient definition, OBF moves the needle in that direction.","title":"Naming"},{"location":"cimpl6ObjectiveFHIR/#obf-actors","text":"Name Description SubjectOfRecord Identifies the person whose clinical record contains the information. The SubjectOfRecord is often the same as the Patient or Subject, but in some cases, the subject of information (called the FocalSubject ) may be different than the SubjectOfRecord. InformationSource The originator or source of the information or request: a practitioner, patient, related person, organization, an algorithm, device, etc. Author The actor who created the item and it responsible for the content (regardless of the information source or who recorded it). If only the author is given, it is assumed the author is the information source and the recorder. FocalSubject The person or entity that the information in this resource relates to, if different than the person of record. Participant An actor (usually a Practitioner, Patient, or Organization but potentially a device or other entity) that participates in a healthcare task or activity. The participant is not necessarily the performer of the action. Performer The actor that carried out the observation or action. Note: Currently, OBF doesn't include the information recorder among the key actors. The recorder is the actor who physically enters the information, as opposed to creating or being responsible for the information. Author is occasionally mapped to a FHIR attribute named recorder when it is apparent that the resource designers assumed the author and recorder are the same.","title":"OBF Actors"},{"location":"cimpl6ObjectiveFHIR/#obf-event-times","text":"Name Description CreationDateTime The point in time when an ancillary item (such as a report or image) was created. OccurrenceTimeOrPeriod The time or period when the event occurred. StatementDateTime The time when the documentation of an event, action, or situation was created. RelevantTime The time or time period that the statement addresses, not necessarily when the information is gathered. LastUpdated The last time a record was updated.","title":"OBF Event Times"},{"location":"cimpl6ObjectiveFHIR/#building-blocks","text":"OBF classes fall into one of four categories, which are the building blocks of CIMPL: Building Block Description Inherits from Analogous FHIR Type Element The lowest-level building block, representing a property-value pair. Element Property or simple extension Group A building block comprised of other building blocks, specifically, other Groups, Elements, and Entries. Group Backbone element or complex extension Entry A building block representing a group of related information, complete enough to support stand-alone interpretation. Entry or Abstract Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Abstract none","title":"Building Blocks"},{"location":"cimpl6ObjectiveFHIR/#class-hierarchy","text":"In this section, we describe the overall organization and some key classes in Objective FHIR. A pared-down view of the OBF hierarchy is shown below. For full details of each class, please refer to the OBF model documentation . The purpose of the hierarchy is two-fold: 1) To define properties uniformly across multiple classes. For example, almost every FHIR resource should have an author, but many don't, and those that do use a variety of different names . It shouldn't be left up to individual resources, managed by different work groups, to each define author themselves. Inevitably, they will define it differently, or forget entirely, as FHIR R4 shows. Inheriting from a common parent prevents that. 1) To provide a set of ready-made classes that users can extend. An example is QuantitativeLaboratoryObservation , based on Observation . FHIR's approach to uniformity is to define certain patterns, such as the request pattern . However, FHIR stops short of actually implementing these patterns across resources. Implementations can't assume all requests have the same core properties, and can't write generic methods for processing requests. Instead, each type of request must be implemented as a one-off.","title":"Class Hierarchy"},{"location":"cimpl6ObjectiveFHIR/#resource-domain-resource-metadata","text":"At the top of the OBF hierarchy are the classes Resource and DomainResource. They involve the Metadata group. These classes align with FHIR.","title":"Resource, Domain Resource, Metadata"},{"location":"cimpl6ObjectiveFHIR/#information-item","text":"InformationItem includes definitional items, value set definitions, questionnaire, research study, entities such as locations and organizations, people, financial information, etc. While InformationItem has no attributes itself, it serves as a conceptual grouper for things that exist in the clinical world that are not statements about a patient's health or healthcare.","title":"Information Item"},{"location":"cimpl6ObjectiveFHIR/#entityorrole","text":"This branch of the hierarchy, which splits into Entity and Role, represent the potential actors in healthcare scenarios. Entities include organizations, locations, devices, medications, and other \"things\", physical and conceptual. Roles are patient, practitioner, related person, and research subject. FHIR models these resources by conflating the role with the person playing the role. Although this is not the optimal model, OBF continues that practice, just to make OBF more obvious to FHIR users. Earlier versions of OBF modeled a person separately from the role(s) that person could play.","title":"EntityOrRole"},{"location":"cimpl6ObjectiveFHIR/#clinical-statement","text":"ClinicalStatement provides properties and behaviors common to entries in a medical record. This class also allows for common representation of simple data provenance elements: SubjectOfRecord , CareContext ( Encounter or EpisodeOfCare ), and StatementDateTime . Below ClinicalStatement are two classes, SituationStatement and ActionStatement : SituationStatements covers many types of descriptive information, including opinions, evaluations, laboratory results, genomic data, and social information. ActionStatements covers requested and performed actions, such as prescribing and taking medications, performing procedures, requesting a service.","title":"Clinical Statement"},{"location":"cimpl6ObjectiveFHIR/#future","text":"Current work is focused on using the classes defined in Objective FHIR directly in implementations, leveraging automatically generated Javascript classes and methods that, at runtime, translate FHIR resources to and from the logical model classes. This would allow implementers to use object oriented programming in much more powerful ways than available in native FHIR, with its flat class structure and complex extension representations.","title":"Future"},{"location":"cimpl6ObjectiveFHIR/#appendix-relationship-to-other-initiatives","text":"Conceptually, Objective FHIR could be expressed in other modeling frameworks, besides CIMPL. Some of the potential frameworks include: Unified Modeling Language (UML) for structure coupled with Object Constraint Language (OCL) for constraint representation. The Federal Health Information Model initiative (FHIM) has conducted some experiments using Model-Driven Health Tools to try and convert UML/OCL models into FHIR profiles. Basic Meta-Model (BMM) for class hierarchy, coupled with Archetype Description Language (ADL) for constraint representation. BMM/ADL has been used in openEHR . Claude Nanjo of University of Utah has conducted some experiments to try to convert ADL/BMM models into FHIR profiles. Clinical Element Models . CEMs are being used to produce some Clinical Information Modeling Initiative (CIMI) FHIR Implementation Guides . Essential parts of CEM-related tooling are internal to Intermountain Healthcare. Objective FHIR is an open source project , and we welcome contributions.","title":"Appendix: Relationship to Other Initiatives"},{"location":"cimpl6ToolingReference/","text":"CIMPL 6.0 Tooling Reference Note: This documentation is a draft. This is a comprehensive guide to CIMPL 6.0 Tooling, including the command line interface, auxiliary files, and configurations needed to produce a FHIR Implementation Guide (IG). If you're looking for a quick introduction to CIMPL and SHR-CLI environment setup, try the Hello World or In-Depth Tutorials . For details of the CIMPL language itself, see the CIMPL Language Reference Manual . Table of Contents CIMPL 6.0 Tooling Reference Overview CIMPL Tooling Overview Inputs Processing Sequence Outputs Relationship of CIMPL Models and Implementation Guides Typical IG-Data Model Relationship Relationship between IGs and Data Models in CIMPL Suggested Directory Structure Naming Conventions Configuration File Filter Strategy Configuration Parameters Implementation Guide Configuration Parameters Provenance Information Configuration Parameters Front Matter Files FHIR Examples Configuration for FHIR Examples Package List File Content Profile File Executing SHR-CLI Addressing Error Messages Outputs from SHR-CLI Typical Contents of the /out Directory FHIR Export Logical Model Export Logical Model Example Model Documentation Export Model Documentation Example Data Dictionary Export JSON Schema Export Creating the Implementation Guide Appendix A: Error Messages Table of Contents Error Code Structure Parsing Errors Warning Codes Compilation Error Codes Mapping Error Codes Overview This reference manual describes the configurations, files, and commands needed to create a FHIR IG from CIMPL ( C linical I nformation M odeling P rofiling L anguage). It assumes that the CIMPL Language files (classes, value sets, and maps) have been defined (see CIMPL Language Reference Manual for details). It also assumes that the CIMPL SHR-CLI tooling has been installed according to the directions in the Setup and Installation Guide . The CIMPL Tooling, also called SHR-CLI (Standard Health Record Command Line Interface), is the engine that imports a set of inputs, including CIMPL language files, and exports FHIR and other outputs, as shown below: CIMPL Tooling Overview Inputs CIMPL Language files , including class files, value set files, and mapping files that define your clinical information model, A Configuration file that contains directives to the tooling, and points to other resources, An optional Content Profile file, which specifies Must-Support elements and profiling options specific to an IG, One or more Front Matter files, which are the narratives and graphics that introduce the IG, FHIR Examples that are to be included in the IG, and A Package List that has information required for building the IG. Processing Sequence The user issues a build command through the command-line interface (CLI) to launch SHR-CLI. The CIMPL tooling imports definitions from CIMPL files (class, value set, and map files). SHR-CLI reports any errors in the CIMPL definitions. Continuing the build process, SHR-CLI selects a subset of the data models to include in the IG, according to the filter strategy . To complete the build process, SHR-CLI exports the selected CIMPL definitions into desired formats, such as FHIR profiles, data dictionaries, etc. The exports can be selected through command line options . The user issues a separate command to produce the IG. Outputs Depending on the configuration options selected, the SHR-CLI produces one or more of the following outputs: FHIR Profiles, Extensions, Value Sets that form the core content of the IG, A Logical Model corresponding to the CIMPL class definitions, expressed as FHIR StructureDefinitions, JSON Schema for the profiles defined by the IG, A Data Dictionary that lists the Must-Support data elements in the IG, as well as value sets and value set members, Model Documentation in the form of a Javadoc-like browser that allows one to see the hierarchical class relationships in the logical model. Relationship of CIMPL Models and Implementation Guides It is important to understand the relationship between models defined in CIMPL and implementation guide(s) created from those models. The state-of-practice for FHIR IGs is still evolving, but currently, most IGs are developed by separate groups and define their own data models, as follows: Typical IG-Data Model Relationship The drawback of this approach is that different IGs can require very similar data models. If different data models are developed by different teams, interoperability will suffer. In CIMPL, data models are independent of IGs. IGs are consumers of models, rather than owners of models (although new models can certainly be created in the context of IG development). Each IG uses a different subset of models, reflecting the different use cases they address, but the commonality of data models assures interoperability between the use cases. This idea is illustrated below: Relationship between IGs and Data Models in CIMPL Much of what is discussed subsequently reflects this conceptual picture of the relationship between CIMPL models and IGs. Suggested Directory Structure The SHR-CLI tooling does not require a particular directory structure. However, following conventions makes the process of managing the requisite files much easier. Here is an example of the suggested arrangement that assumes the same IG can be produced under FHIR STU3 and R4: \u251c\u2500\u2500 shr-cli-6.5.0 // Tooling location | ... | \u251c\u2500\u2500 spec // Main specification directory | \u251c\u2500\u2500 ns-namespace1 // Namespace directories | | \u251c\u2500\u2500 namespace1-foo.txt // class file(s) | | \u251c\u2500\u2500 namespace1-bar.txt | | \u251c\u2500\u2500 namespace1-foo-vs.txt // value set file(s) | | \u251c\u2500\u2500 namespace1-bar-vs.txt | | \u251c\u2500\u2500 namespace1-foo-map-stu3.txt // map(s) for FHIR STU3 | | \u251c\u2500\u2500 namespace1-bar-map-stu3.txt | | \u251c\u2500\u2500 namespace1-foo-map-r4.txt // map(s) for FHIR r4 | | \u2514\u2500\u2500 namespace1-bar-map-r4.txt | \u251c\u2500\u2500 ns-namespace2 | | ... | \u251c\u2500\u2500 ns-namespace3 | | ... | | ... | \u251c\u2500\u2500 ig-myguide1 // IG directories | | \u251c\u2500\u2500 myguide1-examples // directory of examples | | | \u251c\u2500\u2500 example1 | | | \u2514\u2500\u2500 example2 | | \u251c\u2500\u2500 myguide1-frontmatter // directory containing narratives | | | \u251c\u2500\u2500 index.html | | | \u251c\u2500\u2500 picture.png | | | \u2514\u2500\u2500 another-page.html | | \u251c\u2500\u2500 myguide1-stu3-cp.txt // content profile file for FHIR STU3 IG | | \u251c\u2500\u2500 myguide1-r4-cp.txt // content profile file for FHIR R4 IG | | \u251c\u2500\u2500 myguide1-stu3-plist.json // package list for FHIR STU3 IG | | \u251c\u2500\u2500 myguide1-r4-plist.json // package list for FHIR R4 IG | | \u251c\u2500\u2500 myguide1-stu3-config.json // config file for FHIR STU3 IG | | \u2514\u2500\u2500 myguide1-r4-config.json // config file for FHIR R4 IG | \u251c\u2500\u2500 ig-myguide2 | | ... In this reference guide, we will refer to several directories: Tooling Directory - this the directory where the SHR-CLI tooling has been installed. Any convenient directory can be used. For easy identification, we recommend the tooling version number be included in the directory name. Specification Directory - this is the top level directory where the input files and are located, usually arranged in sub-folders. Any convenient directory can be used. If you are using a source code control system such as Github to manage your development, this could be where the repository is checked out to your local machine. Namespace Directories - these directories, located under the Specification Directory, contains CIMPL language files for a single namespace. The name of the directory should be prefixed with ns- followed by the shortname or acronym of the namespace followed . IG Directories - these directories, under the specification directory contain files specific to a given implementation guide. There are subdirectories containing the front matter and examples, and individual configuration, content profile, and package list files. These files can be specific to a FHIR release, since the same IG could be created using different versions of FHIR. Note: There is currently no way to combine profiles for multiple FHIR versions in single IG. Naming Conventions The naming of configuration, content profiles, and package list files is arbitrary, but it is useful for different teams to follow similar conventions. The suggested approach to naming uses variations on the same shortened IG name, as follows: Configuration file: ig-<guide-name>-config.json Content Profile file: ig-<guide-name>-cp.txt Package List file: ig-<guide-name>-plist.json If more than one FHIR version will be supported, the FHIR version should be included: Configuration file: ig-<guide-name>-<FHIR Version>-config.json Content Profile file: ig-<guide-name>-<FHIR Version>-cp.txt Package List file: ig-<guide-name>-<FHIR Version>-plist.json where FHIR version is dstu2, stu3, or r4. Configuration File SHR-CLI requires a configuration file to run. The name of this file is typically specified on the command line using the -c command line option . If the name is not specified, the tooling looks for a file named config.json in the working directory. If that cannot be found, or the contents of the configuration file are invalid, an error message is returned. The configuration file is a JSON file with the following parameters: Parameter Type Description projectName string The full, official name of the project, for example \"HL7 FHIR Implementation Guide: minimal Common Oncology Data Elements (mCODE) Release 1 - US Realm, STU Ballot 1\" projectShorthand string A shorthand name for the project, such as \"mcode\". projectURL string The primary URL for the project, such as \"http://hl7.org/fhir/us/mcode/\" fhirURL string The FHIR IG URL for the project, often the same as the projectURL. (TO DO: clarify the difference between projectURL, fhirURL, and entryTypeURL) fhirTarget string The FHIR version this IG will be based on, currently a choice of \"FHIR_R4\" , \"FHIR_STU_3\" , or \"FHIR_DSTU_2\" entryTypeURL string The root URL for the JSON schema EntryType field. (TO DO: clarify where and how this is used) filterStrategy {} A JSON object containing configuration for filtering ( see below ). contentProfile string The file name of the content profile for the project. implementationGuide {} A JSON object containing configuration for IG publishing ( see below ). copyrightYear string The copyright year to include in the documentation. publisher string The name of the publisher for the project, which for HL7 projects, should be the sponsoring workgroup, for example, \"HL7 International Clinical Interoperability Council\". contact [] A JSON array containing HL7 FHIR R4 ContactPoint objects . provenanceInfo {} A JSON object specifying author and other information ( see below ) Filter Strategy Configuration Parameters Between the import stage and the export stage, there is a filtering stage (see CIMPL Tooling Overview ). Filtering is useful when specification directory contains namespaces that or entries that are outside the scope of the current IG, and should not be included in the IG. Filtering removes unwanted namespaces and entries to limit the scope of the exports, and subsequently, the IG. The contents of the filterStrategy object are as follows: Parameter Type Description filter boolean A value indicating whether to enable filtering. If filter is true , then the filtering operation will occur. Otherwise, no filtering will occur. (Also, if the filterStrategy parameter is entirely omitted, no filtering will occur.) strategy string The strategy for specification filtering, either \"namespace\", \"element\", or \"hybrid\". target [] An array of strings containing the names of Entries, Namespaces, or both. The \"element\" strategy filters the imported classes to include each Entry listed in the target array, and their recursive dependencies. The \"namespace\" strategy filters the imported classes to include only Entries in the namespaces listed in the target array, and their recursive dependencies. The \"hybrid\" strategy filters the imported classes to include each Entry listed in the target array and all Entries in every namespace listed in the target array, and their recursive dependencies. When specifying an Entry in the target array, use the fully qualified name (FQN) format. Implementation Guide Configuration Parameters These configurations are used to control the production of the IG. The contents of the implementationGuide object are as follows: Parameter Type Description npmName string The assigned node package manager name for this IG, for example \"hl7.fhir.us.mcode\". The npm name is usually assigned by HL7. version string The version of this IG (not necessarily the version of FHIR), usually in the form major.minor.revision , for example, \"3.0.1\" ballotStatus string The HL7 ballot status of the IG (e.g., STU1 Ballot, Continuous Integration Build, etc.) packageList string The name of the file to use as the IG's package list , relative to the Specification Directory. includeLogicalModels boolean A \"true\" or \"false\" value indicating whether to include logical models in the IG. includeModelDoc boolean A \"true\" or \"false\" value indicating whether to include the model documentation in the IG. indexContent string The name of the file or folder containing the front matter , relative to the Specification Directory, for example, \"ig-mcode/IndexFolder-Oncocore\". If the indexContent is a folder, then it must contain an index.html file whose contents will be used as the body of the IG home page. extraResources string The name of the folder containing extra JSON resources to include in the IG, one file per resource. Currently, the following resource types are supported: SearchParameter , OperationDefinition , CapabilityStatement (STU3+), Conformance (DSTU2). If files are detected, links are added to the navigation menu as necessary. examples string The name of the folder containing examples (one example per file) to include in the IG, for example, \"ig-mcode/Examples-mCODE-r4\". We recommend the individual example file name match the id in the example file (with .json extension added). The example's meta.profile must match the canonical URL for the profile it exemplifies (e.g. \"meta\": { \"profile\": [ \"http://hl7.org/fhir/us/breastcancer/StructureDefinition/oncology-BreastCancerPresenceStatement\" ] } ). If no examples folder is specified, and a folder named \"fhir-examples\" exists in the specification directory, it will be used as the examples folder. historyLink string The URL for the page containing the IG's history information. (TO DO: clarify where and how this is used) changesLink string The URL to a site where users can request changes (shown in page footer) (TO DO: clarify where and how this is used) primarySelectionStrategy {} The strategy for selection of what is primary in the IG (see below). The primary selection strategy causes certain profiles to be displayed in a \"Primary\" section at the top list of profiles. All other exported profiles are listed in a \"Supporting\" section below the \"Primary\" section. The contents of the primarySelectionStrategy object are as follows: Parameter Type Description strategy string The strategy to follow for primary selection, either \"namespace\", \"hybrid\", or \"entry\" (default). primary [] An array of strings containing the namespaces and entries (only used for \"namespace\" and \"hybrid\" strategy). The strategy options are as follows: \"entry\" selects every exported profile as primary. \"namespace\" selects every profile found in the namespaces of the primary array as primary. \"hybrid\" selects every entry listed in the primary array or found in the namespaces in the primary array as primary. When specifying an Entry in the target array, use the fully qualified name (FQN) format. Provenance Information Configuration Parameters (TO DO: document what this structure can contain) Here is an example of provenanceInformation: \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } Front Matter Files Every IG contains some amount of narrative content, which we refer to as the \" front matter \". The front matter is typically a set of hyperlinked HTML files, graphics, and sometimes, downloads. These files are manually authored using any convenient tool; there are no special facilities in CIMPL to author the front matter. If multiple files are involved, they must be placed into a single folder, named in the indexContent parameter of the configuration file . This folder must contain a file named index.html whose contents will be used as the body of the IG home page (the header and footer of the pages are automatically generated). If a single file is used, the file should be named in the indexContent parameter of the configuration file, and a folder is not required. FHIR Examples Configuring FHIR examples to appear in the generated IG involves the following steps: Create a folder which will contain your FHIR examples Modify the CIMPL configuration file to specify the folder containing your examples The name of the folder is arbitrary, however, following directory structure and naming conventions is recommended. The folder location is specified using the \"examples:\" parameter in the CIMPL configuration file. This is illustrated below: Configuration for FHIR Examples Package List File The format and content of this file follows the FHIR specification for package lists . The package list is required for IGs published by HL7. The file containing the package list is named by the packageList parameter of the configuration file . If the packageList parameter is not supplied and no file is found at the default location (packageList.json), and fhirURL is an hl7.org or fhir.org URL (indicating it is an HL7 publication), then a basic package list file will be created. In this case, the IG author should review and modify the file as needed. Here is an example of a package list file: { \"package-id\": \"hl7.fhir.us.mcode\", \"title\": \"HL7 FHIR Implementation Guide: minimal Common Oncology Data Elements (mCODE) Release 1 - US Realm | STU Ballot 1\", \"canonical\": \"http://hl7.org/fhir/us/mcode\", \"list\": [ { \"version\": \"current\", \"desc\": \"Continuous Integration Build (latest in version control)\", \"path\": \"https://build.fhir.org/ig/HL7/fhir-mCODE-ig\", \"status\": \"ci-build\", \"current\": true }, { \"version\": \"0.9.1\", \"date\": \"2019-06-10\", \"desc\": \"Initial version\", \"path\": \"http://hl7.org/fhir/us/mcode/2019Sep\", \"status\": \"draft\", \"sequence\": \"STU 1\", \"fhir-version\": \"4.0.0\" } ] } Content Profile File In FHIR, Must-Support is a boolean flag which allows a profile to indicate that an implementation must be able to process that element in a FHIR instance if it exists. The Content Profile is where Must-Support elements are declared. Note that the Must-Supports are designated at the level of the IG, not the data model. This is because different elements are important for different use cases. For example, one use case may not require date of death to be supported, but another might. Note: Filtering is the mechanism by which entries (profiles) and namespaces are selected for an IG, and content profiles are the mechanism for declaring Must-Support. The syntax of a Content Profile file is: Grammar: ContentProfile 1.0 Namespace: <namespace-1> <Entry-1>: <Element-1> MS <Element-2> MS ... <Entry-2>: ... Namespace: <namespace-2> <Entry-1>: <Element-1> MS <Element-2> MS ... <Entry-2>: ... Here is an excerpt from a Content Profile file: Grammar: ContentProfile 1.0 Namespace: obf ComorbidCondition: Code MS ClinicalStatus MS MedicationStatement: MedicationCodeOrReference MS OccurrenceTimeOrPeriod MS TerminationReason MS TreatmentIntent MS ECOGPerformanceStatus: DataValue MS Namespace: vital BloodPressure: Components.ObservationComponent MS RelevantTime MS BodyHeight: DataValue MS RelevantTime MS BodyWeight: DataValue MS RelevantTime MS Namespace: onco.core PrimaryCancerCondition: Code MS ClinicalStatus MS BodyLocation.Code MS HistologyMorphologyBehavior MS DateOfDiagnosis MS Note: The grammar of the Content Profile file is still evolving and may include additional information in the future. Executing SHR-CLI The general form of the SHR-CLI execution command is as follows (where $ stands for the command prompt, which could be different on your system): $ node <tooling-directory> <specification-directory> [options] where options include: -c, --config <config> the name of the config file (default: config.json) -l, --log-level <level> the console log level <fatal, error, warn, info, debug, trace> (default: info) -s, --skip <feature> skip an export feature <fhir, json-schema, model-doc, data-dict, all> (default: <none>) -o, --out <out> the path to the output folder (default: out) -m, --log-mode <mode> the console log mode <short,long,json,off> (default: short) -d, --duplicate show duplicate error messages (default: false) -j, --export-es6 export ES6 JavaScript classes (experimental, default: false) -n, --clean Save archive of old output directory and perform clean build (default: false) -h, --help output usage information The options are not order-sensitive. Here is an example of a SHR-CLI command and an explanation of its parts: $ node . ../shr_spec/spec -c ig-mcode/ig-mcode-r4-config.json -l error node is the command that starts the SHR-CLI application. The dot . represents the current directory in Windows and macOS. In this example, the tooling directory is the current working directory. ../shr_spec/spec represents the location of the specification directory. The the double dot .. represents the directory above the current working directory, in Windows and macOS. In this case, /shr_spec is parallel to the tooling directory, and /spec is one level below that. -c ig-mcode/ig-mcode-r4-config.json directs the execution engine to the configuration file. Note that the configuration file location is relative to the specification directory, implying the full path to the configuration is ../shr_spec/spec/ig-mcode/ig-mcode-r4-config.json -l error is an option that sets tells the system to surpress any messages that don't rise to the level of an error . This reduces the amount of output to the console window. Addressing Error Messages In the process of building a model, it is inevitable that you will encounter error messages from SHR-CLI. Debugging the model is an iterative process, and it could take some perseverance to arrive at a \"clean\" run of SHR-CLI with no errors. This is an expected part of the process. A detailed list of CIMPL compilation errors and troubleshooting suggestions are available in Appendix A . Here are some general tips on approaching debugging your model: Always eliminate parsing errors first. Parsing errors can be identified because they include a file, line number, and column number. It is essential to elminate parsing errors first, because parsing errors usually trigger large cascades of other errors, so you can't truly start debugging your model until parsing errors have been eliminated. Once all parsing errors have been eliminated, start working top down on the first (or first few) errors. Often, subsequent errors are a consequence of the first error. Don't be discouraged by the number of errors, since a single correction can silence multiple logged errors. Read the error messages carefully. Although the messages might be cryptic, especially at first, the names of classes and paths are often excellent clues. Outputs from SHR-CLI The output of running SHR-CLI appear in a directory named \"out\". By default, the /out directory is created in the tooling directory. A different location can be designated using the -o command line option . The content of the /out directory depends on which exporters were selected to run, which is controlled using the -s command line option. By default, the /out will contain five exports, as shown below, each corresponding to a separate export process: Typical Contents of the /out Directory cimcore - this directory is used in the process of building the \"modeldoc\" export, and is not discussed further data-dictionary - this directory contains an MS-Excel spreadsheet containing a list of model elements and value sets fhir - this directory contains all the definitions and assets necessary to produce the IG json-schema - this directory contains schemas for the ( TO DO -- need to define the JSON schema export ) modeldoc - this directory contains files that present the model with a look and feel similar to Javadoc FHIR Export The FHIR export consists of profiles, extensions, value sets, code systems, examples, and other artifacts needed to create a FHIR IG. These are not the pages of the IG, but rather various definitions that underlie the IG presentation. You must run the IG publisher to create the IG itself. The FHIR export appears in the /fhir subdirectory under the designated \"out\" directory. The directory contains further subdirectories for code systems, extensions, the IG (guide), the logical model (logical), profiles, and value sets. Logical Model Export The logical model is an alternative representation of the CIMPL model, expressed in a familiar FHIR-like format. The logical model closely follows the CIMPL definitions because it reflects the model prior to mapping to FHIR resources. Each entry is presented as if it were a new FHIR resource, rather than a profile. The logical model is formally expressed as a set of FHIR StructureDefinitions . These definitions are distinguished from profiles because the names generated by the tooling end in -model . Because the logical model does not entail the additional complication of mapping, it is useful for review purposes. The logical model can be checked for clinical relevance and sufficiency before making mapping decisions. An optional part of the FHIR export, the logical model can be turned on or off using the includeLogicalModels flag in the configuration file. Logical Model Example Model Documentation Export The model documentation provides another way to view the logical model. This view emphasizes the class hierarchy defined in CIMPL, the datatypes, associated constraints, and relationships between the classes (references). The panel in the upper left allows the user to filter on the namespace and (in SHR-CLI 6.6 and higher) the class type (Entry, Group, or Element). The right-hand panel shows details for the selected class, include the full set of properties and constraints. For many users, especially those with experience in object-oriented modeling, the model documentation is the quickest way to navigate around the model. Model Documentation Example Data Dictionary Export The Data Dictionary is an Microsoft Excel file containing a simplified, flattened list of model elements and value sets, extracted from the FHIR profiles. The spreadsheet has five tabs: The \"Key\" tab contains a key to the columns in the other tabs; The \"Profiles\" tab contains a list of the primary profiles and their descriptions; The \"Data Elements\" tab contains a list of Must-support and required elements associated with those profiles; The \"Value Sets\" tab contains a list of value sets used in the IG, and their descriptions; The \"Value Set Details\" tab contains a list of the codes and/or implicit definitions in those value sets. The Data Dictionary can be useful both to clinicians and implementers who don't need the structural details of the FHIR profiles, but want the contents in list form. For many reviewers and contributors, this can be an easy-to-use format to facilitate discussion and feedback. JSON Schema Export ( TO DO: determine what to say here ) Creating the Implementation Guide The final step in the IG creation process is to run the FHIR IG Publisher . This tool is maintained and owned by HL7 FHIR. Open a command prompt, change directories to the tooling directory, and use one of these two options: If you used the default \"out\" directory when running SHR-CLI: $ yarn run ig:publish If you used a different \"out\" directory: $ java -Xms4g -Xmx8g -jar /your/out/directory/fhir/guide/org.hl7.fhir.publisher.jar -ig /your/out/directory/fhir/guide/ig.json Note: The IG publisher can take 15-30 minutes or even longer to run, depending on the size of the IG, and it takes lots of memory. The yarn script above will allocate up to 8GB of RAM. A minimum of 4GB of RAM is recommended to run the IG Publisher tool. When the publisher finishes, the IG can be opened by running the following commands. If you used default \"out\" directory: $ yarn run ig:open If you used a different \"out\" directory, by manually opening the file: $ /your/out/directory/fhir/guide/output/index.html You now have your completed IG. The FHIR IG Publisher performs numerous validation checks on the content of the IG. The output of these checks can be accessed through the \"QA Report\" link in the footer of the home page, or by opening the file /out/fhir/guide/output/qa.html . An example QA output is shown below: Appendix A: Error Messages In the following, $ prefix indicates a variable that will be filled in with specific information. Table of Contents Error Code Structure Parsing Errors Warning Codes Compilation Error Codes Mapping Error Codes Error Code Structure CIMPL Compilation Errors are structured in the following format: 1 2 3 4 5 \u21b3 First digit tells whether it is an warning or error. 0 = warning, 1 = error 1 2 3 4 5 \u21b3 Second digit indicates the phase of processing where the error appeared: 1 = grammar and importing of the text files, 2 = logical verification of the model, 3 = exporting of FHIR profiles, 4 = exporting of the JSON profiles 1 2 3 4 5 \u21b3 The last three digits are for unique identification and have no particular meaning. Parsing Errors Parsing errors are generated when the importer cannot make sense of the contents of a CIMPL statement. Parsing error messages include the file, line, and column number, and can be linked directly to a location in a CIMPL file where parsing failed. Most other types of errors (with the exception of mapping errors) cannot be linked to a specific file location because they represent some type of a logical inconsistency. A typical parsing error looks like this: extraneous input 'Entry' expecting {<EOF>, 'CodeSystem:', 'Abstract:', 'Element:', 'Entry:', 'Group:'}. ERROR_CODE:11023 (module=shr-text-input, file=..\\shr_spec\\spec\\ns-onco-core\\oncocore.txt, line=9, column=0) When a parsing error occurs, the associated error code number and subsequent errors are not meaningful, since the entire model could not be read. Warning Codes Warning Code Warning Message Potential Solution 01001 No project configuration file found, currently using default EXAMPLE identifiers. Auto-generating a proper 'config.json' in your specifications folder Open the 'config.json' file and customize it for your project. 01002 Config file missing key: $KEY , using default key: $DEFAULT VALUE instead. Open the 'config.json' file and add your project specific details for that key. 02001 Potentially mismatched targets: $CLASS maps to $ITEM , but based on class ( $CLASS ) maps to $ITEM , and $ITEM is not based on $ELEMENT in $CLASS .' You are overriding an inherited mapping. 03001 Trying to map $PROFILE to $CODE , but $PROFILE was previously mapped to it 03002 Choice has equivalent types, so choice options may overwrite or override each other when mapped to FHIR. 03003 Overriding extensible value set constraint from $VS1 to $VS2 . Only allowed when new codes do not overlap meaning of old codes. The \"extensible\" binding means that a code from outside the given value set should be used only if the value set does not contain a suitable code. 03004 Element profiled on Basic. Consider a more specific mapping. The Basic profile should not be used in most cases. Consider a more specific profile mapping that categorizes the Element being mapped. 03005 No mapping to ' $ELEMENT PATH '. This property is core to the target resource and usually should be mapped. 03006 The $PROPERTY property is not bound to a value set, fixed to a code, or fixed to a quantity unit. This property is core to the target resource and usually should be constrained Usually a result of not setting the Code attribute of an Observation. 04001 Unsupported code system: ' $CODESYSTEM ' Compilation Error Codes Error Code Error Message Solution 11001 Element name ' $NAME ' should begin with a capital letter Rename the specified Element 11002 Entry name ' $NAME ' should begin with a capital letter Rename the specified Entry 11003 Unable to resolve value set reference: $VALUESET Invalid value set reference, double check the name and the path 11004 Unsupported binding strength: $BINDING_STRENGTH . Defaulting to REQUIRED Binding strength has to be one of the following: example, preferred, extensible, or required (default). 11005 Error parsing source path: $PATH Invalid path to definitions. Double check path. 11006 Invalid config file. Should be valid JSON dictionary Make sure your 'config.json' file is using a valid format for JSON. 11007 Unsupported grammar version: $VERSION Grammar Version for file must be 5.0 (or above) 11008 Defining value sets by URL has been deprecated in ValueSet files. ValueSet $VALUESET ignored. Define the value set with a name using proper syntax. 11009 Defining value sets by URN has been deprecated in ValueSet files. ValueSet $VALUESET ignored. Define the value set with a name using proper syntax. 11010 Couldn\u2019t resolve code system for alias: $ALIAS Invalid Codesystem, double check spelling 11011 Uses statements have been deprecated in ValueSet files. Uses statement ignored. Uses statement is unnecessary. Refer to documentation for proper syntax 11012 Only default path definitions are allowed in ValueSet files. Path definition ignored. Use one of the preset path definitions defined in the documentation. 11013 Failed to resolve definition for $ELEMENT_NAME The referenced Element doesn't exist in the current namespace, or in any of its inherited parents. Check spelling errors as well as imports. 11013 Failed to resolve definition for primitive Only certain primitives are supported. Please refer to the documentation to see the full list. 11015 token recognition error at: $CHARACTER This is usually a typo issue. Investigate keywords and missing colons around the specificed text input. 11016 mismatched input $INPUT expecting $LIST_OF_KEYWORDS This is usually a typo issue. Investigate spelling and keywords used around the specificied text input. 11017 Cannot resolve path without namespaces There was a failure to parse the namespace. Ensure the namespace is correctly defined. 11018 Failed to resolve path for $NAME . 11019 Found conflicting path for $NAME in multiple namespaces: $NAMESPACES 11020 Failed to resolve vocabulary for $NAME . 11021 Found conflicting vocabularies for $NAME in multiple namespaces: $NAMESPACES 11022 Found conflicting definitions for $NAME in multiple namespaces: $NAMESPACES 11023 Elements cannot be based on \"Value\" keyword 11024 Elements cannot use \"Value:\" modifier and specify \"Value\" field at same time. 11025 Fields cannot be constrained to type \"Value\" 11026 ref(Value) is an unsupported construct; treating as Value without the reference. 11027 Unable to import property $FQN , unknown value type: $VALUE_TYPE The type either does not exist, or the import tool needs to be updated. 11028 Unable to import unknown constraint type: $CONSTRAINT_TYPE The type either does not exist, or the import tool needs to be updated. 11029 Unable to import mapping, unknown rule type: $RULE_TYPE The type either does not exist, or the import tool needs to be updated. 11030 Unable to import VS rule, unknown rule type: $RULE_TYPE The type either does not exist, or the import tool needs to be updated. 11031 Unable to import FixedValueConstraint, unknown fixed value type: $RULE_TYPE The value type either does not exist, or the import tool needs to be updated. 11032 Project configuration not found! Exiting the program. There was an error finding or loading the configuration file. Please double check that it exists and is valid. 11033 Name $ELEMENT_ENTRY_NAME already exists. The entity or element name already exists within the namespace and the most recently defined element or entry name will be used. 11034 ValueSet name $VS_NAME already exists. The value set name already exists within the namespace. 11035 Definition not found for data element in content profile path: $ELEMENT_FQN . Could indicate a missing definition, misspelling, or missing Uses declaration. 11036 Path not found for $ELEMENT_FQN : $PATH . Usually when sub-elements in a dotted path (foo.bar.baz) can't be traced. See CIMPL path for more information. 11037 Could not find content profile file: $FILE_NAME . Check the name or path to the content profile file specified in your configuration file. 11038 Namespace declaration not found. File needs a namespace declaration at the top of the file under the Grammar declaration. 11039 Grammar declaration not found. File needs a Grammar declaration at the top of the file. 11040 Property $PROPERTY already exists. Extra declaration of Property needs to be removed. 11041 Choice value constrained without specifying the specific choice. 11042 Constraint refers to previous identifier. 11043 Value should not be declaring cardinality. Remove cardinality declared for the value. 11044 Missing a value element. 12001 Cannot resolve element definition. Element doesn't exist. Double check spelling and inheritance 12002 Reference to non-existing base: $ELEMENT_NAME Base doesn't exist. Double check spelling and inheritance. 12003 No cardinality found for value: $VALUE Explicitly define cardinality for that value. 12004 No cardinality found for field: $FIELD Explicity define cardinality for that field. 12005 Cannot override $OLD_VALUE with $NEW_VALUE Double check types match. 12006 Cannot override $OLD_VALUE with $NEW_VALUE since it is not one of the options Verify Identifiers match. 12007 Cannot override $OLD_VALUE with $NEW_VALUE Verify Identifiers match. 12008 Cannot override $OLD_VALUE with $NEW_VALUE since overriding ChoiceValue is not supported Verify Identifiers match. 12009 Unsupported constraint type: $CONSTRAINT Invalid constraint syntax. Consult documentation to see what constraints are supported 12010 Cannot constrain cardinality of $NAME from $SMALL_CARDINALITY to $BIGGER_CARDINALITY You can only narrow the cardinality. You cannot constrain it to have a larger range than its parent 12011 Cannot further constrain cardinality of $NAME from $CARDINALITY to $CARDINALITY You can only narrow the cardinality. You cannot constrain it to have a larger range than its parent 12012 Cannot constrain type of $NAME to $TYPE Make sure base types match 12013 Cannot constrain type of $NAME since it has no identifier Invalid Element 12014 Cannot constrain type of $NAME to $TYPE Make sure base types match 12015 Cannot further constrain type of $NAME from $TYPE to $TYPE The two elements aren't based on the same parent. You cannot constrain an element to one that is completely distinct. 12017 Cannot constrain type of $NAME since it has no identifier 12018 Cannot constrain element $NAME to $TARGET since it is an invalid sub-type Element has to be based on $s or otherwise is a child of $s . 12020 Cardinality of $NAME not found Please explicitly define the cardinality. 12021 Cannot include cardinality on $NAME , cardinality of $CARD doesnt fit within $CARD The cardinality of included parameters must be as narrow or narrower than the property it contains. 12022 Cannot constrain valueset of $NAME since it has no identifier 12023 Cannot constrain valueset of $NAME since neither it nor its value is a code, Coding, or CodeableConcept ? 12024 Cannot constrain valueset of $NAME since it is already constrained to a single code ? 12025 Cannot constrain code of $NAME since neither it nor its value is a code, based on a Coding, or based on CodeableConcept ? 12026 Cannot constrain included code of $NAME since neither it nor its value is a code, based on a Coding, or based on CodeableConcept ? 12027 Cannot constrain boolean value of $NAME since neither it nor its value is a boolean ? 12028 Cannot constrain boolean value of $NAME to $VALUE since a previous constraint constrains it to $VALUE ? 12029 Cannot resolve element definition for $NAME This is due to a incomplete definition for an element. Please refer to the document for proper definition syntax. 12030 Cannot determine target item System error. 12031 Cannot resolve data element definition from path: $PATH Check spelling for field or value. 12032 Cannot resolve data element definition from path: $PATH Check spelling for field or value. 12033 Cannot map Value since element does not define a value Define a value for your element 12034 Cannot map Value since it is unsupported type: $VALUE_TYPE ? 12035 Found multiple matches for field $FIELD Please use fully qualified identifier. 12036 Could not find expanded definition of $ELEMENT . Inheritance calculations will be incomplete. Double check shr.base.Entry is defined within the specifications. 12037 Could not find based on element $ELEMENT for child element $ELEMENT . Double check the basedOn element is defined within the specifications and correctly referenced. 14001 Unsupported value set rule type: $s 14002 Unknown type for value $VALUE 14003 Unknown type for constraint $CONSTRAINT Mapping Error Codes Error Code Error Message Solution 13001 Invalid FHIR target: $TARGET Could not find the FHIR resource or profile you're trying to map to. Check spelling and FHIR version. 13002 Cannot flag path as mapped 13003 Slicing on include type constraints with paths is not supported 13004 Slicing required to disambiguate multiple mappings to $TARGET 13005 Invalid source path 13006 Invalid or unsupported target path 13007 Cannot unroll contentReference $CONTENT_REFERENCE on $ELEMENT because it is not a local reference 13008 Invalid content reference on $ELEMENT : $CONTENT_REFERENCE 13009 Cannot unroll $ELEMENT . Create an explicit choice element first. 13010 Cannot unroll $ELEMENT at $ELEMENT : invalid SHR element. 13011 Cannot make choice element explicit since it is not a choice ([x]): $ELEMENT 13012 Cannot make choice element explicit at $ELEMENT . Invalid SHR identifier: $IDENTIFIER . 13013 Invalid target path. Cannot apply cardinality constraint. 13014 Cannot constrain cardinality from $CARD to $CARD 13015 Invalid target path. Cannot apply fixed value. 13016 Currently, only fixing codes is supported (value must contain \"#\"). Unable to fix to $VALUE . 13017 Incompatible cardinality (using aggregation). Source cardinality $CARD does not fit in target cardinality 13018 Cannot constrain cardinality to $CARD because cardinality placement is ambiguous. Explicitly constrain parent elements in target path. 13019 Cannot constrain cardinality to $CARD because there is no tail cardinality min that can get us there 13020 Cannot constrain cardinality to $CARD because there is no tail cardinality max that can get us there 13021 Cannot constrain cardinality to $CARD because there is no tail cardinality that can get us there 13022 Mismatched types. Cannot map $SOURCE_VALUE to $MAPPING . Find the EntryElement referenced in the error details and change it to match the data type of the target field. 13023 Cannot resolve element definition for $ELEMENT 13024 Failed to resolve element path from $ELEMENT to $PATH 13025 Applying constraints to profiled children not yet supported. SHR doesn\\ 13026 Failed to resolve path from $ELEMENT to $PATH 13027 Unsupported binding strength: $BINDING_STRENGTH 13028 Cannot change binding strength from $BINDING_STRENGTH to $BINDING_STRENGTH 13029 Cannot override value set constraint from $URI to $URI 13030 Found more than one value set to apply to $ELEMENT . This should never happen and is probably a bug in the tool. 13031 Found more than one code to fix on $ELEMENT . This should never happen and is probably a bug in the tool. 13032 Can\u2019t fix code on $ELEMENT because source value isn\u2019t code-like. This should never happen and is probably a bug in the tool. 13033 Can\u2019t fix code on $ELEMENT because source value isn\u2019t code-like. This should never happen and is probably a bug in the tool. 13034 Cannot override code constraint from $VALUE to $VALUE 13035 Cannot override boolean constraint from $VALUE to $VALUE 13036 Found more than one boolean to fix on $ELEMENT . This should never happen and is probably a bug in the tool. 13037 Conversion from $VALUE to one of $TYPE drops boolean constraints 13038 Conversion from $VALUE to one of $TYPE drops value set constraints 13039 Conversion from $VALUE to one of $TYPE drops code constraints 13040 Conversion from $VALUE to one of $TYPE drops includesCode constraints 13041 Unable to establish namespace for $ELEMENT 13042 No slice name supplied for target. This should never happen and is probably a bug in the tool. 13043 Couldn\u2019t find target in slice $SLICE (Exporting) 13044 Target resolves to multiple elements but is not sliced 13045 Unable to establish namespace for $FIELD (Extensions) 13046 Mapping to MAP_TARGET 's RULE_TARGET : slice could not be found. 13047 Couldn't find sd to unroll 13048 Cannot override code constraint from $SYSTEM | $CODE to $SYSTEM | $CODE ' 13049 Unexpected error processing mapping to FHIR. 13050 Unexpected error processing mapping rule. 13051 Unexpected error adding extension. 13054 Using profile that is currently in the middle of processing: $PROFILE_ID . 13055 Using extension that is currently in the middle of processing: $EXTENSION_ID . 13056 Can't fix $TARGET to $VALUE since $TARGET is not one of: $ALLOWABLE_TYPES . 13057 Could not fix $TARGET to $VALUE ; failed to detect compatible type for value $VALUE . 13058 Cannot fix $TARGET to $VALUE since it is not a $TYPE type. 13059 Cannot fix $TARGET to $VALUE since it is already fixed to $OTHER_VALUE . 13060 Could not determine how to map nested value ( $ELEMENT_PATH ) to FHIR profile. Occurs on the FHIR profile export when there are multiple levels of reference specified. e.g.: LaboratoryObservationTopic.Specimen.CollectionSite within LaboratoryObservationTopic. Resolved by creating a reference in the cimi entity to FHIR map in cimi_entity_map.txt. 13061 Mapping $ELEMENT sub-fields is currently not supported. 13062 Cannot make choice element explicit at $ELEMENT . Could not find compatible type match for: $TYPE . 13063 Could not find FHIR element with path $ELEMENT_PATH for content profile rule with path $RULE_PATH . 13064 Could not find FHIR element for content profile rule with path $RULE_PATH . 13065 Could not find FHIR element subextension for content profile rule with path $RULE_PATH .","title":"CIMPL 6.0 Tooling Reference"},{"location":"cimpl6ToolingReference/#cimpl-60-tooling-reference","text":"Note: This documentation is a draft. This is a comprehensive guide to CIMPL 6.0 Tooling, including the command line interface, auxiliary files, and configurations needed to produce a FHIR Implementation Guide (IG). If you're looking for a quick introduction to CIMPL and SHR-CLI environment setup, try the Hello World or In-Depth Tutorials . For details of the CIMPL language itself, see the CIMPL Language Reference Manual . Table of Contents CIMPL 6.0 Tooling Reference Overview CIMPL Tooling Overview Inputs Processing Sequence Outputs Relationship of CIMPL Models and Implementation Guides Typical IG-Data Model Relationship Relationship between IGs and Data Models in CIMPL Suggested Directory Structure Naming Conventions Configuration File Filter Strategy Configuration Parameters Implementation Guide Configuration Parameters Provenance Information Configuration Parameters Front Matter Files FHIR Examples Configuration for FHIR Examples Package List File Content Profile File Executing SHR-CLI Addressing Error Messages Outputs from SHR-CLI Typical Contents of the /out Directory FHIR Export Logical Model Export Logical Model Example Model Documentation Export Model Documentation Example Data Dictionary Export JSON Schema Export Creating the Implementation Guide Appendix A: Error Messages Table of Contents Error Code Structure Parsing Errors Warning Codes Compilation Error Codes Mapping Error Codes","title":"CIMPL 6.0 Tooling Reference"},{"location":"cimpl6ToolingReference/#overview","text":"This reference manual describes the configurations, files, and commands needed to create a FHIR IG from CIMPL ( C linical I nformation M odeling P rofiling L anguage). It assumes that the CIMPL Language files (classes, value sets, and maps) have been defined (see CIMPL Language Reference Manual for details). It also assumes that the CIMPL SHR-CLI tooling has been installed according to the directions in the Setup and Installation Guide . The CIMPL Tooling, also called SHR-CLI (Standard Health Record Command Line Interface), is the engine that imports a set of inputs, including CIMPL language files, and exports FHIR and other outputs, as shown below:","title":"Overview"},{"location":"cimpl6ToolingReference/#cimpl-tooling-overview","text":"","title":"CIMPL Tooling Overview"},{"location":"cimpl6ToolingReference/#inputs","text":"CIMPL Language files , including class files, value set files, and mapping files that define your clinical information model, A Configuration file that contains directives to the tooling, and points to other resources, An optional Content Profile file, which specifies Must-Support elements and profiling options specific to an IG, One or more Front Matter files, which are the narratives and graphics that introduce the IG, FHIR Examples that are to be included in the IG, and A Package List that has information required for building the IG.","title":"Inputs"},{"location":"cimpl6ToolingReference/#processing-sequence","text":"The user issues a build command through the command-line interface (CLI) to launch SHR-CLI. The CIMPL tooling imports definitions from CIMPL files (class, value set, and map files). SHR-CLI reports any errors in the CIMPL definitions. Continuing the build process, SHR-CLI selects a subset of the data models to include in the IG, according to the filter strategy . To complete the build process, SHR-CLI exports the selected CIMPL definitions into desired formats, such as FHIR profiles, data dictionaries, etc. The exports can be selected through command line options . The user issues a separate command to produce the IG.","title":"Processing Sequence"},{"location":"cimpl6ToolingReference/#outputs","text":"Depending on the configuration options selected, the SHR-CLI produces one or more of the following outputs: FHIR Profiles, Extensions, Value Sets that form the core content of the IG, A Logical Model corresponding to the CIMPL class definitions, expressed as FHIR StructureDefinitions, JSON Schema for the profiles defined by the IG, A Data Dictionary that lists the Must-Support data elements in the IG, as well as value sets and value set members, Model Documentation in the form of a Javadoc-like browser that allows one to see the hierarchical class relationships in the logical model.","title":"Outputs"},{"location":"cimpl6ToolingReference/#relationship-of-cimpl-models-and-implementation-guides","text":"It is important to understand the relationship between models defined in CIMPL and implementation guide(s) created from those models. The state-of-practice for FHIR IGs is still evolving, but currently, most IGs are developed by separate groups and define their own data models, as follows:","title":"Relationship of CIMPL Models and Implementation Guides"},{"location":"cimpl6ToolingReference/#typical-ig-data-model-relationship","text":"The drawback of this approach is that different IGs can require very similar data models. If different data models are developed by different teams, interoperability will suffer. In CIMPL, data models are independent of IGs. IGs are consumers of models, rather than owners of models (although new models can certainly be created in the context of IG development). Each IG uses a different subset of models, reflecting the different use cases they address, but the commonality of data models assures interoperability between the use cases. This idea is illustrated below:","title":"Typical IG-Data Model Relationship"},{"location":"cimpl6ToolingReference/#relationship-between-igs-and-data-models-in-cimpl","text":"Much of what is discussed subsequently reflects this conceptual picture of the relationship between CIMPL models and IGs.","title":"Relationship between IGs and Data Models in CIMPL"},{"location":"cimpl6ToolingReference/#suggested-directory-structure","text":"The SHR-CLI tooling does not require a particular directory structure. However, following conventions makes the process of managing the requisite files much easier. Here is an example of the suggested arrangement that assumes the same IG can be produced under FHIR STU3 and R4: \u251c\u2500\u2500 shr-cli-6.5.0 // Tooling location | ... | \u251c\u2500\u2500 spec // Main specification directory | \u251c\u2500\u2500 ns-namespace1 // Namespace directories | | \u251c\u2500\u2500 namespace1-foo.txt // class file(s) | | \u251c\u2500\u2500 namespace1-bar.txt | | \u251c\u2500\u2500 namespace1-foo-vs.txt // value set file(s) | | \u251c\u2500\u2500 namespace1-bar-vs.txt | | \u251c\u2500\u2500 namespace1-foo-map-stu3.txt // map(s) for FHIR STU3 | | \u251c\u2500\u2500 namespace1-bar-map-stu3.txt | | \u251c\u2500\u2500 namespace1-foo-map-r4.txt // map(s) for FHIR r4 | | \u2514\u2500\u2500 namespace1-bar-map-r4.txt | \u251c\u2500\u2500 ns-namespace2 | | ... | \u251c\u2500\u2500 ns-namespace3 | | ... | | ... | \u251c\u2500\u2500 ig-myguide1 // IG directories | | \u251c\u2500\u2500 myguide1-examples // directory of examples | | | \u251c\u2500\u2500 example1 | | | \u2514\u2500\u2500 example2 | | \u251c\u2500\u2500 myguide1-frontmatter // directory containing narratives | | | \u251c\u2500\u2500 index.html | | | \u251c\u2500\u2500 picture.png | | | \u2514\u2500\u2500 another-page.html | | \u251c\u2500\u2500 myguide1-stu3-cp.txt // content profile file for FHIR STU3 IG | | \u251c\u2500\u2500 myguide1-r4-cp.txt // content profile file for FHIR R4 IG | | \u251c\u2500\u2500 myguide1-stu3-plist.json // package list for FHIR STU3 IG | | \u251c\u2500\u2500 myguide1-r4-plist.json // package list for FHIR R4 IG | | \u251c\u2500\u2500 myguide1-stu3-config.json // config file for FHIR STU3 IG | | \u2514\u2500\u2500 myguide1-r4-config.json // config file for FHIR R4 IG | \u251c\u2500\u2500 ig-myguide2 | | ... In this reference guide, we will refer to several directories: Tooling Directory - this the directory where the SHR-CLI tooling has been installed. Any convenient directory can be used. For easy identification, we recommend the tooling version number be included in the directory name. Specification Directory - this is the top level directory where the input files and are located, usually arranged in sub-folders. Any convenient directory can be used. If you are using a source code control system such as Github to manage your development, this could be where the repository is checked out to your local machine. Namespace Directories - these directories, located under the Specification Directory, contains CIMPL language files for a single namespace. The name of the directory should be prefixed with ns- followed by the shortname or acronym of the namespace followed . IG Directories - these directories, under the specification directory contain files specific to a given implementation guide. There are subdirectories containing the front matter and examples, and individual configuration, content profile, and package list files. These files can be specific to a FHIR release, since the same IG could be created using different versions of FHIR. Note: There is currently no way to combine profiles for multiple FHIR versions in single IG.","title":"Suggested Directory Structure"},{"location":"cimpl6ToolingReference/#naming-conventions","text":"The naming of configuration, content profiles, and package list files is arbitrary, but it is useful for different teams to follow similar conventions. The suggested approach to naming uses variations on the same shortened IG name, as follows: Configuration file: ig-<guide-name>-config.json Content Profile file: ig-<guide-name>-cp.txt Package List file: ig-<guide-name>-plist.json If more than one FHIR version will be supported, the FHIR version should be included: Configuration file: ig-<guide-name>-<FHIR Version>-config.json Content Profile file: ig-<guide-name>-<FHIR Version>-cp.txt Package List file: ig-<guide-name>-<FHIR Version>-plist.json where FHIR version is dstu2, stu3, or r4.","title":"Naming Conventions"},{"location":"cimpl6ToolingReference/#configuration-file","text":"SHR-CLI requires a configuration file to run. The name of this file is typically specified on the command line using the -c command line option . If the name is not specified, the tooling looks for a file named config.json in the working directory. If that cannot be found, or the contents of the configuration file are invalid, an error message is returned. The configuration file is a JSON file with the following parameters: Parameter Type Description projectName string The full, official name of the project, for example \"HL7 FHIR Implementation Guide: minimal Common Oncology Data Elements (mCODE) Release 1 - US Realm, STU Ballot 1\" projectShorthand string A shorthand name for the project, such as \"mcode\". projectURL string The primary URL for the project, such as \"http://hl7.org/fhir/us/mcode/\" fhirURL string The FHIR IG URL for the project, often the same as the projectURL. (TO DO: clarify the difference between projectURL, fhirURL, and entryTypeURL) fhirTarget string The FHIR version this IG will be based on, currently a choice of \"FHIR_R4\" , \"FHIR_STU_3\" , or \"FHIR_DSTU_2\" entryTypeURL string The root URL for the JSON schema EntryType field. (TO DO: clarify where and how this is used) filterStrategy {} A JSON object containing configuration for filtering ( see below ). contentProfile string The file name of the content profile for the project. implementationGuide {} A JSON object containing configuration for IG publishing ( see below ). copyrightYear string The copyright year to include in the documentation. publisher string The name of the publisher for the project, which for HL7 projects, should be the sponsoring workgroup, for example, \"HL7 International Clinical Interoperability Council\". contact [] A JSON array containing HL7 FHIR R4 ContactPoint objects . provenanceInfo {} A JSON object specifying author and other information ( see below )","title":"Configuration File"},{"location":"cimpl6ToolingReference/#filter-strategy-configuration-parameters","text":"Between the import stage and the export stage, there is a filtering stage (see CIMPL Tooling Overview ). Filtering is useful when specification directory contains namespaces that or entries that are outside the scope of the current IG, and should not be included in the IG. Filtering removes unwanted namespaces and entries to limit the scope of the exports, and subsequently, the IG. The contents of the filterStrategy object are as follows: Parameter Type Description filter boolean A value indicating whether to enable filtering. If filter is true , then the filtering operation will occur. Otherwise, no filtering will occur. (Also, if the filterStrategy parameter is entirely omitted, no filtering will occur.) strategy string The strategy for specification filtering, either \"namespace\", \"element\", or \"hybrid\". target [] An array of strings containing the names of Entries, Namespaces, or both. The \"element\" strategy filters the imported classes to include each Entry listed in the target array, and their recursive dependencies. The \"namespace\" strategy filters the imported classes to include only Entries in the namespaces listed in the target array, and their recursive dependencies. The \"hybrid\" strategy filters the imported classes to include each Entry listed in the target array and all Entries in every namespace listed in the target array, and their recursive dependencies. When specifying an Entry in the target array, use the fully qualified name (FQN) format.","title":"Filter Strategy Configuration Parameters"},{"location":"cimpl6ToolingReference/#implementation-guide-configuration-parameters","text":"These configurations are used to control the production of the IG. The contents of the implementationGuide object are as follows: Parameter Type Description npmName string The assigned node package manager name for this IG, for example \"hl7.fhir.us.mcode\". The npm name is usually assigned by HL7. version string The version of this IG (not necessarily the version of FHIR), usually in the form major.minor.revision , for example, \"3.0.1\" ballotStatus string The HL7 ballot status of the IG (e.g., STU1 Ballot, Continuous Integration Build, etc.) packageList string The name of the file to use as the IG's package list , relative to the Specification Directory. includeLogicalModels boolean A \"true\" or \"false\" value indicating whether to include logical models in the IG. includeModelDoc boolean A \"true\" or \"false\" value indicating whether to include the model documentation in the IG. indexContent string The name of the file or folder containing the front matter , relative to the Specification Directory, for example, \"ig-mcode/IndexFolder-Oncocore\". If the indexContent is a folder, then it must contain an index.html file whose contents will be used as the body of the IG home page. extraResources string The name of the folder containing extra JSON resources to include in the IG, one file per resource. Currently, the following resource types are supported: SearchParameter , OperationDefinition , CapabilityStatement (STU3+), Conformance (DSTU2). If files are detected, links are added to the navigation menu as necessary. examples string The name of the folder containing examples (one example per file) to include in the IG, for example, \"ig-mcode/Examples-mCODE-r4\". We recommend the individual example file name match the id in the example file (with .json extension added). The example's meta.profile must match the canonical URL for the profile it exemplifies (e.g. \"meta\": { \"profile\": [ \"http://hl7.org/fhir/us/breastcancer/StructureDefinition/oncology-BreastCancerPresenceStatement\" ] } ). If no examples folder is specified, and a folder named \"fhir-examples\" exists in the specification directory, it will be used as the examples folder. historyLink string The URL for the page containing the IG's history information. (TO DO: clarify where and how this is used) changesLink string The URL to a site where users can request changes (shown in page footer) (TO DO: clarify where and how this is used) primarySelectionStrategy {} The strategy for selection of what is primary in the IG (see below). The primary selection strategy causes certain profiles to be displayed in a \"Primary\" section at the top list of profiles. All other exported profiles are listed in a \"Supporting\" section below the \"Primary\" section. The contents of the primarySelectionStrategy object are as follows: Parameter Type Description strategy string The strategy to follow for primary selection, either \"namespace\", \"hybrid\", or \"entry\" (default). primary [] An array of strings containing the namespaces and entries (only used for \"namespace\" and \"hybrid\" strategy). The strategy options are as follows: \"entry\" selects every exported profile as primary. \"namespace\" selects every profile found in the namespaces of the primary array as primary. \"hybrid\" selects every entry listed in the primary array or found in the namespaces in the primary array as primary. When specifying an Entry in the target array, use the fully qualified name (FQN) format.","title":"Implementation Guide Configuration Parameters"},{"location":"cimpl6ToolingReference/#provenance-information-configuration-parameters","text":"(TO DO: document what this structure can contain) Here is an example of provenanceInformation: \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" }","title":"Provenance Information Configuration Parameters"},{"location":"cimpl6ToolingReference/#front-matter-files","text":"Every IG contains some amount of narrative content, which we refer to as the \" front matter \". The front matter is typically a set of hyperlinked HTML files, graphics, and sometimes, downloads. These files are manually authored using any convenient tool; there are no special facilities in CIMPL to author the front matter. If multiple files are involved, they must be placed into a single folder, named in the indexContent parameter of the configuration file . This folder must contain a file named index.html whose contents will be used as the body of the IG home page (the header and footer of the pages are automatically generated). If a single file is used, the file should be named in the indexContent parameter of the configuration file, and a folder is not required.","title":"Front Matter Files"},{"location":"cimpl6ToolingReference/#fhir-examples","text":"Configuring FHIR examples to appear in the generated IG involves the following steps: Create a folder which will contain your FHIR examples Modify the CIMPL configuration file to specify the folder containing your examples The name of the folder is arbitrary, however, following directory structure and naming conventions is recommended. The folder location is specified using the \"examples:\" parameter in the CIMPL configuration file. This is illustrated below:","title":"FHIR Examples"},{"location":"cimpl6ToolingReference/#configuration-for-fhir-examples","text":"","title":"Configuration for FHIR Examples"},{"location":"cimpl6ToolingReference/#package-list-file","text":"The format and content of this file follows the FHIR specification for package lists . The package list is required for IGs published by HL7. The file containing the package list is named by the packageList parameter of the configuration file . If the packageList parameter is not supplied and no file is found at the default location (packageList.json), and fhirURL is an hl7.org or fhir.org URL (indicating it is an HL7 publication), then a basic package list file will be created. In this case, the IG author should review and modify the file as needed. Here is an example of a package list file: { \"package-id\": \"hl7.fhir.us.mcode\", \"title\": \"HL7 FHIR Implementation Guide: minimal Common Oncology Data Elements (mCODE) Release 1 - US Realm | STU Ballot 1\", \"canonical\": \"http://hl7.org/fhir/us/mcode\", \"list\": [ { \"version\": \"current\", \"desc\": \"Continuous Integration Build (latest in version control)\", \"path\": \"https://build.fhir.org/ig/HL7/fhir-mCODE-ig\", \"status\": \"ci-build\", \"current\": true }, { \"version\": \"0.9.1\", \"date\": \"2019-06-10\", \"desc\": \"Initial version\", \"path\": \"http://hl7.org/fhir/us/mcode/2019Sep\", \"status\": \"draft\", \"sequence\": \"STU 1\", \"fhir-version\": \"4.0.0\" } ] }","title":"Package List File"},{"location":"cimpl6ToolingReference/#content-profile-file","text":"In FHIR, Must-Support is a boolean flag which allows a profile to indicate that an implementation must be able to process that element in a FHIR instance if it exists. The Content Profile is where Must-Support elements are declared. Note that the Must-Supports are designated at the level of the IG, not the data model. This is because different elements are important for different use cases. For example, one use case may not require date of death to be supported, but another might. Note: Filtering is the mechanism by which entries (profiles) and namespaces are selected for an IG, and content profiles are the mechanism for declaring Must-Support. The syntax of a Content Profile file is: Grammar: ContentProfile 1.0 Namespace: <namespace-1> <Entry-1>: <Element-1> MS <Element-2> MS ... <Entry-2>: ... Namespace: <namespace-2> <Entry-1>: <Element-1> MS <Element-2> MS ... <Entry-2>: ... Here is an excerpt from a Content Profile file: Grammar: ContentProfile 1.0 Namespace: obf ComorbidCondition: Code MS ClinicalStatus MS MedicationStatement: MedicationCodeOrReference MS OccurrenceTimeOrPeriod MS TerminationReason MS TreatmentIntent MS ECOGPerformanceStatus: DataValue MS Namespace: vital BloodPressure: Components.ObservationComponent MS RelevantTime MS BodyHeight: DataValue MS RelevantTime MS BodyWeight: DataValue MS RelevantTime MS Namespace: onco.core PrimaryCancerCondition: Code MS ClinicalStatus MS BodyLocation.Code MS HistologyMorphologyBehavior MS DateOfDiagnosis MS Note: The grammar of the Content Profile file is still evolving and may include additional information in the future.","title":"Content Profile File"},{"location":"cimpl6ToolingReference/#executing-shr-cli","text":"The general form of the SHR-CLI execution command is as follows (where $ stands for the command prompt, which could be different on your system): $ node <tooling-directory> <specification-directory> [options] where options include: -c, --config <config> the name of the config file (default: config.json) -l, --log-level <level> the console log level <fatal, error, warn, info, debug, trace> (default: info) -s, --skip <feature> skip an export feature <fhir, json-schema, model-doc, data-dict, all> (default: <none>) -o, --out <out> the path to the output folder (default: out) -m, --log-mode <mode> the console log mode <short,long,json,off> (default: short) -d, --duplicate show duplicate error messages (default: false) -j, --export-es6 export ES6 JavaScript classes (experimental, default: false) -n, --clean Save archive of old output directory and perform clean build (default: false) -h, --help output usage information The options are not order-sensitive. Here is an example of a SHR-CLI command and an explanation of its parts: $ node . ../shr_spec/spec -c ig-mcode/ig-mcode-r4-config.json -l error node is the command that starts the SHR-CLI application. The dot . represents the current directory in Windows and macOS. In this example, the tooling directory is the current working directory. ../shr_spec/spec represents the location of the specification directory. The the double dot .. represents the directory above the current working directory, in Windows and macOS. In this case, /shr_spec is parallel to the tooling directory, and /spec is one level below that. -c ig-mcode/ig-mcode-r4-config.json directs the execution engine to the configuration file. Note that the configuration file location is relative to the specification directory, implying the full path to the configuration is ../shr_spec/spec/ig-mcode/ig-mcode-r4-config.json -l error is an option that sets tells the system to surpress any messages that don't rise to the level of an error . This reduces the amount of output to the console window.","title":"Executing SHR-CLI"},{"location":"cimpl6ToolingReference/#addressing-error-messages","text":"In the process of building a model, it is inevitable that you will encounter error messages from SHR-CLI. Debugging the model is an iterative process, and it could take some perseverance to arrive at a \"clean\" run of SHR-CLI with no errors. This is an expected part of the process. A detailed list of CIMPL compilation errors and troubleshooting suggestions are available in Appendix A . Here are some general tips on approaching debugging your model: Always eliminate parsing errors first. Parsing errors can be identified because they include a file, line number, and column number. It is essential to elminate parsing errors first, because parsing errors usually trigger large cascades of other errors, so you can't truly start debugging your model until parsing errors have been eliminated. Once all parsing errors have been eliminated, start working top down on the first (or first few) errors. Often, subsequent errors are a consequence of the first error. Don't be discouraged by the number of errors, since a single correction can silence multiple logged errors. Read the error messages carefully. Although the messages might be cryptic, especially at first, the names of classes and paths are often excellent clues.","title":"Addressing Error Messages"},{"location":"cimpl6ToolingReference/#outputs-from-shr-cli","text":"The output of running SHR-CLI appear in a directory named \"out\". By default, the /out directory is created in the tooling directory. A different location can be designated using the -o command line option . The content of the /out directory depends on which exporters were selected to run, which is controlled using the -s command line option. By default, the /out will contain five exports, as shown below, each corresponding to a separate export process:","title":"Outputs from SHR-CLI"},{"location":"cimpl6ToolingReference/#typical-contents-of-the-out-directory","text":"cimcore - this directory is used in the process of building the \"modeldoc\" export, and is not discussed further data-dictionary - this directory contains an MS-Excel spreadsheet containing a list of model elements and value sets fhir - this directory contains all the definitions and assets necessary to produce the IG json-schema - this directory contains schemas for the ( TO DO -- need to define the JSON schema export ) modeldoc - this directory contains files that present the model with a look and feel similar to Javadoc","title":"Typical Contents of the /out Directory"},{"location":"cimpl6ToolingReference/#fhir-export","text":"The FHIR export consists of profiles, extensions, value sets, code systems, examples, and other artifacts needed to create a FHIR IG. These are not the pages of the IG, but rather various definitions that underlie the IG presentation. You must run the IG publisher to create the IG itself. The FHIR export appears in the /fhir subdirectory under the designated \"out\" directory. The directory contains further subdirectories for code systems, extensions, the IG (guide), the logical model (logical), profiles, and value sets.","title":"FHIR Export"},{"location":"cimpl6ToolingReference/#logical-model-export","text":"The logical model is an alternative representation of the CIMPL model, expressed in a familiar FHIR-like format. The logical model closely follows the CIMPL definitions because it reflects the model prior to mapping to FHIR resources. Each entry is presented as if it were a new FHIR resource, rather than a profile. The logical model is formally expressed as a set of FHIR StructureDefinitions . These definitions are distinguished from profiles because the names generated by the tooling end in -model . Because the logical model does not entail the additional complication of mapping, it is useful for review purposes. The logical model can be checked for clinical relevance and sufficiency before making mapping decisions. An optional part of the FHIR export, the logical model can be turned on or off using the includeLogicalModels flag in the configuration file.","title":"Logical Model Export"},{"location":"cimpl6ToolingReference/#logical-model-example","text":"","title":"Logical Model Example"},{"location":"cimpl6ToolingReference/#model-documentation-export","text":"The model documentation provides another way to view the logical model. This view emphasizes the class hierarchy defined in CIMPL, the datatypes, associated constraints, and relationships between the classes (references). The panel in the upper left allows the user to filter on the namespace and (in SHR-CLI 6.6 and higher) the class type (Entry, Group, or Element). The right-hand panel shows details for the selected class, include the full set of properties and constraints. For many users, especially those with experience in object-oriented modeling, the model documentation is the quickest way to navigate around the model.","title":"Model Documentation Export"},{"location":"cimpl6ToolingReference/#model-documentation-example","text":"","title":"Model Documentation Example"},{"location":"cimpl6ToolingReference/#data-dictionary-export","text":"The Data Dictionary is an Microsoft Excel file containing a simplified, flattened list of model elements and value sets, extracted from the FHIR profiles. The spreadsheet has five tabs: The \"Key\" tab contains a key to the columns in the other tabs; The \"Profiles\" tab contains a list of the primary profiles and their descriptions; The \"Data Elements\" tab contains a list of Must-support and required elements associated with those profiles; The \"Value Sets\" tab contains a list of value sets used in the IG, and their descriptions; The \"Value Set Details\" tab contains a list of the codes and/or implicit definitions in those value sets. The Data Dictionary can be useful both to clinicians and implementers who don't need the structural details of the FHIR profiles, but want the contents in list form. For many reviewers and contributors, this can be an easy-to-use format to facilitate discussion and feedback.","title":"Data Dictionary Export"},{"location":"cimpl6ToolingReference/#json-schema-export","text":"( TO DO: determine what to say here )","title":"JSON Schema Export"},{"location":"cimpl6ToolingReference/#creating-the-implementation-guide","text":"The final step in the IG creation process is to run the FHIR IG Publisher . This tool is maintained and owned by HL7 FHIR. Open a command prompt, change directories to the tooling directory, and use one of these two options: If you used the default \"out\" directory when running SHR-CLI: $ yarn run ig:publish If you used a different \"out\" directory: $ java -Xms4g -Xmx8g -jar /your/out/directory/fhir/guide/org.hl7.fhir.publisher.jar -ig /your/out/directory/fhir/guide/ig.json Note: The IG publisher can take 15-30 minutes or even longer to run, depending on the size of the IG, and it takes lots of memory. The yarn script above will allocate up to 8GB of RAM. A minimum of 4GB of RAM is recommended to run the IG Publisher tool. When the publisher finishes, the IG can be opened by running the following commands. If you used default \"out\" directory: $ yarn run ig:open If you used a different \"out\" directory, by manually opening the file: $ /your/out/directory/fhir/guide/output/index.html You now have your completed IG. The FHIR IG Publisher performs numerous validation checks on the content of the IG. The output of these checks can be accessed through the \"QA Report\" link in the footer of the home page, or by opening the file /out/fhir/guide/output/qa.html . An example QA output is shown below:","title":"Creating the Implementation Guide"},{"location":"cimpl6ToolingReference/#appendix-a-error-messages","text":"In the following, $ prefix indicates a variable that will be filled in with specific information.","title":"Appendix A: Error Messages"},{"location":"cimpl6ToolingReference/#table-of-contents","text":"Error Code Structure Parsing Errors Warning Codes Compilation Error Codes Mapping Error Codes","title":"Table of Contents"},{"location":"cimpl6ToolingReference/#error-code-structure","text":"CIMPL Compilation Errors are structured in the following format: 1 2 3 4 5 \u21b3 First digit tells whether it is an warning or error. 0 = warning, 1 = error 1 2 3 4 5 \u21b3 Second digit indicates the phase of processing where the error appeared: 1 = grammar and importing of the text files, 2 = logical verification of the model, 3 = exporting of FHIR profiles, 4 = exporting of the JSON profiles 1 2 3 4 5 \u21b3 The last three digits are for unique identification and have no particular meaning.","title":"Error Code Structure"},{"location":"cimpl6ToolingReference/#parsing-errors","text":"Parsing errors are generated when the importer cannot make sense of the contents of a CIMPL statement. Parsing error messages include the file, line, and column number, and can be linked directly to a location in a CIMPL file where parsing failed. Most other types of errors (with the exception of mapping errors) cannot be linked to a specific file location because they represent some type of a logical inconsistency. A typical parsing error looks like this: extraneous input 'Entry' expecting {<EOF>, 'CodeSystem:', 'Abstract:', 'Element:', 'Entry:', 'Group:'}. ERROR_CODE:11023 (module=shr-text-input, file=..\\shr_spec\\spec\\ns-onco-core\\oncocore.txt, line=9, column=0) When a parsing error occurs, the associated error code number and subsequent errors are not meaningful, since the entire model could not be read.","title":"Parsing Errors"},{"location":"cimpl6ToolingReference/#warning-codes","text":"Warning Code Warning Message Potential Solution 01001 No project configuration file found, currently using default EXAMPLE identifiers. Auto-generating a proper 'config.json' in your specifications folder Open the 'config.json' file and customize it for your project. 01002 Config file missing key: $KEY , using default key: $DEFAULT VALUE instead. Open the 'config.json' file and add your project specific details for that key. 02001 Potentially mismatched targets: $CLASS maps to $ITEM , but based on class ( $CLASS ) maps to $ITEM , and $ITEM is not based on $ELEMENT in $CLASS .' You are overriding an inherited mapping. 03001 Trying to map $PROFILE to $CODE , but $PROFILE was previously mapped to it 03002 Choice has equivalent types, so choice options may overwrite or override each other when mapped to FHIR. 03003 Overriding extensible value set constraint from $VS1 to $VS2 . Only allowed when new codes do not overlap meaning of old codes. The \"extensible\" binding means that a code from outside the given value set should be used only if the value set does not contain a suitable code. 03004 Element profiled on Basic. Consider a more specific mapping. The Basic profile should not be used in most cases. Consider a more specific profile mapping that categorizes the Element being mapped. 03005 No mapping to ' $ELEMENT PATH '. This property is core to the target resource and usually should be mapped. 03006 The $PROPERTY property is not bound to a value set, fixed to a code, or fixed to a quantity unit. This property is core to the target resource and usually should be constrained Usually a result of not setting the Code attribute of an Observation. 04001 Unsupported code system: ' $CODESYSTEM '","title":"Warning Codes"},{"location":"cimpl6ToolingReference/#compilation-error-codes","text":"Error Code Error Message Solution 11001 Element name ' $NAME ' should begin with a capital letter Rename the specified Element 11002 Entry name ' $NAME ' should begin with a capital letter Rename the specified Entry 11003 Unable to resolve value set reference: $VALUESET Invalid value set reference, double check the name and the path 11004 Unsupported binding strength: $BINDING_STRENGTH . Defaulting to REQUIRED Binding strength has to be one of the following: example, preferred, extensible, or required (default). 11005 Error parsing source path: $PATH Invalid path to definitions. Double check path. 11006 Invalid config file. Should be valid JSON dictionary Make sure your 'config.json' file is using a valid format for JSON. 11007 Unsupported grammar version: $VERSION Grammar Version for file must be 5.0 (or above) 11008 Defining value sets by URL has been deprecated in ValueSet files. ValueSet $VALUESET ignored. Define the value set with a name using proper syntax. 11009 Defining value sets by URN has been deprecated in ValueSet files. ValueSet $VALUESET ignored. Define the value set with a name using proper syntax. 11010 Couldn\u2019t resolve code system for alias: $ALIAS Invalid Codesystem, double check spelling 11011 Uses statements have been deprecated in ValueSet files. Uses statement ignored. Uses statement is unnecessary. Refer to documentation for proper syntax 11012 Only default path definitions are allowed in ValueSet files. Path definition ignored. Use one of the preset path definitions defined in the documentation. 11013 Failed to resolve definition for $ELEMENT_NAME The referenced Element doesn't exist in the current namespace, or in any of its inherited parents. Check spelling errors as well as imports. 11013 Failed to resolve definition for primitive Only certain primitives are supported. Please refer to the documentation to see the full list. 11015 token recognition error at: $CHARACTER This is usually a typo issue. Investigate keywords and missing colons around the specificed text input. 11016 mismatched input $INPUT expecting $LIST_OF_KEYWORDS This is usually a typo issue. Investigate spelling and keywords used around the specificied text input. 11017 Cannot resolve path without namespaces There was a failure to parse the namespace. Ensure the namespace is correctly defined. 11018 Failed to resolve path for $NAME . 11019 Found conflicting path for $NAME in multiple namespaces: $NAMESPACES 11020 Failed to resolve vocabulary for $NAME . 11021 Found conflicting vocabularies for $NAME in multiple namespaces: $NAMESPACES 11022 Found conflicting definitions for $NAME in multiple namespaces: $NAMESPACES 11023 Elements cannot be based on \"Value\" keyword 11024 Elements cannot use \"Value:\" modifier and specify \"Value\" field at same time. 11025 Fields cannot be constrained to type \"Value\" 11026 ref(Value) is an unsupported construct; treating as Value without the reference. 11027 Unable to import property $FQN , unknown value type: $VALUE_TYPE The type either does not exist, or the import tool needs to be updated. 11028 Unable to import unknown constraint type: $CONSTRAINT_TYPE The type either does not exist, or the import tool needs to be updated. 11029 Unable to import mapping, unknown rule type: $RULE_TYPE The type either does not exist, or the import tool needs to be updated. 11030 Unable to import VS rule, unknown rule type: $RULE_TYPE The type either does not exist, or the import tool needs to be updated. 11031 Unable to import FixedValueConstraint, unknown fixed value type: $RULE_TYPE The value type either does not exist, or the import tool needs to be updated. 11032 Project configuration not found! Exiting the program. There was an error finding or loading the configuration file. Please double check that it exists and is valid. 11033 Name $ELEMENT_ENTRY_NAME already exists. The entity or element name already exists within the namespace and the most recently defined element or entry name will be used. 11034 ValueSet name $VS_NAME already exists. The value set name already exists within the namespace. 11035 Definition not found for data element in content profile path: $ELEMENT_FQN . Could indicate a missing definition, misspelling, or missing Uses declaration. 11036 Path not found for $ELEMENT_FQN : $PATH . Usually when sub-elements in a dotted path (foo.bar.baz) can't be traced. See CIMPL path for more information. 11037 Could not find content profile file: $FILE_NAME . Check the name or path to the content profile file specified in your configuration file. 11038 Namespace declaration not found. File needs a namespace declaration at the top of the file under the Grammar declaration. 11039 Grammar declaration not found. File needs a Grammar declaration at the top of the file. 11040 Property $PROPERTY already exists. Extra declaration of Property needs to be removed. 11041 Choice value constrained without specifying the specific choice. 11042 Constraint refers to previous identifier. 11043 Value should not be declaring cardinality. Remove cardinality declared for the value. 11044 Missing a value element. 12001 Cannot resolve element definition. Element doesn't exist. Double check spelling and inheritance 12002 Reference to non-existing base: $ELEMENT_NAME Base doesn't exist. Double check spelling and inheritance. 12003 No cardinality found for value: $VALUE Explicitly define cardinality for that value. 12004 No cardinality found for field: $FIELD Explicity define cardinality for that field. 12005 Cannot override $OLD_VALUE with $NEW_VALUE Double check types match. 12006 Cannot override $OLD_VALUE with $NEW_VALUE since it is not one of the options Verify Identifiers match. 12007 Cannot override $OLD_VALUE with $NEW_VALUE Verify Identifiers match. 12008 Cannot override $OLD_VALUE with $NEW_VALUE since overriding ChoiceValue is not supported Verify Identifiers match. 12009 Unsupported constraint type: $CONSTRAINT Invalid constraint syntax. Consult documentation to see what constraints are supported 12010 Cannot constrain cardinality of $NAME from $SMALL_CARDINALITY to $BIGGER_CARDINALITY You can only narrow the cardinality. You cannot constrain it to have a larger range than its parent 12011 Cannot further constrain cardinality of $NAME from $CARDINALITY to $CARDINALITY You can only narrow the cardinality. You cannot constrain it to have a larger range than its parent 12012 Cannot constrain type of $NAME to $TYPE Make sure base types match 12013 Cannot constrain type of $NAME since it has no identifier Invalid Element 12014 Cannot constrain type of $NAME to $TYPE Make sure base types match 12015 Cannot further constrain type of $NAME from $TYPE to $TYPE The two elements aren't based on the same parent. You cannot constrain an element to one that is completely distinct. 12017 Cannot constrain type of $NAME since it has no identifier 12018 Cannot constrain element $NAME to $TARGET since it is an invalid sub-type Element has to be based on $s or otherwise is a child of $s . 12020 Cardinality of $NAME not found Please explicitly define the cardinality. 12021 Cannot include cardinality on $NAME , cardinality of $CARD doesnt fit within $CARD The cardinality of included parameters must be as narrow or narrower than the property it contains. 12022 Cannot constrain valueset of $NAME since it has no identifier 12023 Cannot constrain valueset of $NAME since neither it nor its value is a code, Coding, or CodeableConcept ? 12024 Cannot constrain valueset of $NAME since it is already constrained to a single code ? 12025 Cannot constrain code of $NAME since neither it nor its value is a code, based on a Coding, or based on CodeableConcept ? 12026 Cannot constrain included code of $NAME since neither it nor its value is a code, based on a Coding, or based on CodeableConcept ? 12027 Cannot constrain boolean value of $NAME since neither it nor its value is a boolean ? 12028 Cannot constrain boolean value of $NAME to $VALUE since a previous constraint constrains it to $VALUE ? 12029 Cannot resolve element definition for $NAME This is due to a incomplete definition for an element. Please refer to the document for proper definition syntax. 12030 Cannot determine target item System error. 12031 Cannot resolve data element definition from path: $PATH Check spelling for field or value. 12032 Cannot resolve data element definition from path: $PATH Check spelling for field or value. 12033 Cannot map Value since element does not define a value Define a value for your element 12034 Cannot map Value since it is unsupported type: $VALUE_TYPE ? 12035 Found multiple matches for field $FIELD Please use fully qualified identifier. 12036 Could not find expanded definition of $ELEMENT . Inheritance calculations will be incomplete. Double check shr.base.Entry is defined within the specifications. 12037 Could not find based on element $ELEMENT for child element $ELEMENT . Double check the basedOn element is defined within the specifications and correctly referenced. 14001 Unsupported value set rule type: $s 14002 Unknown type for value $VALUE 14003 Unknown type for constraint $CONSTRAINT","title":"Compilation Error Codes"},{"location":"cimpl6ToolingReference/#mapping-error-codes","text":"Error Code Error Message Solution 13001 Invalid FHIR target: $TARGET Could not find the FHIR resource or profile you're trying to map to. Check spelling and FHIR version. 13002 Cannot flag path as mapped 13003 Slicing on include type constraints with paths is not supported 13004 Slicing required to disambiguate multiple mappings to $TARGET 13005 Invalid source path 13006 Invalid or unsupported target path 13007 Cannot unroll contentReference $CONTENT_REFERENCE on $ELEMENT because it is not a local reference 13008 Invalid content reference on $ELEMENT : $CONTENT_REFERENCE 13009 Cannot unroll $ELEMENT . Create an explicit choice element first. 13010 Cannot unroll $ELEMENT at $ELEMENT : invalid SHR element. 13011 Cannot make choice element explicit since it is not a choice ([x]): $ELEMENT 13012 Cannot make choice element explicit at $ELEMENT . Invalid SHR identifier: $IDENTIFIER . 13013 Invalid target path. Cannot apply cardinality constraint. 13014 Cannot constrain cardinality from $CARD to $CARD 13015 Invalid target path. Cannot apply fixed value. 13016 Currently, only fixing codes is supported (value must contain \"#\"). Unable to fix to $VALUE . 13017 Incompatible cardinality (using aggregation). Source cardinality $CARD does not fit in target cardinality 13018 Cannot constrain cardinality to $CARD because cardinality placement is ambiguous. Explicitly constrain parent elements in target path. 13019 Cannot constrain cardinality to $CARD because there is no tail cardinality min that can get us there 13020 Cannot constrain cardinality to $CARD because there is no tail cardinality max that can get us there 13021 Cannot constrain cardinality to $CARD because there is no tail cardinality that can get us there 13022 Mismatched types. Cannot map $SOURCE_VALUE to $MAPPING . Find the EntryElement referenced in the error details and change it to match the data type of the target field. 13023 Cannot resolve element definition for $ELEMENT 13024 Failed to resolve element path from $ELEMENT to $PATH 13025 Applying constraints to profiled children not yet supported. SHR doesn\\ 13026 Failed to resolve path from $ELEMENT to $PATH 13027 Unsupported binding strength: $BINDING_STRENGTH 13028 Cannot change binding strength from $BINDING_STRENGTH to $BINDING_STRENGTH 13029 Cannot override value set constraint from $URI to $URI 13030 Found more than one value set to apply to $ELEMENT . This should never happen and is probably a bug in the tool. 13031 Found more than one code to fix on $ELEMENT . This should never happen and is probably a bug in the tool. 13032 Can\u2019t fix code on $ELEMENT because source value isn\u2019t code-like. This should never happen and is probably a bug in the tool. 13033 Can\u2019t fix code on $ELEMENT because source value isn\u2019t code-like. This should never happen and is probably a bug in the tool. 13034 Cannot override code constraint from $VALUE to $VALUE 13035 Cannot override boolean constraint from $VALUE to $VALUE 13036 Found more than one boolean to fix on $ELEMENT . This should never happen and is probably a bug in the tool. 13037 Conversion from $VALUE to one of $TYPE drops boolean constraints 13038 Conversion from $VALUE to one of $TYPE drops value set constraints 13039 Conversion from $VALUE to one of $TYPE drops code constraints 13040 Conversion from $VALUE to one of $TYPE drops includesCode constraints 13041 Unable to establish namespace for $ELEMENT 13042 No slice name supplied for target. This should never happen and is probably a bug in the tool. 13043 Couldn\u2019t find target in slice $SLICE (Exporting) 13044 Target resolves to multiple elements but is not sliced 13045 Unable to establish namespace for $FIELD (Extensions) 13046 Mapping to MAP_TARGET 's RULE_TARGET : slice could not be found. 13047 Couldn't find sd to unroll 13048 Cannot override code constraint from $SYSTEM | $CODE to $SYSTEM | $CODE ' 13049 Unexpected error processing mapping to FHIR. 13050 Unexpected error processing mapping rule. 13051 Unexpected error adding extension. 13054 Using profile that is currently in the middle of processing: $PROFILE_ID . 13055 Using extension that is currently in the middle of processing: $EXTENSION_ID . 13056 Can't fix $TARGET to $VALUE since $TARGET is not one of: $ALLOWABLE_TYPES . 13057 Could not fix $TARGET to $VALUE ; failed to detect compatible type for value $VALUE . 13058 Cannot fix $TARGET to $VALUE since it is not a $TYPE type. 13059 Cannot fix $TARGET to $VALUE since it is already fixed to $OTHER_VALUE . 13060 Could not determine how to map nested value ( $ELEMENT_PATH ) to FHIR profile. Occurs on the FHIR profile export when there are multiple levels of reference specified. e.g.: LaboratoryObservationTopic.Specimen.CollectionSite within LaboratoryObservationTopic. Resolved by creating a reference in the cimi entity to FHIR map in cimi_entity_map.txt. 13061 Mapping $ELEMENT sub-fields is currently not supported. 13062 Cannot make choice element explicit at $ELEMENT . Could not find compatible type match for: $TYPE . 13063 Could not find FHIR element with path $ELEMENT_PATH for content profile rule with path $RULE_PATH . 13064 Could not find FHIR element for content profile rule with path $RULE_PATH . 13065 Could not find FHIR element subextension for content profile rule with path $RULE_PATH .","title":"Mapping Error Codes"},{"location":"cimpl6Tutorial_detail/","text":"CIMPL 6.0 In-depth Tutorial This is an extensive tutorial, meant to educate people about many different aspects of CIMPL. If you're looking for a quick introduction to CIMPL and SHR-CLI environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Language Reference documentation . Table Of Contents CIMPL 6.0 In-depth Tutorial Pre-requisite Tutorial Pre-configuration Introduction Define Use Cases Create a High-level Conceptual Model Create a List of Data Elements Create the Logical Model in CIMPL Creating Custom Value Sets Create Logical Model to FHIR mappings Generate the FHIR IG Specify the FHIR \"Must-Support\" elements Create a Homepage for the IG Configuring your output Running scripts to compile CIMPL and IG Generation Create FHIR examples Pre-requisite This tutorial assumes that you already have the following software components installed: CIMPL SHR-CLI (preferably installed in the ~/cimpl/shr-cli directory) A text-editor (preferably VSCode with the vs-code-language-cimpl extension, but not required) Note: This tutorial was run using a MacOS environment. While the content of CIMPL authoring are identical regardless of platform, the command lines run in a command line terminal will differ in file path specifications. Namely, for a Windows command line terminal, replace all the path references of forward-slash / to back-slash \\ . Tutorial Pre-configuration To keep this tutorial more focused on how to model, we're first going to setup the environment with some supporting configuration and core data type files. We're also going to assume the following directory structure for your configuration: Directory: cimpl |_ shr-cli Note: Your top level directory where SHR-CLI was installed might differ. If so, then you'll be instead referencing the relative directory where you have installed shr-cli. Create a sub-directory under cimpl called myExampleC6 Now your directory structure should look like this: Directory: cimpl |_ shr-cli |_ myExampleC6 Copy the following files to the myExampleC6 sub-directory. The files contain global definitions for Code Systems, Value Sets, maps to FHIR R4 elements and examples. These file names are hyperlinked for retrieval: shr_core_datatype.txt shr_core_datatype_vs.txt shr_core_datatype_map_r4.txt ig-myExampleR4-config.json Introduction This tutorial will guide the user in a step by step process to build a basic clinical data model using the \"Clean Slate\" method of CIMPL authoring. It will also illustrate the modeling practice briefly described in Appendix A of the CIMPL Authoring Guide . The steps are briefly summarized here for conciseness: Define use case(s) Create a high-level conceptual model Create a data element requirement list Create the logical model Create logical element-to-FHIR mappings Generate the FHIR Implementation Guide Create FHIR examples for each profile (optional) Define Use Cases For our example, we'll focus on obstructive sleep apnea (OSA) . The goal is to measure the prevalence of patients diagnosed with OSA, stratified by age groups. A secondary goal is to further identify the population by gender. Electronic Health Records (EHRs) are the primary source for this information. Create a High-level Conceptual Model A conceptual diagram is shown in the figure below: While this case is very simple, diagrams of this sort are valuable to the non-technical community, and to drive further design of the model. Create a List of Data Elements Creating a list of data elements helps to refine the contents, data types, cardinality, and clinical terminologies needed in the model. It helps at this stage to research existing standards and related models, but for this example, we won't look beyond FHIR resources for inspiration. The table below is a high level summary of the elements we need in this use case: Entity Data Element Name Cardinality Data type Value Set (if applicable) Patient BirthDate 1..1 date Patient Gender 0..1 concept HL7 Gender OSADisorder OSADisorderCode concept SNOMED codes for OSA OSADisorder OSADisorderStatus concept HL7 status codes Create the Logical Model in CIMPL Now we can start authoring models in the CIMPL development environment. In this example, we are using the \"clean slate\" method of defining our logical model elements without using the pre-existing \"Objective FHIR\" class library. CIMPL has three main files involved in the creation of a logical model - one of each for every CIMPL project. We list them here for brevity, but reference the CIMPL 6 Reference Guide for further details on each: Class file Value Set file Map file The class file is the place to start. Create a new file under the myExampleC6 subdirectory called myExample.txt . Type in the CIMPL header information designating the namespace and version of the DataElement parser: Grammar: DataElement 6.0 Namespace: myExample Description: \"CIMPL Tutorial: myExample for an OSA patient.\" Uses: shr.core Where: Grammar is a required keyword indicating the parser to be used, in this case DataElement 6.0 Namespace , also required, is a short name for your project, implementation guide, or module you are defining. Uses is the list of all namespaces which your model elements will reference. For our example, we fix this to shr.core . Next, we will create our first profile called MyPatient which we determined will also have the following properties: MyBirthDate (a required field which only accepts one value) MyGender (an optional field that we want to have the receive accept if it so happens to have a value sent in any FHIR instance.) Let's build our Patient logical model. Add the following lines below your CIMPL header. Entry: MyPatient Description: \"An individual awaiting or under medical care and treatment. (source: Webster's Dictionary)\" Property: MyBirthDate 1..1 Property: MyGender 0..1 Element: MyBirthDate Description: \"The date when the patient was born.\" Value: date Element: MyGender Description: \"Either of the two sexes (male and female), especially when considered with reference to social and cultural differences rather than biological ones. (source: Oxford Dictionary)\" Value: concept from http://hl7.org/fhir/ValueSet/administrative-gender What we just represented here is that there is a Patient entity called MyPatient which has 2 properties: MyBirthdate and MyGender . Never mind that FHIR Patient has these attributes -- this won't always be the case. We determined from our clinical requirements that MyBirthDate has a data type of date , which is one of the primitive data types supported in CIMPL. We also determined that MyGender is a value set that can be male , female , or unknown . For the sake of simplicity, we find that HL7 has a matching value set identical to our requirements so we'll use that one for its value. Now let's work on the OSA Disorder entity. Add the following text into the file: Entry: ObstructiveSleepApneaDisorder Description: \"Obstructive sleep apnea (OSA) is a sleep-related breathing disorder that involves a decrease or complete halt in airflow despite an ongoing effort to breathe. It occurs when the muscles relax during sleep, causing soft tissue in the back of the throat to collapse and block the upper airway. (source: American Academy of Sleep Medicine)\" Property: OSADisorderCode 1..1 Property: OSACurrentStatus 0..1 Element: OSADisorderCode Description: \"The diagnosis or problem list code assigned to the OSA disorder.\" Value: concept from OSADisorderVS Element: OSACurrentStatus Description: \"State of the diagnosis or problem list item.\" Value: concept from OSACurrentStatusVS Here we specify the entity called ObstructiveSleepApneaDisorder containing two properties to define the disorder code and current status. Both properties have been defined as concepts which reference value sets that need to be defined. Again, don't be concerned that this seems to replicate the elements of FHIR Condition; many logical models will have elements with no analogy in FHIR. Creating Custom Value Sets Create a new file called myExample_vs.txt underneath the myExampleC6 directory. Add the CIMPL value set header information below: Grammar: ValueSet 5.1 Namespace: myExample Where: Grammar is the keyword which specifies that the file created is a value set file conforming to CIMPL value set parser version 5.1. Namespace is the keyword whose value contains the namespace defined for your model. In this case, it's myExample . Next we specify the terms in the value set which we've defined in our clinical data requirements. Add the following text below the CIMPL value set header information: CodeSystem: SCT = http://snomed.info/sct CodeSystem: STAT = http://terminology.hl7.org/CodeSystem/condition-clinical ValueSet: OSADisorderVS Description: \"The list of disorders related to Obstructive Sleep Apnea.\" SCT#1101000119103 \"Obstructive sleep apnea of adult (disorder)\" SCT#1091000119108 \"Obstructive sleep apnea of child (disorder)\" ValueSet: OSACurrentStatusVS Description: \"The current disease status of an OSA patient\" STAT#active \"Active\" STAT#inactive \"Inactive\" STAT#resolved \"Resolved\" Here we have defined the terminology coding system reference by the value set, specified using the CodeSystem: keyword up front. This allows us to tag a short-hand notation of the coding system to the code for each term in the value set. It also allows for the flexibility of specifying terms with different coding systems within a value set, if applicable. The format for specifying each term in the value set is as follows: <CodeSystem Abbreviation>#<Term Code> For example: HL7CONDSTAT#active \"Active\" Where: HL7CONDSTAT is the value assigned to CodeSystem: which contains the canonical URL or urn: of the coding system. # is a delimiter separating the coding system and the code active is the term code for the concept \"Active\" is the display name associated with the term code. Create Logical Model to FHIR mappings Create a file called myExample_map_r4.txt under the myExampleC6 sub-directory. Copy the following header information to the top of the file: Grammar: Map 5.1 Namespace: myExample Target: FHIR_R4 Where: Grammar: is the version supported for the mapping grammar Namespace: is the name of the namespace for your logical model Target: is the FHIR release version targeted for mapping elements in your logical model, one of the following values: FHIR_DSTU2, FHIR_STU_3, or FHIR_R4. Our mapping will be to FHIR_R4. Specifying the target also configures the CIMPL tool chain to generate R4 structure definitions. During mapping, we ask the following questions: Is there a FHIR resource that could be a good fit for our logical model entities? If yes, is there an equivalent FHIR attribute for each of the properties in our logical model? If there is an equivalent FHIR attribute then do the data types, cardinality constraints, and terminology bindings align? For simplicity, we made the example such that the answer is yes to all questions. MyPatient entity can map to Patient , and ObstructiveSleepApneaDisorder can map to Condition . Because we have specified our target map to be FHIR_R4 , our mappings will target the R4 version. MyPatient maps to Patient: MyBirthDate maps to birthDate MyGender maps to gender ObstructiveSleepApneaDisorder maps to Condition: OSADisorderCode maps to code OSACurrentStatus maps to clinicalStatus The logical model properties also match to equivalent FHIR attributes for each resource we've chosen to build our profiles. And because FHIR profiling does allow to further constrain and not loosen cardinality constraints and binding strengths, we can confirm that our elements also satisfy those requirements. Generate the FHIR IG In this section, we cover some of the extra CIMPL configuration steps that might be needed to customize the output of your FHIR IG. Specify the FHIR \"Must-Support\" elements The CIMPL toolchain provides a separate configuration file called a \"Content Profile\" which serves two purposes: Specifies which elements in your logical model that you want to designate in FHIR as \"must-support\" (MS) . Instructs the CIMPL toolchain which elements you want auto-generated in a data dictionary output. Together with specified cardinality, the MS declaration can be interpreted as follows : Cardinality Must Support Interpretation 1..1 any required 0..1 yes required if known 0..1 no optional Create a file called ig-myExample-cp.txt under the myExampleC6 sub-directory. Paste the following code snippet into your file: Grammar: ContentProfile 1.0 Namespace: myExample MyPatient: MyGender MS ObstructiveSleepApneaDisorder: OSADisorderCode MS For our example, we have designated the MyGender and OSADisorderCode elements as must-support . Further documentation about the CIMPL Content Profile configuration can be found here . Create a Homepage for the IG Create a new file called index.html under the myExampleC6 directory. Copy the following contents in this page: <h1>myExample Implementation Guide</h1> <p>CIMPL Tutorial demonstrating how to create FHIR profiles and an IG.</p> Configuring your output For purpose of the tutorial's focus on modeling, we have already created a configuration file called ig-myExampleR4-config.json for our example and had you copy this file to the myExampleC6 directory at the start of this tutorial. But let's review some highlights of this file. Click here to view the contents of ig-myExampleR4-config.json . The table below shows a partial listing of fields in the config file. More advanced configuration options are available here . Parameter Value Meaning ProjectName \"My Example Project\" This will appear on the home page title of your generated IG. fhirURL \"http://example.com/fhir\" The URL pre-pended to your StructureDefinition canonical URLs. contentProfile \"ig-myExample-cp.txt\" The name of the file which sets FHIR must-support flags. filterStrategy \"true\" Indicates that not all entries in the logical model should be including in the IG strategy \"namespace\" Indicates all logical model elements in the namespace will be in the IG. target [\"myExample\"] JSON array containing the namespace(s) targeted by the filtering strategy. indexContent \"index.html\" The file containing the IG homepage. Running scripts to compile CIMPL and IG Generation Generating the FHIR IG is a 2-step process: Before executing Step 1 to compile your CIMPL code, an examples directory must exist. It can be empty. Create a subdirectory called examples_myFhirExamplesFolder under the myExampleC6 folder. Step 1: Run the Command Line Interface (SHR-CLI) compiler. Open a command line terminal and navigate to the ./cimpl/shr-cli directory (or whichever directory you installed SHR-CLI). Run the following command: node . ../myExampleC6 -l error -o myExampleC6r4 -c ig-myExampleR4-config.json Where: * the first parameter after the node command, ../myExampleC6 is the path where your CIMPL modeling and configuration files are located. * the -l parameter and error value specifies logging to only show errors. * the -o parameter and myExampleC6r4 value specify the name of the directory in which you want to generate the IG output. * the -c parameter and ig-myExampleR4-config.json value specify the name of the CIMPL configuration file to reference for the output. After you run this first command, as an interim check, navigate to the ~/cimpl/shr-cli folder. You should see a new subdirectory created called myExampleC6r4 which will eventually contain the StructureDefinition and html output of the generated IG. This is the value that was specified in the -o parameter in the above command. Step 2: Run the IG Publisher. From the same command line terminal, run the following command: yarn run ig:publish Alternately, run the full command to specify the destination directory (following the -ig flag): java $JAVA_OPTS -jar myExampleC6r4/fhir/guide/org.hl7.fhir.publisher.jar -ig myExampleC6r4/fhir/guide/ig.json Navigate to the ~/cimpl/shr-cli/myExampleC6r4/fhir/guide/output directory and open the index.html file in a browser. This will display the home page of the generated FHIR IG for your example project. Create FHIR examples We're now going to add a FHIR example that conforms to our profile. This step adds an example file to the directory you created in the first step. Since the details creating FHIR examples are out of scope for this tutorial, we're going to supply one for you. Directory: cimpl |_ shr-cli |_ myExampleC6 |_ examples_myFhirExamplesFolder Copy the file myPatientExample1.json and its contents into the examples_myFhirExamplesFolder . Note: The FHIR example can contain additional content, and still pass validation. What matters is that the requirements of the profile are met. Add the following line to your cimpl configuration file within the \"implementationGuide\": JSON object: \"examples\": \"examples_myFhirExamplesFolder\" We have already added it for you so you can just check that the parameter is there. The following screenshot shows an exmample of where you would find this parameter within the CIMPL configuration file ig-myExampleR4-config.json . Now run SHR-CLI and the IG publisher commands again: node . ../myExampleC6 -l error -o myExampleC6r4 -c ig-myExampleR4-config.json java $JAVA_OPTS -jar myExampleC6r4/fhir/guide/org.hl7.fhir.publisher.jar -ig myExampleC6r4/fhir/guide/ig.json Open the index.html file from the generated IG output in your browser and navigate to the Profiles tab and select the MyPatient profile. You'll now find a tab called Examples which will contain a URL to the example within the examples_myFhirExamplesFolder . So you might be thinking, \"How does the IG know which profile to insert your example?\" The answer is that the name of the related FHIR StructureDefinition for the profile is specified within the FHIR example itself... The IG Publisher will match the canonical URL specified in the example with what is specified in the IG. Note that the value of the profile parameter must match the canonical URL of the profile where the StructureDefinition is located in order for the example to appear.","title":"CIMPL 6.0 In-depth Tutorial"},{"location":"cimpl6Tutorial_detail/#cimpl-60-in-depth-tutorial","text":"This is an extensive tutorial, meant to educate people about many different aspects of CIMPL. If you're looking for a quick introduction to CIMPL and SHR-CLI environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Language Reference documentation . Table Of Contents CIMPL 6.0 In-depth Tutorial Pre-requisite Tutorial Pre-configuration Introduction Define Use Cases Create a High-level Conceptual Model Create a List of Data Elements Create the Logical Model in CIMPL Creating Custom Value Sets Create Logical Model to FHIR mappings Generate the FHIR IG Specify the FHIR \"Must-Support\" elements Create a Homepage for the IG Configuring your output Running scripts to compile CIMPL and IG Generation Create FHIR examples","title":"CIMPL 6.0 In-depth Tutorial"},{"location":"cimpl6Tutorial_detail/#pre-requisite","text":"This tutorial assumes that you already have the following software components installed: CIMPL SHR-CLI (preferably installed in the ~/cimpl/shr-cli directory) A text-editor (preferably VSCode with the vs-code-language-cimpl extension, but not required) Note: This tutorial was run using a MacOS environment. While the content of CIMPL authoring are identical regardless of platform, the command lines run in a command line terminal will differ in file path specifications. Namely, for a Windows command line terminal, replace all the path references of forward-slash / to back-slash \\ .","title":"Pre-requisite"},{"location":"cimpl6Tutorial_detail/#tutorial-pre-configuration","text":"To keep this tutorial more focused on how to model, we're first going to setup the environment with some supporting configuration and core data type files. We're also going to assume the following directory structure for your configuration: Directory: cimpl |_ shr-cli Note: Your top level directory where SHR-CLI was installed might differ. If so, then you'll be instead referencing the relative directory where you have installed shr-cli. Create a sub-directory under cimpl called myExampleC6 Now your directory structure should look like this: Directory: cimpl |_ shr-cli |_ myExampleC6 Copy the following files to the myExampleC6 sub-directory. The files contain global definitions for Code Systems, Value Sets, maps to FHIR R4 elements and examples. These file names are hyperlinked for retrieval: shr_core_datatype.txt shr_core_datatype_vs.txt shr_core_datatype_map_r4.txt ig-myExampleR4-config.json","title":"Tutorial Pre-configuration"},{"location":"cimpl6Tutorial_detail/#introduction","text":"This tutorial will guide the user in a step by step process to build a basic clinical data model using the \"Clean Slate\" method of CIMPL authoring. It will also illustrate the modeling practice briefly described in Appendix A of the CIMPL Authoring Guide . The steps are briefly summarized here for conciseness: Define use case(s) Create a high-level conceptual model Create a data element requirement list Create the logical model Create logical element-to-FHIR mappings Generate the FHIR Implementation Guide Create FHIR examples for each profile (optional)","title":"Introduction"},{"location":"cimpl6Tutorial_detail/#define-use-cases","text":"For our example, we'll focus on obstructive sleep apnea (OSA) . The goal is to measure the prevalence of patients diagnosed with OSA, stratified by age groups. A secondary goal is to further identify the population by gender. Electronic Health Records (EHRs) are the primary source for this information.","title":"Define Use Cases"},{"location":"cimpl6Tutorial_detail/#create-a-high-level-conceptual-model","text":"A conceptual diagram is shown in the figure below: While this case is very simple, diagrams of this sort are valuable to the non-technical community, and to drive further design of the model.","title":"Create a High-level Conceptual Model"},{"location":"cimpl6Tutorial_detail/#create-a-list-of-data-elements","text":"Creating a list of data elements helps to refine the contents, data types, cardinality, and clinical terminologies needed in the model. It helps at this stage to research existing standards and related models, but for this example, we won't look beyond FHIR resources for inspiration. The table below is a high level summary of the elements we need in this use case: Entity Data Element Name Cardinality Data type Value Set (if applicable) Patient BirthDate 1..1 date Patient Gender 0..1 concept HL7 Gender OSADisorder OSADisorderCode concept SNOMED codes for OSA OSADisorder OSADisorderStatus concept HL7 status codes","title":"Create a List of Data Elements"},{"location":"cimpl6Tutorial_detail/#create-the-logical-model-in-cimpl","text":"Now we can start authoring models in the CIMPL development environment. In this example, we are using the \"clean slate\" method of defining our logical model elements without using the pre-existing \"Objective FHIR\" class library. CIMPL has three main files involved in the creation of a logical model - one of each for every CIMPL project. We list them here for brevity, but reference the CIMPL 6 Reference Guide for further details on each: Class file Value Set file Map file The class file is the place to start. Create a new file under the myExampleC6 subdirectory called myExample.txt . Type in the CIMPL header information designating the namespace and version of the DataElement parser: Grammar: DataElement 6.0 Namespace: myExample Description: \"CIMPL Tutorial: myExample for an OSA patient.\" Uses: shr.core Where: Grammar is a required keyword indicating the parser to be used, in this case DataElement 6.0 Namespace , also required, is a short name for your project, implementation guide, or module you are defining. Uses is the list of all namespaces which your model elements will reference. For our example, we fix this to shr.core . Next, we will create our first profile called MyPatient which we determined will also have the following properties: MyBirthDate (a required field which only accepts one value) MyGender (an optional field that we want to have the receive accept if it so happens to have a value sent in any FHIR instance.) Let's build our Patient logical model. Add the following lines below your CIMPL header. Entry: MyPatient Description: \"An individual awaiting or under medical care and treatment. (source: Webster's Dictionary)\" Property: MyBirthDate 1..1 Property: MyGender 0..1 Element: MyBirthDate Description: \"The date when the patient was born.\" Value: date Element: MyGender Description: \"Either of the two sexes (male and female), especially when considered with reference to social and cultural differences rather than biological ones. (source: Oxford Dictionary)\" Value: concept from http://hl7.org/fhir/ValueSet/administrative-gender What we just represented here is that there is a Patient entity called MyPatient which has 2 properties: MyBirthdate and MyGender . Never mind that FHIR Patient has these attributes -- this won't always be the case. We determined from our clinical requirements that MyBirthDate has a data type of date , which is one of the primitive data types supported in CIMPL. We also determined that MyGender is a value set that can be male , female , or unknown . For the sake of simplicity, we find that HL7 has a matching value set identical to our requirements so we'll use that one for its value. Now let's work on the OSA Disorder entity. Add the following text into the file: Entry: ObstructiveSleepApneaDisorder Description: \"Obstructive sleep apnea (OSA) is a sleep-related breathing disorder that involves a decrease or complete halt in airflow despite an ongoing effort to breathe. It occurs when the muscles relax during sleep, causing soft tissue in the back of the throat to collapse and block the upper airway. (source: American Academy of Sleep Medicine)\" Property: OSADisorderCode 1..1 Property: OSACurrentStatus 0..1 Element: OSADisorderCode Description: \"The diagnosis or problem list code assigned to the OSA disorder.\" Value: concept from OSADisorderVS Element: OSACurrentStatus Description: \"State of the diagnosis or problem list item.\" Value: concept from OSACurrentStatusVS Here we specify the entity called ObstructiveSleepApneaDisorder containing two properties to define the disorder code and current status. Both properties have been defined as concepts which reference value sets that need to be defined. Again, don't be concerned that this seems to replicate the elements of FHIR Condition; many logical models will have elements with no analogy in FHIR.","title":"Create the Logical Model in CIMPL"},{"location":"cimpl6Tutorial_detail/#creating-custom-value-sets","text":"Create a new file called myExample_vs.txt underneath the myExampleC6 directory. Add the CIMPL value set header information below: Grammar: ValueSet 5.1 Namespace: myExample Where: Grammar is the keyword which specifies that the file created is a value set file conforming to CIMPL value set parser version 5.1. Namespace is the keyword whose value contains the namespace defined for your model. In this case, it's myExample . Next we specify the terms in the value set which we've defined in our clinical data requirements. Add the following text below the CIMPL value set header information: CodeSystem: SCT = http://snomed.info/sct CodeSystem: STAT = http://terminology.hl7.org/CodeSystem/condition-clinical ValueSet: OSADisorderVS Description: \"The list of disorders related to Obstructive Sleep Apnea.\" SCT#1101000119103 \"Obstructive sleep apnea of adult (disorder)\" SCT#1091000119108 \"Obstructive sleep apnea of child (disorder)\" ValueSet: OSACurrentStatusVS Description: \"The current disease status of an OSA patient\" STAT#active \"Active\" STAT#inactive \"Inactive\" STAT#resolved \"Resolved\" Here we have defined the terminology coding system reference by the value set, specified using the CodeSystem: keyword up front. This allows us to tag a short-hand notation of the coding system to the code for each term in the value set. It also allows for the flexibility of specifying terms with different coding systems within a value set, if applicable. The format for specifying each term in the value set is as follows: <CodeSystem Abbreviation>#<Term Code> For example: HL7CONDSTAT#active \"Active\" Where: HL7CONDSTAT is the value assigned to CodeSystem: which contains the canonical URL or urn: of the coding system. # is a delimiter separating the coding system and the code active is the term code for the concept \"Active\" is the display name associated with the term code.","title":"Creating Custom Value Sets"},{"location":"cimpl6Tutorial_detail/#create-logical-model-to-fhir-mappings","text":"Create a file called myExample_map_r4.txt under the myExampleC6 sub-directory. Copy the following header information to the top of the file: Grammar: Map 5.1 Namespace: myExample Target: FHIR_R4 Where: Grammar: is the version supported for the mapping grammar Namespace: is the name of the namespace for your logical model Target: is the FHIR release version targeted for mapping elements in your logical model, one of the following values: FHIR_DSTU2, FHIR_STU_3, or FHIR_R4. Our mapping will be to FHIR_R4. Specifying the target also configures the CIMPL tool chain to generate R4 structure definitions. During mapping, we ask the following questions: Is there a FHIR resource that could be a good fit for our logical model entities? If yes, is there an equivalent FHIR attribute for each of the properties in our logical model? If there is an equivalent FHIR attribute then do the data types, cardinality constraints, and terminology bindings align? For simplicity, we made the example such that the answer is yes to all questions. MyPatient entity can map to Patient , and ObstructiveSleepApneaDisorder can map to Condition . Because we have specified our target map to be FHIR_R4 , our mappings will target the R4 version. MyPatient maps to Patient: MyBirthDate maps to birthDate MyGender maps to gender ObstructiveSleepApneaDisorder maps to Condition: OSADisorderCode maps to code OSACurrentStatus maps to clinicalStatus The logical model properties also match to equivalent FHIR attributes for each resource we've chosen to build our profiles. And because FHIR profiling does allow to further constrain and not loosen cardinality constraints and binding strengths, we can confirm that our elements also satisfy those requirements.","title":"Create Logical Model to FHIR mappings"},{"location":"cimpl6Tutorial_detail/#generate-the-fhir-ig","text":"In this section, we cover some of the extra CIMPL configuration steps that might be needed to customize the output of your FHIR IG.","title":"Generate the FHIR IG"},{"location":"cimpl6Tutorial_detail/#specify-the-fhir-must-support-elements","text":"The CIMPL toolchain provides a separate configuration file called a \"Content Profile\" which serves two purposes: Specifies which elements in your logical model that you want to designate in FHIR as \"must-support\" (MS) . Instructs the CIMPL toolchain which elements you want auto-generated in a data dictionary output. Together with specified cardinality, the MS declaration can be interpreted as follows : Cardinality Must Support Interpretation 1..1 any required 0..1 yes required if known 0..1 no optional Create a file called ig-myExample-cp.txt under the myExampleC6 sub-directory. Paste the following code snippet into your file: Grammar: ContentProfile 1.0 Namespace: myExample MyPatient: MyGender MS ObstructiveSleepApneaDisorder: OSADisorderCode MS For our example, we have designated the MyGender and OSADisorderCode elements as must-support . Further documentation about the CIMPL Content Profile configuration can be found here .","title":"Specify the FHIR \"Must-Support\" elements"},{"location":"cimpl6Tutorial_detail/#create-a-homepage-for-the-ig","text":"Create a new file called index.html under the myExampleC6 directory. Copy the following contents in this page: <h1>myExample Implementation Guide</h1> <p>CIMPL Tutorial demonstrating how to create FHIR profiles and an IG.</p>","title":"Create a Homepage for the IG"},{"location":"cimpl6Tutorial_detail/#configuring-your-output","text":"For purpose of the tutorial's focus on modeling, we have already created a configuration file called ig-myExampleR4-config.json for our example and had you copy this file to the myExampleC6 directory at the start of this tutorial. But let's review some highlights of this file. Click here to view the contents of ig-myExampleR4-config.json . The table below shows a partial listing of fields in the config file. More advanced configuration options are available here . Parameter Value Meaning ProjectName \"My Example Project\" This will appear on the home page title of your generated IG. fhirURL \"http://example.com/fhir\" The URL pre-pended to your StructureDefinition canonical URLs. contentProfile \"ig-myExample-cp.txt\" The name of the file which sets FHIR must-support flags. filterStrategy \"true\" Indicates that not all entries in the logical model should be including in the IG strategy \"namespace\" Indicates all logical model elements in the namespace will be in the IG. target [\"myExample\"] JSON array containing the namespace(s) targeted by the filtering strategy. indexContent \"index.html\" The file containing the IG homepage.","title":"Configuring your output"},{"location":"cimpl6Tutorial_detail/#running-scripts-to-compile-cimpl-and-ig-generation","text":"Generating the FHIR IG is a 2-step process: Before executing Step 1 to compile your CIMPL code, an examples directory must exist. It can be empty. Create a subdirectory called examples_myFhirExamplesFolder under the myExampleC6 folder. Step 1: Run the Command Line Interface (SHR-CLI) compiler. Open a command line terminal and navigate to the ./cimpl/shr-cli directory (or whichever directory you installed SHR-CLI). Run the following command: node . ../myExampleC6 -l error -o myExampleC6r4 -c ig-myExampleR4-config.json Where: * the first parameter after the node command, ../myExampleC6 is the path where your CIMPL modeling and configuration files are located. * the -l parameter and error value specifies logging to only show errors. * the -o parameter and myExampleC6r4 value specify the name of the directory in which you want to generate the IG output. * the -c parameter and ig-myExampleR4-config.json value specify the name of the CIMPL configuration file to reference for the output. After you run this first command, as an interim check, navigate to the ~/cimpl/shr-cli folder. You should see a new subdirectory created called myExampleC6r4 which will eventually contain the StructureDefinition and html output of the generated IG. This is the value that was specified in the -o parameter in the above command. Step 2: Run the IG Publisher. From the same command line terminal, run the following command: yarn run ig:publish Alternately, run the full command to specify the destination directory (following the -ig flag): java $JAVA_OPTS -jar myExampleC6r4/fhir/guide/org.hl7.fhir.publisher.jar -ig myExampleC6r4/fhir/guide/ig.json Navigate to the ~/cimpl/shr-cli/myExampleC6r4/fhir/guide/output directory and open the index.html file in a browser. This will display the home page of the generated FHIR IG for your example project.","title":"Running scripts to compile CIMPL and IG Generation"},{"location":"cimpl6Tutorial_detail/#create-fhir-examples","text":"We're now going to add a FHIR example that conforms to our profile. This step adds an example file to the directory you created in the first step. Since the details creating FHIR examples are out of scope for this tutorial, we're going to supply one for you. Directory: cimpl |_ shr-cli |_ myExampleC6 |_ examples_myFhirExamplesFolder Copy the file myPatientExample1.json and its contents into the examples_myFhirExamplesFolder . Note: The FHIR example can contain additional content, and still pass validation. What matters is that the requirements of the profile are met. Add the following line to your cimpl configuration file within the \"implementationGuide\": JSON object: \"examples\": \"examples_myFhirExamplesFolder\" We have already added it for you so you can just check that the parameter is there. The following screenshot shows an exmample of where you would find this parameter within the CIMPL configuration file ig-myExampleR4-config.json . Now run SHR-CLI and the IG publisher commands again: node . ../myExampleC6 -l error -o myExampleC6r4 -c ig-myExampleR4-config.json java $JAVA_OPTS -jar myExampleC6r4/fhir/guide/org.hl7.fhir.publisher.jar -ig myExampleC6r4/fhir/guide/ig.json Open the index.html file from the generated IG output in your browser and navigate to the Profiles tab and select the MyPatient profile. You'll now find a tab called Examples which will contain a URL to the example within the examples_myFhirExamplesFolder . So you might be thinking, \"How does the IG know which profile to insert your example?\" The answer is that the name of the related FHIR StructureDefinition for the profile is specified within the FHIR example itself... The IG Publisher will match the canonical URL specified in the example with what is specified in the IG. Note that the value of the profile parameter must match the canonical URL of the profile where the StructureDefinition is located in order for the example to appear.","title":"Create FHIR examples"},{"location":"cimpl6Tutorial_helloWorld/","text":"CIMPL 6.0 'Hello World' Tutorial Let\u2019s do a \u201cHello, World\u201d using CIMPL v6! Note: Make sure you have completed the CIMPL Installation instructions before proceeding, and that SHR-CLI (minimum version 6.2.0) is installed in ~/cimpl/shr-cli . Start by creating a folder structure for our new project. Open up your favorite (Unix-based) command-line tool and enter the following: cd ~/cimpl mkdir hello_world Now, create a file called HelloWorld.txt in the ~/cimpl/hello_world folder and add the following data definitions: Grammar: DataElement 6.0 Namespace: hello Description: \"A simple example of CIMPL.\" Entry: HelloWorld Description: \"A silly profile.\" Property: SayHello 0..1 Element: SayHello Description: \"An extension indicating whether to say hello\" Value: boolean Next, create a file called HelloWorld_map.txt that defines the mapping to FHIR. Since this doesn\u2019t align with any particular resource, it will map to Basic . This file is even simpler: Grammar: Map 5.1 Namespace: hello Target: FHIR_STU_3 HelloWorld maps to Basic: We didn\u2019t map the SayHello data element to an existing element inside this resource, so it will automatically appear as an extension. Next, we need some simple HTML for the Implementation Guide pages, so create an exampleIndexContent.html file with the following content: HELLO HELLO HELLO Finally, we need a configuration file. Create an ig-hello_world-config.json file with these contents: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"npmName\": \"hello_world\", \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } } Now, go back to your SHR-CLI installation and run the hello world: cd ~/cimpl/shr-cli node . -c ig-hello_world-config.json ../hello_world When the program runs, it will output a warning message alerting you that mapping to Basic usually isn\u2019t the best choice, but in this case, it is intentional. After the program runs, the generated profile (a FHIR StructureDefinition ) will be found in ~/cimpl/shr-cli/out/fhir/profiles/ . StructureDefinition s are verbose, and this one clocks in at several hundred lines. A friendlier view is created when we create an implementation guide (IG). To do this, we use the existing FHIR implementation guide (IG) publisher . IG Generation _Note: If your organization uses a proxy server, you may have to run the IG publishing process from outside your organization's firewall. For more information, see FHIR's GForge tracker as issue #19815 . To generate the IG, run: cd ~/cimpl/shr-cli yarn run ig:publish The generated profile page will be located at ~/cimpl/shr-cli/out/fhir/guide/output/StructureDefinition-hello-HelloWorld.html . Open this page in your favorite web browser. You should see a FHIR profile that looks like a traditional FHIR Implementation Guide . For a more comprehensive understanding of the CIMPL grammar and how to use it for your project, continue to the Tutorial . Note: the IG is automatically branded as part of the Standard Health Record (SHR). We are working on \u201cde-branding\u201d the IG, so please ignore the SHR references for now.","title":"CIMPL 6.0 'Hello World' Tutorial"},{"location":"cimpl6Tutorial_helloWorld/#cimpl-60-hello-world-tutorial","text":"Let\u2019s do a \u201cHello, World\u201d using CIMPL v6! Note: Make sure you have completed the CIMPL Installation instructions before proceeding, and that SHR-CLI (minimum version 6.2.0) is installed in ~/cimpl/shr-cli . Start by creating a folder structure for our new project. Open up your favorite (Unix-based) command-line tool and enter the following: cd ~/cimpl mkdir hello_world Now, create a file called HelloWorld.txt in the ~/cimpl/hello_world folder and add the following data definitions: Grammar: DataElement 6.0 Namespace: hello Description: \"A simple example of CIMPL.\" Entry: HelloWorld Description: \"A silly profile.\" Property: SayHello 0..1 Element: SayHello Description: \"An extension indicating whether to say hello\" Value: boolean Next, create a file called HelloWorld_map.txt that defines the mapping to FHIR. Since this doesn\u2019t align with any particular resource, it will map to Basic . This file is even simpler: Grammar: Map 5.1 Namespace: hello Target: FHIR_STU_3 HelloWorld maps to Basic: We didn\u2019t map the SayHello data element to an existing element inside this resource, so it will automatically appear as an extension. Next, we need some simple HTML for the Implementation Guide pages, so create an exampleIndexContent.html file with the following content: HELLO HELLO HELLO Finally, we need a configuration file. Create an ig-hello_world-config.json file with these contents: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"npmName\": \"hello_world\", \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } } Now, go back to your SHR-CLI installation and run the hello world: cd ~/cimpl/shr-cli node . -c ig-hello_world-config.json ../hello_world When the program runs, it will output a warning message alerting you that mapping to Basic usually isn\u2019t the best choice, but in this case, it is intentional. After the program runs, the generated profile (a FHIR StructureDefinition ) will be found in ~/cimpl/shr-cli/out/fhir/profiles/ . StructureDefinition s are verbose, and this one clocks in at several hundred lines. A friendlier view is created when we create an implementation guide (IG). To do this, we use the existing FHIR implementation guide (IG) publisher .","title":"CIMPL 6.0 'Hello World' Tutorial"},{"location":"cimpl6Tutorial_helloWorld/#ig-generation","text":"_Note: If your organization uses a proxy server, you may have to run the IG publishing process from outside your organization's firewall. For more information, see FHIR's GForge tracker as issue #19815 . To generate the IG, run: cd ~/cimpl/shr-cli yarn run ig:publish The generated profile page will be located at ~/cimpl/shr-cli/out/fhir/guide/output/StructureDefinition-hello-HelloWorld.html . Open this page in your favorite web browser. You should see a FHIR profile that looks like a traditional FHIR Implementation Guide . For a more comprehensive understanding of the CIMPL grammar and how to use it for your project, continue to the Tutorial . Note: the IG is automatically branded as part of the Standard Health Record (SHR). We are working on \u201cde-branding\u201d the IG, so please ignore the SHR references for now.","title":"IG Generation"},{"location":"cimplInstall/","text":"CIMPL Setup and Installation Table of Contents CIMPL Setup and Installation Background Windows Installation Instructions Windows Proxy Setup Supporting Software Node.js for Windows Yarn for Windows Yarn Proxy Setup Git for Windows Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool Windows Java Installation Windows Jekyll Installation macOS Installation Instructions Terminal Proxy Setup Supporting Software Node.js for macOS Homebrew Yarn for macOS Git for macOS Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool MacOS Java Installation MacOS Jekyll Installation Background CIMPL (and, by extension, the SHR-CLI tool) is a text-based tool that requires its users to understand and use your operating system's command line . If you are uncomfortable with using the command line, try this short introduction . Windows Installation Instructions Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: Read the instructions thoroughly . Follow instructions in order , without skipping around. Pay attention to variables (like your organization's proxy) that you may need to replace. Windows Proxy Setup Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server, you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: setx HTTP_PROXY http://your.proxy.org setx HTTPS_PROXY https://your.proxy.org setx http_proxy http://your.proxy.org setx https_proxy https://your.proxy.org setx proxy http://your.proxy.org setx JAVA_OPTS \"-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80\" Open a windows command prompt Copy and paste the modified code block (with your organization's proxy server) into the command prompt Close and re-open your command prompt to make sure those settings take effect Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server. Supporting Software Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code . Node.js for Windows The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Yarn for Windows Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. It is recommended that CIMPL developers download and install the stable version of Yarn . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Yarn Proxy Setup Note: If your organization uses a proxy server, replace http://your.proxy.org with your organization's proxy server in the following code block: yarn config set proxy http://your.proxy.org yarn config set strict-ssl false ...then run the modified code block (with your organization's proxy server) in the command prompt Git for Windows Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the SHR-CLI tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . Download the installation package for Git for Windows and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete). This will install a few applications, but the most useful for CIMPL development will be the 'Git Bash' application. This opens a command-line prompt which emulates the use of git on a Unix-based system (e.g., Linux or macOS). Most CIMPL developers use Unix-based systems, so you may want to use 'Git Bash' for working with CIMPL instead of the standard Windows command line. There are many tutorials online about the use of git. Users that are new to Unix or bash may find this video introduction to Git Bash helpful. You should also set up git so that any changes you make to the codebase are properly identified (replacing the name and email placeholders with your name and email): git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\" Git Proxy Setup Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open a windows command prompt Copy and paste that code block (with your organization's proxy server) into the command prompt Learning Git If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/ Visual Studio Code Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . You can use the default options in the installer file, but some developers find it helpful to check these checkboxes during the installation wizard: Add \"Open with Code\" action to Windows Explorer file context menu Add \"Open with Code\" action to Windows Explorer directory context menu Register Code as an editor for supported file types Proxy Setup Note: If your organization uses a proxy server, you'll need to set this up in the VSCode settings. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: Open Visual Studio Code Open the User Settings menu (File -> Preferences -> Settings in the menu bar or Ctrl + , ) Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: Save the changes (Using File -> Save in the menu bar or Ctrl + S ) Exit and re-open Visual Studio Code to make sure the settings take effect CIMPL Extension Setup CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: Open the extensions menu (Using View -> Extensions in the menu bar, Ctrl + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) By default, the extensions are filtered by @sort:installs . Replace this with cimpl Look for the vscode-language-cimpl extension and click the Install button When the installation has completed, click the Reload button SHR-CLI Tool With the supporting software installed, you can move on to installing the actual SHR-CLI tool. Open 'Git Bash' (not the windows command prompt) and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the SHR-CLI tool and places it in the ~/cimpl/shr-cli directory. To set up the SHR-CLI tool, run: cd ~/cimpl/shr-cli yarn FHIR IG Generation Tool The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly. Windows Java Installation The IG publisher is primarily written in java and requires JRE version 8. To install JRE: Go to the Java SE Runtime Environment 8 Downloads page Click the 'Accept License Agreement' radio button Download the most recent JRE 8 installer for your operating system Windows Jekyll Installation Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. Use the Windows Installation Instructions for Jekyll : Download RubyInstaller and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) After clicking 'Finish', a command prompt should open asking about an MSYS2 base installation . Press Enter to continue. When that installation is complete, open a new command prompt from the Windows start menu and type: gem install jekyll bundler Check to see that Jekyll is installed using: jekyll -v You should see the following: jekyll X.X.X ...where X.X.X is the latest Jekyll version number. If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example. macOS Installation Instructions Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: Read the instructions thoroughly Follow instructions in order , without skipping around Pay attention to variables (like your organization's proxy) that you may need to replace Terminal Proxy Setup Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server and you use the standard Terminal app for macOS , you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: echo \"export http_proxy=http://your.proxy.org:80 export https_proxy=http://your.proxy.org:80 export HTTP_PROXY=http://your.proxy.org:80 export HTTPS_PROXY=http://your.proxy.org:80 export JAVA_OPTS='-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 \\ -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 \\ -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80'\" >> ~/.bash_profile;\\ source ~/.bash_profile Open Terminal Copy and paste the modified code block (with your organization's proxy server) into the terminal Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server. Supporting Software Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code . Node.js for macOS The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Homebrew Homebrew is a package manager for macOS which will allow us to install several other applications. To install homebrew, enter the following in a terminal window: /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Note: During the installation, you may be asked if you want to install 'OSX Developer Tools'. If this occurs, answer 'yes'. Yarn for macOS Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. With homebrew installed, yarn can be installed by entering the following in a terminal window: brew install yarn Git for macOS Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the SHR-CLI tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . With homebrew installed, git can be installed by entering the following in a terminal window: brew install git You should also set up git so that any changes you make to the codebase are properly identified. Replace the name and email placeholders with your name and email : git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\" Git Proxy Setup Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open Terminal Copy and paste that code block (with your organization's proxy server) into the terminal Learning Git If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/ Visual Studio Code Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . Proxy Setup Note: If your organization uses a proxy server, you will need to add some proxy settings to Visual Studio Code. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: Open Visual Studio Code Open the User Settings menu (Code -> Preferences -> Settings in the menu bar or Command + , ) Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: Save the changes (Using File -> Save in the menu bar or Command + S ) Exit and re-open Visual Studio Code to make sure the settings take effect CIMPL Extension Setup CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: Open the extensions menu (Using View -> Extensions in the menu bar, Command + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) By default, the extensions are filtered by @sort:installs . Replace this with cimpl Look for the vscode-language-cimpl extension and click the Install button When the installation has completed, click the Reload button SHR-CLI Tool With the supporting software installed, you can move on to installing the actual SHR-CLI tool. Open a terminal window and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the SHR-CLI tool and places it in the ~/cimpl/shr-cli directory. To set up the SHR-CLI tool, run: cd ~/cimpl/shr-cli yarn Note: If you encounter error unable to get local issuer certificate , run the following command in terminal: yarn config set strict-ssl false ...and then re-run yarn using: yarn FHIR IG Generation Tool The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly. MacOS Java Installation The IG publisher is primarily written in java and requires JRE version 8. To install JRE: Go to the Java SE Runtime Environment 8 Downloads page Click the 'Accept License Agreement' radio button Download the most recent JRE 8 installer for your operating system MacOS Jekyll Installation Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. If you don't know if the xcode developer tools are installed, run the following command: xcode-select --install Install the latest version of Ruby: brew install ruby When ruby is finished installing, run the following: gem install bundler jekyll NOTE: If your system requires sudo to gem install bundler and jekyll, use the following command to preserve environment variables when using sudo : sudo -E gem install bundler jekyll If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example.","title":"CIMPL Setup and Installation"},{"location":"cimplInstall/#cimpl-setup-and-installation","text":"Table of Contents CIMPL Setup and Installation Background Windows Installation Instructions Windows Proxy Setup Supporting Software Node.js for Windows Yarn for Windows Yarn Proxy Setup Git for Windows Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool Windows Java Installation Windows Jekyll Installation macOS Installation Instructions Terminal Proxy Setup Supporting Software Node.js for macOS Homebrew Yarn for macOS Git for macOS Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool MacOS Java Installation MacOS Jekyll Installation","title":"CIMPL Setup and Installation"},{"location":"cimplInstall/#background","text":"CIMPL (and, by extension, the SHR-CLI tool) is a text-based tool that requires its users to understand and use your operating system's command line . If you are uncomfortable with using the command line, try this short introduction .","title":"Background"},{"location":"cimplInstall/#windows-installation-instructions","text":"Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: Read the instructions thoroughly . Follow instructions in order , without skipping around. Pay attention to variables (like your organization's proxy) that you may need to replace.","title":"Windows Installation Instructions"},{"location":"cimplInstall/#windows-proxy-setup","text":"Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server, you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: setx HTTP_PROXY http://your.proxy.org setx HTTPS_PROXY https://your.proxy.org setx http_proxy http://your.proxy.org setx https_proxy https://your.proxy.org setx proxy http://your.proxy.org setx JAVA_OPTS \"-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80\" Open a windows command prompt Copy and paste the modified code block (with your organization's proxy server) into the command prompt Close and re-open your command prompt to make sure those settings take effect Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server.","title":"Windows Proxy Setup"},{"location":"cimplInstall/#supporting-software","text":"Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code .","title":"Supporting Software"},{"location":"cimplInstall/#nodejs-for-windows","text":"The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Node.js for Windows"},{"location":"cimplInstall/#yarn-for-windows","text":"Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. It is recommended that CIMPL developers download and install the stable version of Yarn . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Yarn for Windows"},{"location":"cimplInstall/#yarn-proxy-setup","text":"Note: If your organization uses a proxy server, replace http://your.proxy.org with your organization's proxy server in the following code block: yarn config set proxy http://your.proxy.org yarn config set strict-ssl false ...then run the modified code block (with your organization's proxy server) in the command prompt","title":"Yarn Proxy Setup"},{"location":"cimplInstall/#git-for-windows","text":"Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the SHR-CLI tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . Download the installation package for Git for Windows and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete). This will install a few applications, but the most useful for CIMPL development will be the 'Git Bash' application. This opens a command-line prompt which emulates the use of git on a Unix-based system (e.g., Linux or macOS). Most CIMPL developers use Unix-based systems, so you may want to use 'Git Bash' for working with CIMPL instead of the standard Windows command line. There are many tutorials online about the use of git. Users that are new to Unix or bash may find this video introduction to Git Bash helpful. You should also set up git so that any changes you make to the codebase are properly identified (replacing the name and email placeholders with your name and email): git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\"","title":"Git for Windows"},{"location":"cimplInstall/#git-proxy-setup","text":"Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open a windows command prompt Copy and paste that code block (with your organization's proxy server) into the command prompt","title":"Git Proxy Setup"},{"location":"cimplInstall/#learning-git","text":"If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/","title":"Learning Git"},{"location":"cimplInstall/#visual-studio-code","text":"Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . You can use the default options in the installer file, but some developers find it helpful to check these checkboxes during the installation wizard: Add \"Open with Code\" action to Windows Explorer file context menu Add \"Open with Code\" action to Windows Explorer directory context menu Register Code as an editor for supported file types","title":"Visual Studio Code"},{"location":"cimplInstall/#proxy-setup","text":"Note: If your organization uses a proxy server, you'll need to set this up in the VSCode settings. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: Open Visual Studio Code Open the User Settings menu (File -> Preferences -> Settings in the menu bar or Ctrl + , ) Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: Save the changes (Using File -> Save in the menu bar or Ctrl + S ) Exit and re-open Visual Studio Code to make sure the settings take effect","title":"Proxy Setup"},{"location":"cimplInstall/#cimpl-extension-setup","text":"CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: Open the extensions menu (Using View -> Extensions in the menu bar, Ctrl + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) By default, the extensions are filtered by @sort:installs . Replace this with cimpl Look for the vscode-language-cimpl extension and click the Install button When the installation has completed, click the Reload button","title":"CIMPL Extension Setup"},{"location":"cimplInstall/#shr-cli-tool","text":"With the supporting software installed, you can move on to installing the actual SHR-CLI tool. Open 'Git Bash' (not the windows command prompt) and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the SHR-CLI tool and places it in the ~/cimpl/shr-cli directory. To set up the SHR-CLI tool, run: cd ~/cimpl/shr-cli yarn","title":"SHR-CLI Tool"},{"location":"cimplInstall/#fhir-ig-generation-tool","text":"The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly.","title":"FHIR IG Generation Tool"},{"location":"cimplInstall/#windows-java-installation","text":"The IG publisher is primarily written in java and requires JRE version 8. To install JRE: Go to the Java SE Runtime Environment 8 Downloads page Click the 'Accept License Agreement' radio button Download the most recent JRE 8 installer for your operating system","title":"Windows Java Installation"},{"location":"cimplInstall/#windows-jekyll-installation","text":"Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. Use the Windows Installation Instructions for Jekyll : Download RubyInstaller and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) After clicking 'Finish', a command prompt should open asking about an MSYS2 base installation . Press Enter to continue. When that installation is complete, open a new command prompt from the Windows start menu and type: gem install jekyll bundler Check to see that Jekyll is installed using: jekyll -v You should see the following: jekyll X.X.X ...where X.X.X is the latest Jekyll version number. If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example.","title":"Windows Jekyll Installation"},{"location":"cimplInstall/#macos-installation-instructions","text":"Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: Read the instructions thoroughly Follow instructions in order , without skipping around Pay attention to variables (like your organization's proxy) that you may need to replace","title":"macOS Installation Instructions"},{"location":"cimplInstall/#terminal-proxy-setup","text":"Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server and you use the standard Terminal app for macOS , you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: echo \"export http_proxy=http://your.proxy.org:80 export https_proxy=http://your.proxy.org:80 export HTTP_PROXY=http://your.proxy.org:80 export HTTPS_PROXY=http://your.proxy.org:80 export JAVA_OPTS='-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 \\ -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 \\ -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80'\" >> ~/.bash_profile;\\ source ~/.bash_profile Open Terminal Copy and paste the modified code block (with your organization's proxy server) into the terminal Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server.","title":"Terminal Proxy Setup"},{"location":"cimplInstall/#supporting-software_1","text":"Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code .","title":"Supporting Software"},{"location":"cimplInstall/#nodejs-for-macos","text":"The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Node.js for macOS"},{"location":"cimplInstall/#homebrew","text":"Homebrew is a package manager for macOS which will allow us to install several other applications. To install homebrew, enter the following in a terminal window: /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Note: During the installation, you may be asked if you want to install 'OSX Developer Tools'. If this occurs, answer 'yes'.","title":"Homebrew"},{"location":"cimplInstall/#yarn-for-macos","text":"Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. With homebrew installed, yarn can be installed by entering the following in a terminal window: brew install yarn","title":"Yarn for macOS"},{"location":"cimplInstall/#git-for-macos","text":"Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the SHR-CLI tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . With homebrew installed, git can be installed by entering the following in a terminal window: brew install git You should also set up git so that any changes you make to the codebase are properly identified. Replace the name and email placeholders with your name and email : git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\"","title":"Git for macOS"},{"location":"cimplInstall/#git-proxy-setup_1","text":"Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open Terminal Copy and paste that code block (with your organization's proxy server) into the terminal","title":"Git Proxy Setup"},{"location":"cimplInstall/#learning-git_1","text":"If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/","title":"Learning Git"},{"location":"cimplInstall/#visual-studio-code_1","text":"Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage .","title":"Visual Studio Code"},{"location":"cimplInstall/#proxy-setup_1","text":"Note: If your organization uses a proxy server, you will need to add some proxy settings to Visual Studio Code. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: Open Visual Studio Code Open the User Settings menu (Code -> Preferences -> Settings in the menu bar or Command + , ) Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: Save the changes (Using File -> Save in the menu bar or Command + S ) Exit and re-open Visual Studio Code to make sure the settings take effect","title":"Proxy Setup"},{"location":"cimplInstall/#cimpl-extension-setup_1","text":"CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: Open the extensions menu (Using View -> Extensions in the menu bar, Command + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) By default, the extensions are filtered by @sort:installs . Replace this with cimpl Look for the vscode-language-cimpl extension and click the Install button When the installation has completed, click the Reload button","title":"CIMPL Extension Setup"},{"location":"cimplInstall/#shr-cli-tool_1","text":"With the supporting software installed, you can move on to installing the actual SHR-CLI tool. Open a terminal window and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the SHR-CLI tool and places it in the ~/cimpl/shr-cli directory. To set up the SHR-CLI tool, run: cd ~/cimpl/shr-cli yarn Note: If you encounter error unable to get local issuer certificate , run the following command in terminal: yarn config set strict-ssl false ...and then re-run yarn using: yarn","title":"SHR-CLI Tool"},{"location":"cimplInstall/#fhir-ig-generation-tool_1","text":"The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly.","title":"FHIR IG Generation Tool"},{"location":"cimplInstall/#macos-java-installation","text":"The IG publisher is primarily written in java and requires JRE version 8. To install JRE: Go to the Java SE Runtime Environment 8 Downloads page Click the 'Accept License Agreement' radio button Download the most recent JRE 8 installer for your operating system","title":"MacOS Java Installation"},{"location":"cimplInstall/#macos-jekyll-installation","text":"Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. If you don't know if the xcode developer tools are installed, run the following command: xcode-select --install Install the latest version of Ruby: brew install ruby When ruby is finished installing, run the following: gem install bundler jekyll NOTE: If your system requires sudo to gem install bundler and jekyll, use the following command to preserve environment variables when using sudo : sudo -E gem install bundler jekyll If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example.","title":"MacOS Jekyll Installation"},{"location":"cimplReleaseNotes/","text":"CIMPL Release Notes Note: \"This documentation is in the process of being further expanded and is an actively updating document.\" CIMPL Release Notes CIMPL 6.0 CIMPL 5.0 CIMPL 6.0 Release Date : June 2019 CIMPL 6.0 contains a number of significant changes to both syntax and its base classes which support translation to FHIR. CIMPL 5.0 Release Date: 2017","title":"CIMPL Release Notes"},{"location":"cimplReleaseNotes/#cimpl-release-notes","text":"Note: \"This documentation is in the process of being further expanded and is an actively updating document.\" CIMPL Release Notes CIMPL 6.0 CIMPL 5.0","title":"CIMPL Release Notes"},{"location":"cimplReleaseNotes/#cimpl-60","text":"Release Date : June 2019 CIMPL 6.0 contains a number of significant changes to both syntax and its base classes which support translation to FHIR.","title":"CIMPL 6.0"},{"location":"cimplReleaseNotes/#cimpl-50","text":"Release Date: 2017","title":"CIMPL 5.0"}]}