{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CIMPL Project CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and declarative, with tools to produce FHIR Profiles, Implementation Guides, data dictionaries, and other documentation. Table of Contents Installation - Installing and configuring the CIMPL development environment. CIMPL Tutorials CIMPL HelloWorld Tutorial - a very simple tutorial which creates a FHIR Implementation Guide (IG). CIMPL Detailed Tutorial - Walkthrough example of how to author a detailed clinical model using CIMPL 6.0 grammar. CIMPL User Guides CIMPL Authoring - A guide on authoring within the CIMPL development environment. CIMPL Class Library (aka Objective FHIR) - An overview of the base classes provided with CIMPL. CIMPL Reference Manuals CIMPL Language Reference Manual - A detailed reference of CIMPL data primitives and syntax. The current version of CIMPL Grammar is CIMPL 6.0. CIMPL Tooling Reference Manual - A detailed description of the command line interface (CLI), auxiliary files, options, and configuration to produce a FHIR IG.","title":"![](img_cimpl/cimpl-logo.png) CIMPL Project"},{"location":"#cimpl-project","text":"CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and declarative, with tools to produce FHIR Profiles, Implementation Guides, data dictionaries, and other documentation.","title":"CIMPL Project"},{"location":"#table-of-contents","text":"Installation - Installing and configuring the CIMPL development environment. CIMPL Tutorials CIMPL HelloWorld Tutorial - a very simple tutorial which creates a FHIR Implementation Guide (IG). CIMPL Detailed Tutorial - Walkthrough example of how to author a detailed clinical model using CIMPL 6.0 grammar. CIMPL User Guides CIMPL Authoring - A guide on authoring within the CIMPL development environment. CIMPL Class Library (aka Objective FHIR) - An overview of the base classes provided with CIMPL. CIMPL Reference Manuals CIMPL Language Reference Manual - A detailed reference of CIMPL data primitives and syntax. The current version of CIMPL Grammar is CIMPL 6.0. CIMPL Tooling Reference Manual - A detailed description of the command line interface (CLI), auxiliary files, options, and configuration to produce a FHIR IG.","title":"Table of Contents"},{"location":"about/","text":"About CIMPL CIMPL was created by the MITRE Corporation . CIMPL is open source and free for public use. If you have questions, comments, or need help, please contact the CIMPL team on the CIMPL FHIR chat channel , or log an issue on the CIMPL Jira Issue Tracker . We can help your clinical modeling project! MITRE provides services to help non-profits develop open-source detailed clinical models. MITRE's FHIR team can provide informatics, modeling, terminology, HL7 standardization, and clinical resources to facilitate FHIR development. For an example of MITRE's work, see the mCODE Implementation Guide .","title":"About CIMPL"},{"location":"about/#about-cimpl","text":"CIMPL was created by the MITRE Corporation . CIMPL is open source and free for public use. If you have questions, comments, or need help, please contact the CIMPL team on the CIMPL FHIR chat channel , or log an issue on the CIMPL Jira Issue Tracker . We can help your clinical modeling project! MITRE provides services to help non-profits develop open-source detailed clinical models. MITRE's FHIR team can provide informatics, modeling, terminology, HL7 standardization, and clinical resources to facilitate FHIR development. For an example of MITRE's work, see the mCODE Implementation Guide .","title":"About CIMPL"},{"location":"cimpl6Authoring/","text":"CIMPL Authoring Guide Preface Purpose of this Document This document provides a step-by-step guide to generate an HL7 FHIR implementation guide (IG) starting with documenting a model using CIMPL. The details about how to accomplish each step are in the CIMPL Language Reference Guide and CIMPL Tooling Reference Guide . Links to these documents are provided in each section. Intended Audience The CIMPL Authoring Guide is targeted to any person comfortable with using software developers or people comfortable with programming languages. Familiarity with FHIR is helpful as the tutorial references FHIR artifacts (such as Resources, Elements, etc.) Prerequisite This guide assumes you installed the software as documented in CIMPL SetUp and Installation , and have at least reviewed the Hello World , and CIMPL In-Depth tutorials. If you already have installed SHR-CLI, make sure you have the latest version installed. Table of Contents CIMPL Authoring Guide Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Using CIMPL to Create FHIR-based Models Logical Model Model Folder Structure and Source Control Configuration File Namespace Class File Map File Value Set File Content Profile File Front Matter FHIR Examples Compile the CIMPL Model Publish the FHIR IG Support Using CIMPL to Create FHIR-based Models CIMPL is designed to be modular and extensible, allowing for the reuse of other logical models, and inheritance from those models. The figure below illustrates this notion. Model key: Gray: CIMPL data types Primitives Light blue: ObjectiveFHIR (OBF) models Dark green: models created using CIMPL, leveraging OBF Light yellow: mCode model, constrains and extends oncoCore, leverages OBF Tan: models that constrain and extend mCode Dark blue: FHIR resources and profiles CIMPL allows the modeling author to represent FHIR profiles in one of two ways: Define the model specific resource attributes you need using FHIR resources or profiles as a base ( clean slate ). In this approach, the modeling author already knows the FHIR resources or profiles to customize, and defines the element constraints or extensions in the new FHIR profile. Leverage CIMPL's ObjectiveFHIR (OBF) base FHIR models - In this approach, the modeling author defines their FHIR profile and specifies a Parent class from the ObjectiveFHIR User Guide elements. Each modeling approach has advantages and disadvantages. The CIMPL clean slate authoring approach might be beneficial when prototyping models containing only a small number of new profiles with minimal changes from base FHIR. However, as the number of customizations increases, maintenance becomes more cumbersome and difficult to keep consistent between FHIR profiles. On the other hand, using OBF FHIR models has significant benefits which include but are not limited to: saves the modeling author time in mapping common elements to their equivalent FHIR attribute. ensures consistency in the representation of commonly used attributes in different FHIR resources. The user must however invest time to understand the OBF logical model. Also, OBF does not comprehensively support all FHIR resources, especially the new ones in R4 with a low maturity level. Logical Model Start by understanding the model you want to document in CIMPL, and its relationship to either base FHIR resources and profiles, or to OBF. Keeping in mind that CIMPL is primarily a way to create logical models with the capability to model-once, translate-to-many , the modeling author should consider requirements-gathering and high level modeling steps. While one approach is proposed below, the modeling author is not limited to following these steps and might find better approaches to creating detailed clinical models. Define the use cases behind the creation of a model. Create a high-level conceptual model which addresses your defined use case and can be easily understood by both technical and clinical communities. Create a data dictionary listing the data elements, cardinality, and potential value sets involved if the data type is a coded element. This provides a convenient summary for implmenters presented in a way that can be understood by non-technical subject matter experts involved in defining the use cases. Start documenting your model with CIMPL. Model Folder Structure and Source Control Create a folder/directory to contain all files you create for the model. If you are modeling with a distributed team, you should consider using a source control system for you CIMPL files. CIMPL In-Depth Tutorial Configuration File A configuration file sets parameters to drive IG creation. By declaring optional parameters, your IG may include model documentation, a graphical view of the model, examples, or a data dictionary. These sections are automatically generated, are not required to include in the IG, but provide valuable information to IG consumers. The data dictionary export might require manual adjustments before the IG is published. Review this document to make sure it meets your needs. CIMPL Tooling Reference Guide Namespace Each model must define a namespace - this differentiates your model artifacts from others. CIMPL Language Reference Guide Class File The Class file documents your model. Decide if you need to import any namespaces (e.g. OBF). Create your Class file with namespaces to import, and Entry , Property , Abstract and Element declarations. CIMPL Language Reference Guide Map File Create a Map file if your model added properties beyond any inherited models. Map the model specific properties to either FHIR resource/profile elements, or OBF. CIMPL Language Reference Guide Value Set File Create this file when you need to constrain an Element Value of concept in the Class file and there is not an existing value set to reference. To avoid redundant value sets, try to find an existing value set that fits your use case. CIMPL Language Reference Guide Content Profile File Create a Content Profile file if there are properties in your model that are critical to IG compliance and must be supported. Any inerited model properties that are not already defined as MustSupport are listed in the same file. CIMPL Tooling Reference Guide Front Matter Introductory text and possibly detailed text is required for IG readers and implementers to understand the background and intended use of your IG. Create this information and declare the location in the Configuration file. Reviewing a published IG might help you structure this material. CIMPL Tooling Reference Guide FHIR Examples A FHIR IG can be generated without examples, however it is recommended to include examples. The FHIR IG generation process requires that an examples folder/directory be defined in the Configuration file. The folder may be empty. CIMPL Tooling Reference Guide Compile the CIMPL Model This step runs a syntax check on the Class, Map and Value Set files and prepares files for IG generation. Errors may be issued from this step. CIMPL Language Reference Guide Publish the FHIR IG The final step in the IG creation process is to run the FHIR IG Publisher . This tool is maintained and owned by HL7 FHIR. By default, the FHIR IG Publisher performs validation checks on the StructureDefinition of specified FHIR profiles, value sets, and examples which reference any base resources or FHIR profiles. An output of these checks are found in the CIMPL output, qa.html . CIMPL Language Reference Guide Support Questions on using CIMPL and its toolchain (SHR-CLI) can be addressed on the HL7 Zulip chat channel #cimpl If you find an issue you can't resolve, or have a question, report it on one of two JIRA projects: Issues related to running the CIMPL SHR-CLI compiler, configuration files, or generating the FHIR Implementation Guide (IG): https://standardhealthrecord.atlassian.net/projects/CIMPL/issues Issues related to CIMPL base classes (Objective FHIR): https://standardhealthrecord.atlassian.net/projects/SHRM/issues","title":"CIMPL Authoring Guide"},{"location":"cimpl6Authoring/#cimpl-authoring-guide","text":"","title":"CIMPL Authoring Guide"},{"location":"cimpl6Authoring/#preface","text":"","title":"Preface"},{"location":"cimpl6Authoring/#purpose-of-this-document","text":"This document provides a step-by-step guide to generate an HL7 FHIR implementation guide (IG) starting with documenting a model using CIMPL. The details about how to accomplish each step are in the CIMPL Language Reference Guide and CIMPL Tooling Reference Guide . Links to these documents are provided in each section.","title":"Purpose of this Document"},{"location":"cimpl6Authoring/#intended-audience","text":"The CIMPL Authoring Guide is targeted to any person comfortable with using software developers or people comfortable with programming languages. Familiarity with FHIR is helpful as the tutorial references FHIR artifacts (such as Resources, Elements, etc.)","title":"Intended Audience"},{"location":"cimpl6Authoring/#prerequisite","text":"This guide assumes you installed the software as documented in CIMPL SetUp and Installation , and have at least reviewed the Hello World , and CIMPL In-Depth tutorials. If you already have installed SHR-CLI, make sure you have the latest version installed.","title":"Prerequisite"},{"location":"cimpl6Authoring/#table-of-contents","text":"CIMPL Authoring Guide Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Using CIMPL to Create FHIR-based Models Logical Model Model Folder Structure and Source Control Configuration File Namespace Class File Map File Value Set File Content Profile File Front Matter FHIR Examples Compile the CIMPL Model Publish the FHIR IG Support","title":"Table of Contents"},{"location":"cimpl6Authoring/#using-cimpl-to-create-fhir-based-models","text":"CIMPL is designed to be modular and extensible, allowing for the reuse of other logical models, and inheritance from those models. The figure below illustrates this notion. Model key: Gray: CIMPL data types Primitives Light blue: ObjectiveFHIR (OBF) models Dark green: models created using CIMPL, leveraging OBF Light yellow: mCode model, constrains and extends oncoCore, leverages OBF Tan: models that constrain and extend mCode Dark blue: FHIR resources and profiles CIMPL allows the modeling author to represent FHIR profiles in one of two ways: Define the model specific resource attributes you need using FHIR resources or profiles as a base ( clean slate ). In this approach, the modeling author already knows the FHIR resources or profiles to customize, and defines the element constraints or extensions in the new FHIR profile. Leverage CIMPL's ObjectiveFHIR (OBF) base FHIR models - In this approach, the modeling author defines their FHIR profile and specifies a Parent class from the ObjectiveFHIR User Guide elements. Each modeling approach has advantages and disadvantages. The CIMPL clean slate authoring approach might be beneficial when prototyping models containing only a small number of new profiles with minimal changes from base FHIR. However, as the number of customizations increases, maintenance becomes more cumbersome and difficult to keep consistent between FHIR profiles. On the other hand, using OBF FHIR models has significant benefits which include but are not limited to: saves the modeling author time in mapping common elements to their equivalent FHIR attribute. ensures consistency in the representation of commonly used attributes in different FHIR resources. The user must however invest time to understand the OBF logical model. Also, OBF does not comprehensively support all FHIR resources, especially the new ones in R4 with a low maturity level.","title":"Using CIMPL to Create FHIR-based Models"},{"location":"cimpl6Authoring/#logical-model","text":"Start by understanding the model you want to document in CIMPL, and its relationship to either base FHIR resources and profiles, or to OBF. Keeping in mind that CIMPL is primarily a way to create logical models with the capability to model-once, translate-to-many , the modeling author should consider requirements-gathering and high level modeling steps. While one approach is proposed below, the modeling author is not limited to following these steps and might find better approaches to creating detailed clinical models. Define the use cases behind the creation of a model. Create a high-level conceptual model which addresses your defined use case and can be easily understood by both technical and clinical communities. Create a data dictionary listing the data elements, cardinality, and potential value sets involved if the data type is a coded element. This provides a convenient summary for implmenters presented in a way that can be understood by non-technical subject matter experts involved in defining the use cases. Start documenting your model with CIMPL.","title":"Logical Model"},{"location":"cimpl6Authoring/#model-folder-structure-and-source-control","text":"Create a folder/directory to contain all files you create for the model. If you are modeling with a distributed team, you should consider using a source control system for you CIMPL files. CIMPL In-Depth Tutorial","title":"Model Folder Structure and Source Control"},{"location":"cimpl6Authoring/#configuration-file","text":"A configuration file sets parameters to drive IG creation. By declaring optional parameters, your IG may include model documentation, a graphical view of the model, examples, or a data dictionary. These sections are automatically generated, are not required to include in the IG, but provide valuable information to IG consumers. The data dictionary export might require manual adjustments before the IG is published. Review this document to make sure it meets your needs. CIMPL Tooling Reference Guide","title":"Configuration File"},{"location":"cimpl6Authoring/#namespace","text":"Each model must define a namespace - this differentiates your model artifacts from others. CIMPL Language Reference Guide","title":"Namespace"},{"location":"cimpl6Authoring/#class-file","text":"The Class file documents your model. Decide if you need to import any namespaces (e.g. OBF). Create your Class file with namespaces to import, and Entry , Property , Abstract and Element declarations. CIMPL Language Reference Guide","title":"Class File"},{"location":"cimpl6Authoring/#map-file","text":"Create a Map file if your model added properties beyond any inherited models. Map the model specific properties to either FHIR resource/profile elements, or OBF. CIMPL Language Reference Guide","title":"Map File"},{"location":"cimpl6Authoring/#value-set-file","text":"Create this file when you need to constrain an Element Value of concept in the Class file and there is not an existing value set to reference. To avoid redundant value sets, try to find an existing value set that fits your use case. CIMPL Language Reference Guide","title":"Value Set File"},{"location":"cimpl6Authoring/#content-profile-file","text":"Create a Content Profile file if there are properties in your model that are critical to IG compliance and must be supported. Any inerited model properties that are not already defined as MustSupport are listed in the same file. CIMPL Tooling Reference Guide","title":"Content Profile File"},{"location":"cimpl6Authoring/#front-matter","text":"Introductory text and possibly detailed text is required for IG readers and implementers to understand the background and intended use of your IG. Create this information and declare the location in the Configuration file. Reviewing a published IG might help you structure this material. CIMPL Tooling Reference Guide","title":"Front Matter"},{"location":"cimpl6Authoring/#fhir-examples","text":"A FHIR IG can be generated without examples, however it is recommended to include examples. The FHIR IG generation process requires that an examples folder/directory be defined in the Configuration file. The folder may be empty. CIMPL Tooling Reference Guide","title":"FHIR Examples"},{"location":"cimpl6Authoring/#compile-the-cimpl-model","text":"This step runs a syntax check on the Class, Map and Value Set files and prepares files for IG generation. Errors may be issued from this step. CIMPL Language Reference Guide","title":"Compile the CIMPL Model"},{"location":"cimpl6Authoring/#publish-the-fhir-ig","text":"The final step in the IG creation process is to run the FHIR IG Publisher . This tool is maintained and owned by HL7 FHIR. By default, the FHIR IG Publisher performs validation checks on the StructureDefinition of specified FHIR profiles, value sets, and examples which reference any base resources or FHIR profiles. An output of these checks are found in the CIMPL output, qa.html . CIMPL Language Reference Guide","title":"Publish the FHIR IG"},{"location":"cimpl6Authoring/#support","text":"Questions on using CIMPL and its toolchain (SHR-CLI) can be addressed on the HL7 Zulip chat channel #cimpl If you find an issue you can't resolve, or have a question, report it on one of two JIRA projects: Issues related to running the CIMPL SHR-CLI compiler, configuration files, or generating the FHIR Implementation Guide (IG): https://standardhealthrecord.atlassian.net/projects/CIMPL/issues Issues related to CIMPL base classes (Objective FHIR): https://standardhealthrecord.atlassian.net/projects/SHRM/issues","title":"Support"},{"location":"cimpl6LanguageReference/","text":"CIMPL 6.0 Language Reference Preface CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a specially-designed language for defining clinical information models. It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles, extensions and implementation guides (IG). Because it is a language , written in text statements, CIMPL encourages distributed, team-based development using conventional source-code control tools such as Github. CIMPL provides tooling that enables you to define a model once, and publish that model to multiple versions of FHIR. Purpose of this Document This document is a comprehensive guide to the CIMPL language, covering the syntax used to specify clinical models, value sets, and mappings to FHIR. Intended Audience The CIMPL Language Reference is targeted to the users of CIMPL, involved with creating or reviewing models expressed in the CIMPL language. Prerequisite This guide assumes you have: Installed the latest version of the SHR-CLI software as documented in CIMPL SetUp and Installation (preferably installed in the ~/cimpl/shr-cli directory). A text editor to create your CIMPL files (preferably VSCode with the vs-code-language-cimpl extension, but not required). Reviewed the In-Depth Tutorial . Table of Contents CIMPL 6.0 Language Reference Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Fundamentals Versioning File Types Classes Namespaces Naming Conventions File Names Namespace Names Class Names Fully Qualified Names Value Set Names Local Code Names Language Basics Whitespace Comments Reserved Words Primitives Concept Codes Keywords Abstract CodeSystem Concept Description Element Entry Grammar Group Namespace Parent Path Property Uses Value ValueSet CIMPL Paths Dot Notation Entries Terminate Paths Bracket Notation for Value Choices Path Example Constraints Cardinality Constraint Fixed Value Constraint Append Constraint Substitute Constraint Value Set Binding Constraint Value Set Binding in Elements Value Set Binding in Entry, Abstract, or Group Includes Constraint Only Constraint Class File Class File Example Class File Header Class Definitions Class Type and Name Declaration Properties and Values Naming Recommendations Value Set File Value Set File Example Value Set File Header Value Set Definition Explicit Codes Locally Defined Value Set Implicit Codes Map File Inheritance of Mapping Rules Mapping CIMPL Primitives to FHIR Map File Example Map File Header Setting the Mapping Target Mapping Properties Mapping to References Placement of Extensions Special Mapping Statements fix constrain Slicing Slicing Rules Declaring a Discriminator (slice on, slice on type) Slice Strategy Moving the Slice Location (slice at) Slicing Examples Appendix A: Changes from CIMPL 5.x Fundamentals Versioning CIMPL follows the semantic versioning convention (MAJOR.MINOR.PATCH). MAJOR: A major release has significant new functionality and potentially, grammar changes or other non-backward-compatible changes. MINOR: Contains new or modified features, while maintaining backwards compatability within the major version. PATCH: Contains minor updates and bug fixes, while maintaining backwards compatability within the major version. CIMPL is currently on major version 6. For a full change log, see the Release Notes . File Types Model information in CIMPL is stored in the following three file types: Class files (.txt): contain definitions of CIMPL classes. Value Set files (.txt): contain definitions of value sets defined in the namespace. Map files (.txt): contain information on how the CIMPL classes relate to FHIR resources, profiles, and elements. Each namespace will typically have one or more class files, and if needed, a value set and map file. Classes CIMPL models consist of classes. Classes define clinical information at some granularity. Classes can be combined in various ways (composition and specialization) to create meaningful structures. Namespaces CIMPL organizes information into namespaces. Namespaces are used to organize code and classes into logical collections and to prevent name collisions. Naming Conventions File Names File names must begin with lower case and typically include the namespace: Class files: namespace.txt or namespace-something.txt Value Set files: namespace-vs.txt or namespace-something-vs.txt Mapping files: namespace-map.txt or namespace-something-map.txt Any periods in the namespace should be replaced by dashes. For example, a namespace called odh.occupation , the recommended value set file name is odh-occupation-vs.txt . The something is useful when you want to break up the contents of a single namespace into multiple files, for example: obf-action.txt obf-finding.txt Note: obf stands for Objective FHIR , a set of classes provided with CIMPL that can help you create FHIR profiles. For more information, see Objective FHIR Overview Additional files for configuring and producing FHIR implementation guides (IGs), and their naming conventions include: Configuration files: ig-igname-config.json Content profile files: ig-igname-cp.json IG examples: ignameExampleName.json IG HTML pages: anyName.html Namespace Names Best practice is to follow the naming convention pattern of organization.domain or project.domain (followed by subdomains if necessary). Example Purpose obf.lab Laboratory profiles belonging to Objective FHIR odh Occupational Data for Health onco.core Core namespace for oncology-related profiles Class Names Elements, Groups and Entries are conventionally defined in PascalCase . For example: * Element: DetectionTime * Group: Dosage * Entry: AdverseEvent Note: Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter. Fully Qualified Names CIMPL does not support duplicate class names within a single namespace. However, the same name may occur in different namespaces. In the case of naming collisions due to an included namespace in Uses , you have to refer to the class by its fully qualified name (FQN). The FQN is a combination of the element's namespace and its declared name (through concatenation delimited by a period). For example, the element CancerCondition in the namespace onco.core has the following FQN: onco.core.CancerCondition FQNs are only required in case of naming collisions between namespaces. Value Set Names Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: Value Set names must begin with an uppercase letter. Local Code Names Within a custom value set, the individual codes (denoted by # symbol) are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or Other Radiation Source\" #swimming_pool \"Swimming Pool\" Language Basics Whitespace Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 6.0 Namespace: myExampleNamespace is equivalent to this: Grammar: DataElement 6.0 Namespace: myExampleNamespace Comments CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */ Reserved Words CIMPL has a number of reserved words and phrases that are part of CIMPL's grammar (e.g., boolean , or , from , maps to ). For a complete list of reserved words, refer to the ANTLR4 grammar . Primitives Primitives are data types, distinguished by starting with lower case letter. CIMPL defines the following primitive data types. With the exception of concept (a simplified representation of code, Coding, and CodeableConcept), the primitive types in CIMPL align with FHIR: concept boolean integer string decimal uri base64Binary instant date dateTime time oid id markdown unsignedInt positiveInt xhtml Note: CIMPL does not have an explicit \"Reference\" type. References are determined during the mapping process. Concept Codes CIMPL uses a single primitive type, concept to represent coded terms from controlled vocabularies. A concept combines three elements: code system, code, and optional display text. The grammar for specifying concepts is: SYSTEM#code \"Display text\" For example: SCT#363346000 \"Malignant neoplastic disease (disorder)\" ICD10CM#C004 \"Malignant neoplasm of lower lip, inner aspect\" The SYSTEM is an alias for a canonical URI that represents a controlled vocabulary. Aliases must be declared in the file header using the CodeSystem keyword . You cannot use the canonical URI directly in the concept grammar. Unlike FHIR, CIMPL does not differentiate between code, Coding, and CodeableConcept. See Mapping Concept Codes for information on how CIMPL maps concept to these FHIR types. Note: Future versions of CIMPL will expand concept to include the code system version. Keywords Keywords are used to make various declarations. Keywords always appear at the beginning of a line and are followed by a colon. Keyword Summary: Keyword Purpose File Type(s) Abstract Declare an non-instantiable class Class CodeSystem Define a code system alias Class, Value Set Concept Express the meaning of a class Class Description Provide a human-readable description Class, Value Set Element Declare lowest-level (elemental) model building block Class Entry Declare a stand-alone class Class Grammar Define how a file should be parsed All Group Declare mid-level, non-stand-alone model building block Class Namespace Associate a file with a namespace All Parent Specify inheritance Class Path Alias long URLs Class, Value Set Property Define an attribute in a class Class Uses Import namespace(s) Class Value Define data type(s) of Elements Class ValueSet Define a value set Value Set Abstract The Abstract keyword is used to declare a new Abstract class. Abstract classes are identical to Entries, except they are not instantiable. For details, see Class File . Example: Abstract: ActionStatement CodeSystem The CodeSystem keyword provides an alias or shorthand for the canonical URI of a code system. You must define a code system alias before you can use codes from that system in constraints or value sets. By convention, the alias should be be UPPER CASE, although the tooling does allow for numbers and hyphens after the first upper case letter. Examples: CodeSystem: LNC = http://loinc.org CodeSystem: SCT = http://snomed.info/sct Concept The Concept keyword (not to be confused with the concept primitive ) establishes the meaning of a class in terms of a code (or codes) from controlled vocabularies. Assigning a concept allows the meaning of the class to be understood without inferring it from the class name. If multiple concept codes are used, they should appear as a comma-separated list. This keyword is optional. Examples: Concept: MTH#C3858779 \"Security classification\" Description The Description keyword is used for a narrative that defines the namespace, class, or value set. Example: Description: \"Oncology data elements that broadly apply to most cancer cases.\" Note: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.) Element The Element keyword is used to declare a new class of type Element, the lowest-level building block in CIMPL. For details, see Class File . Example: Element: EvidenceType Entry The Entry keyword is used to declare a new stand-alone class, analogous to a Resource or Profile in FHIR. For details, see Class File . Example: Entry: GenomicsReport Grammar The Grammar keyword defines how the file is to be parsed. The grammar declaration must be the first line in each CIMPL file. File Type Required First Line Current Version # Class Grammar: DataElement #.# 6.0 Value Set Grammar: ValueSet #.# 5.1 Map Grammar: Map #.# 5.1 Note: no space in ValueSet The version details the MAJOR and MINOR version of the grammar the file was written for. The grammar version is typically not the same as the CIMPL release. Generally, the major version of the Grammar matches the major version number of CIMPL, however, at the time of the CIMPL 6.0 release, the ValueSet and Map grammar remain at 5.1. Group The Group keyword is used to declare a building block comprised of one or more properties, similar to a complex data type in FHIR. For details, see Class File . Example: Group: Dosage Namespace The Namespace keyword defines the association of the file with a namespace, and is required in DataElement , ValueSet and Map files. The namespace can be any number of lowercase period-delimited words. Examples: Namespace: odh Namespace: onco.core Note: While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens. Parent Through the Parent keyword, CIMPL provides a mechanism for basing a class on another class, the child inheriting all properties and constraints from the parent. The child class can then extend information inherited from the parent by adding additional properties and applying additional constraints. Additionally, mappings are inherited alongside properties. At most one parent class can be specified. The Parent declaration is optional There are restrictions on which building blocks can inherit from other building blocks. The rules can be summarized as like inherits from like : Building Block Can Inherit From Element Element Group Group Entry Abstract or Entry Abstract Abstract Note: Although the CIMPL 6.0 tooling does not currently enforce these inheritance rules, they will be enforced in future releases. You are strongly encouraged to comply to these rules, and refactor any definitions ported from CIMPL 5.x that do not comply. Example: Parent: LaboratoryObservation Path The Path keyword allows for abbreviations of long URLs. This functionality is completely optional, but it is provided to make authoring easier. By convention, the alias should be be an all UPPER CASE word, although the tooling does allow for numbers and hyphens after the first letter. Example: Path: FHIR = http://hl7.org/fhir/ValueSet Property Classes based on Group, Entry, and Abstract are composed of one or more properties (called fields or attributes in object-oriented programming). A property can be any Element, Group, or Entry, but never a primitive. Each property must have a specified cardinality range, represented as min..max , indicating the number of repeats of the property. The Property keyword cannot be used in Elements. In the following example, StudyArm has four properties: Name , Type , Comment and ResearchStudy . Name is singular and required, Type is optional and repeating, and Comment is singular and optional: Group: StudyArm Description: \"Refers to participant(s) in a clinical trial assigned to receive specific interventions according to a protocol.\" Property: Name 1..1 Property: Type 0..* Property: Comment 0..1 Property: ResearchStudy 1..1 A property that refers to an Entry (such as ResearchStudy, above) is implicitly a reference (pointer) to an instance of that Entry, rather than implying the Entry is \"in-lined\" into the class. Note: CIMPL 5.0 Grammar use of the keyword ref() is now obsolete. Uses The Uses keyword appears in the Class file and provides a comma-separated list of the namespaces imported to the current namespace. This keyword allows you to use the classes and value sets defined in other namespaces. The list order has no effect. Examples: Uses: obf.datatype Uses: obf.datatype, obf, onco.core Value Value represents the data type(s) an Element can accept. This keyword can only be used when defining an Element. Each Element must have exactly one Value , although the value itself can be a choice of several data types. Value choices can be Primitives , Elements , Groups , or Entries . A value may be inherited and constrained in the child class. Examples: Element: DetectionTime Description: \"The date on which the condition was first observed.\" Value: dateTime Element: ExpectedPerformanceTime Description: \"When an action should be performed.\" Value: dateTime or TimePeriod or Timing Element: SubstanceOrCode Description: \"A code or substance reference identifying the ingredient.\" Value: concept or Substance or Medication Although in general, constraints cannot be applied to a property or value at the same time the item is defined, you are allowed to bind a value set to a concept value choice at the same time the value is defined, as follows: Element: IsPrimaryTumor Description: \"Whether the tumor is the original or first tumor in the body, for a particular cancer.\" Value: concept from YesNoUnknownVS (required) For more information on binding, see Value Set Binding Constraint . Note: CIMPL 5.0 Grammar associating a cardinality to a Value is now obsolete. ValueSet Defines the name of a value set defined inside CIMPL (references to external value sets are also allowed). By convention, all value sets should be Pascal case, start with the name of the corresponding concept-type Element that is being bound to the value set, and end with VS . Example: ValueSet: ProposedStatusVS CIMPL Paths CIMPL provides grammar that allows you to refer to any part of a CIMPL class, regardless of nesting. This section outlines CIMPL Path Grammar, which is used in constraints and mapping . Dot Notation Dot notation is used to denote nested properties. The path lists the properties in order, separated by a dot (.) For example, if Patient has a ContactPoint , and ContactPoint has a Priority , then the path to Priority is Patient.ContactPoint.Priority . Entries Terminate Paths An Entry can appear in a path only as its final element. Paths represent nested containment within one class, and Entries are independent objects. Paths cannot \"hop\" from one Entry to another. For example, Procedure has a Patient property, and while Procedure.Patient is a valid path, Procedure.Patient.gender is not. The former path can be used to set the cardinality of Patient within the Procedure class, but the latter would (illegally) constrain an attribute within Patient from inside Procedure . Bracket Notation for Value Choices Values can offer a choice of data types . Bracket notation is used to refer to a particular value choice. Bracket notation must always be used when an Element is part of a CIMPL path. How value choices appear in paths depends on whether the path appears with an Element definition or not. Inside an: Refer to the Value choices as: Element Value[choice] Entry or Group ElementName[choice] Example: Entry: Procedure Property: Priority 0..1 Priority[concept] = SCT#394849002 \"High Priority\" // not Value[concept] Element: Priority Value: integer or concept Value[concept] from PriorityVS (required) // not Priority[concept] Note: The requirement in CIMPL 6.0 to use bracket notation even when the value has only one choice is a change from CIMPL 5. Path Example Entry: Procedure Property: Landmark Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Group: Location Description: \"Location of the landmark\" Property: Code 0..1 Property: Laterality 0..1 Property: Orientation 0..1 Element: Distance Description: \"How far the body location of interest is from the given landmark.\" Value: Quantity Element: Direction Description: \"The direction from the landmark to the body location of interest.\" Value: ClockFaceDirection or AnatomicalDirection Element: ClockFaceDirection Description: \"A direction indicated by o'clock position or degrees relative to 12 o'clock.\" Value: concept or Angle Group: Quantity Description: \"A quantity with units.\" Property: Number 0..1 Property: Comparator 0..1 Property: Units 0..1 This example assumes all paths begin at Procedure, which is an Entry, but the same patterns would apply if the path started elsewhere, for example, at Landmark. Path to Path Direction Procedure.Landmark.Direction Laterality Procedure.Landmark.Location.Laterality ClockFaceDirection Procedure.Landmark.Direction[ClockFaceDirection] Angle Procedure.Landmark.Direction[ClockFaceDirection][Angle] Units Procedure.Landmark.Distance[Quantity].Units A reliable method to create a CIMPL path is to first view it as a dot path, then bracket any part of the path that is a Value, and finally, remove the dot before each left (open) bracket. Here's an example of that process, for the path from Landmark to Units: Find the path: Landmark to Distance , Distance to Quantity , Quantity to Units . Reduce to dot path: Landmark.Distance.Quantity.Units Bracket each Value: Landmark.Distance.[Quantity].Units Remove dot before left (open) bracket: Landmark.Distance[Quantity].Units Constraints Constraints are a way to shape a general model for a particular purpose. Properties, values, and value choices can be constrained. Constraint targets can be be top-level or deeply nested (the latter referred to using CIMPL paths ), inherited or locally-defined. Unlike keyword declarations, constraint statements do not begin with a keyword. Most constraint statements have three parts: The subject of the constraint A reserved word or phrase indicating the type of constraint The constraint value being applied Here are several examples of this pattern: Example Subject Reserved word Value applied IsPrimaryTumor = true IsPrimaryTumor = true Specimen substitute TumorSpecimen Specimen substitute TumorSpecimen BodyLocation from BodyLocationVS BodyLocation from BodyLocationVS LanguageUsed 0..1 LanguageUsed (implicit) 0..1 Here is a summary of supported constraints: To do this.. Use this Keyword or Symbol Applies to Narrow cardinality {min}..{max} Property Assign a fixed value = Property or Value[Choice] Append a fixed value to an array += Array Property Narrow a data type substitute Property or Value[Choice] Bind a value set from Property or Value[Choice] Slice an array includes Array Property Narrow choices for a value only Value Cardinality Constraint Cardinality defines the number of repeats that can exist for a Property. Cardinality is specified using FHIR syntax, {min}..{max}, where the first integer indicates the minimum repeats (0 implying optional), and the second digit expresses the upper bound on the number of repeats. To express no upper bound, a * is used. When constraining cardinality, you can only narrow the previously declared cardinality. The cardinality constraint only applies to properties. Declaration Constraint Subsequent Constraint Property: LanguageUsed 0..* LanguageUsed 0..1 LanguageUsed 0..0 Property: GovernmentIssuedID 0..* GovernmentIssuedID 1..* GovernmentIssuedID 1..1 Property: Status 1..1 Status 0..1 invalid Note: By constraining a property to 0..0, you effectively remove the property. Use 0..0 with caution, because if an instance does include that property, the instance will fail validation and may be rejected. Fixed Value Constraint The = operator fixes an Element's value to a specific concept, boolean, string, integer, decimal, or URL. The assigned value must be consistent with the defined data type, and is always a primitive. Example Syntax Fix a code to an Element ObservationCode = LNC#82810-3 Fix a boolean value to an Element IsPrimaryTumor = true Fix a code to an Element's Value Value[concept] = SCT#233613009 \"Pneumonia\" Fix the units associated with a Quantity Value Choice Value[Quantity].Units = UCUM#cm Notes: Bracket notation must always be used when applying a constraint to a value choice, even if the value has only one choice . CIMPL allows fixed concept values to be overridden in child classes. Although this seems to violate the notion that constraints should get progressively tighter in subclasses, it is necessary when narrowing the meaning of a class characterized by a concept code. For example, the class Pneumonia , with fixed code, SCT#233604007 , may have a child, Fungal Pneumonia , with fixed code SCT#233613009 , the latter overriding the former. CIMPL will assume, without checking, that the code describing the child class has more constrained semantics than the code it replaces. Fixing numerical types and strings (including URLs) is not yet supported, although this feature is planned. If you only need to fix a code in one particular mapping (one version of FHIR, for example), do so using the fix keyword in the mapping file and not as a constraint. Append Constraint The append += operator appends a fixed concept to a property array whose value is concept . You can use the += operation repeatedly on the same array, limited only be the cardinality of the array. The append operator can only be applied to repeating properties. For example, use += to insert a specific Category value into an array of categories. Example Syntax Insert \"Behavior\" into Category array Category += LNC#54511-1 \"Behavior\" Add \"Social History\" to same array Category += OBSCAT#social-history \"Social History\" Note: Appending other data types is not yet supported, although this feature is planned. Substitute Constraint The substitute keyword constrains value data type of an element. The new data type that is substituted for the original must be a subclass of the original data type. Example Syntax Constrain the element Specimen to be a TumorSpecimen Specimen substitute TumorSpecimen note: TumorSpecimen must be a subclass of Specimen Constrain a Value choice of type Quantity to SimpleQuantity Value[Quantity] substitute SimpleQuantity note: SimpleQuantity is a subclass of Quantity Value Set Binding Constraint Binding is the process of associating an Element with a set of possible values. Binding uses the keyword from . The object of a binding must be an Element whose Value is a concept . The value set that is being bound can be a value set defined in a CIMPL Value Set file, or a canonical URL external to CIMPL. CIMPL uses the binding strengths defined in FHIR , namely: required (strongest) indicates that the code must come from the specified value set. extensible indicates that the code must come from the specified set if the value set contains a relevant code ; otherwise a code outside the value set may be chosen. preferred indicates that the code should ideally come from the specified value set, but codes outside the value set may also be chosen. example (weakest) indicates that the code may come from anywhere; the specified value set is for example purposes only. The following rules apply to binding in CIMPL: If no binding strength is specified, the binding is assumed to be required . When further constraining an existing binding, the binding strength can stay the same or be made tighter (e.g., replacing an preferred binding with an extensible or required binding), but never loosened. Constraining may leave the binding strength the same and change the value set instead. However, certain changes permitted in CIMPL may violate FHIR profiling principles . In particular, FHIR will permit a required value set to be replaced by another required value set only if the codes in the new value set are a subset of the codes in the original value set. For extensible bindings, the new value set can contain codes not in the existing value set, but additional codes SHOULD NOT have the same meaning as existing codes in the base value set. The syntax for binding is different depending on whether the binding is in an Element or another class (Abstract, Entry, or Group). Value Set Binding in Elements The following syntax is allowable when binding inside an Element: Value from <value set reference> Value from <value set reference> (binding strength) Value[choice] from <value set reference> (binding strength) For example: Value from TerminationReasonVS Value from http://hl7.org/fhir/ValueSet/condition-clinical (preferred) Value[AgeGroup] from AgeGroupVS (extensible) Note: You must explicitly specify which value choice the binding applies to if the value has multiple choices (the third pattern, above). Value Set Binding in Entry, Abstract, or Group The following syntax is allowable when binding inside an Entry, Abstract, or Group: <Property> from <value set reference> <Property> from <value set reference> (binding strength) For example: ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical ReasonCode from ReasonCodeVS (extensible) BodyLocation from BodyLocationVS (preferred) Includes Constraint The includes constraint is used to specify that a repeating property (array) should contain a certain class or classes. FHIR refers to this as slicing . In CIMPL, slicing is accomplished by declaring that an array includes certain types of components. The includes statement has several requirements: The classes included in the array must conform to the data type of the array. For example, if the array is Identifier 0..* , the classes included in the array must inherit from Identifier. Cardinality of each inclusion must be specified, and must fit the cardinality of the array. For example, if the array property has a finite maximum cardinality, you cannot include an element with cardinality 0..*. The keyword includes is repeated for each item the array should contain. The includes constraint does not apply to Element Values. Here is an example: Property: Measurement 0..* // the array property ... Measurement includes TumorLength 1..1 includes TumorWidth 0..1 includes TumorDepth 0..1 Note: TumorLength, TumorWidth, and TumorDepth all must inherit from Measurement, because the members of the Measurement array must be Measurements. Here is another example: Property: Identifier 1..* // the array property ... Identifier includes NationalProviderIdentifier 0..1 includes TaxIdentificationNumber 0..1 In this case, both NationalProviderIdentifier and TaxIdentificationNumber must have Identifier as their parent. Note: When using includes , special mapping syntax is required. See Slicing . Only Constraint Values can have multiple data types. Use the only constraint in an Element to narrow the choice of data types. The only constraint can only be applied to a value that has multiple choices. The grammar of only constraints varies depending on whether the constraint appears in an Element, or another class type. | In the class... | Use the grammar... | |----------|---------|--------| | Element | Value only <datatype> | | Element | Value only <datatype1> or <datatype2> or <datatype3> etc. | | Entry or Group | <Property> only <datatype> note : this is allowed only for a single datatype; to constrain to multiple choices, use the substitute constraint (see Example 2, below) | Example 1: Multiple value choices narrowed to a single choice Element: Priority Value: integer or concept Element: IntegerPriority Parent: Priority Value only integer // Both of the following are legal and have the same effect: Group: Alarm-One Property: Priority Priority only integer Group: Alarm-Two Property: Priority Priority substitute IntegerPriority Example 2: Multiple value choices narrowed to smaller number of choices Element: Answer Description: \"A potential answer with many different allowed datatypes.\" Value: integer or date or time or string or concept or Resource Element: TemporalAnswer Parent: Answer Description: \"An answer that's either a date or time\" Value only date or time // legal way to reduce multiple choice! Group: QuestionAndAnswer Property: Question // dummy - not defined Property: Answer Group: QuestionWithTemporalAnswer Parent: QuestionAndAnswer Answer substitute TemporalAnswer // NOT: \"Answer only date or time\" and NOT \"Answer only TemporalAnswer\" Class File Class files contain definitions of the information model. Every model defined in CIMPL must have at least one class file. Class File Example Here is an abbreviated example of a class file: Grammar: DataElement 6.0 Namespace: obf.lab Description: \"Profiles of laboratory tests and panels.\" Uses: datatype, obf CodeSystem: LNC = http://loinc.org CodeSystem: UCUM = http://unitsofmeasure.org Abstract: SimpleQuantLabWithRequiredUnits Parent: SimpleQuantitativeLaboratoryObservation Description: \"Laboratory tests that must be reported with units.\" DataValue 1..1 DataValue only QuantityWithRequiredUnits DataAbsentReason 0..0 Group: QuantityWithRequiredUnits Parent: Quantity Description: \"A quantity with that requires a coded unit of measure.\" Units 1..1 Entry: GlobulinMCncPtSerQnCalculatedLabObs Parent: SimpleQuantLabWithRequiredUnits Description: \"Globulin [Mass/\u200bvolume] in Serum by calculation\" Code = LNC#10834-0 \"Globulin [Mass/\u200bvolume] in Serum by calculation\" DataValue[Quantity].Units from EquivalentUnitsVS-g-per-L (required) Class File Header The elements of the class file header are (in order): Grammar (required) Namespace (required) Description (recommended; once per namespace) Uses (optional; as needed) CodeSystem (optional; as needed) Path (optional) For a further description, see Keywords . Note: Uses imports namespaces whose classes can be used as if they were locally defined. However, if a class name in an imported namespace collides with a local class name, you must refer to that element by its fully qualified name . Class Definitions Following the header, the class file contains class definitions. The order of the class definitions does not matter. Each class definition consists of declarations. Follow the links for further explanation of each item: Class Type and Name Declaration (required, must be first) Parent Declaration (optional) Concept Declaration (optional) Description (optional but highly recommended) Property Declarations (for Entry, Abstract and Group), or Value Declaration (for Element) (optional, but typically present) Constraint statements (optional) Class Type and Name Declaration The first line of all class definitions is a keyword representing the type of class, followed by a descriptive name you choose. Class names must be unique within a given namespace. CIMPL provides four class types: Class Description Has... Analogous FHIR Type Element The lowest-level class, representing a property-value pair. Value Element or simple extension Group A class comprised of other classes, specifically, other Groups, Elements, and Entries. Properties Backbone element or complex extension Entry A class representing a group of related information, complete enough to support stand-alone interpretation. Properties Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Properties none Properties and Values When defining classes, bear in mind that: An Element has exactly one Value field and no Property fields The Value field may have more than one choice (using or ) A Property cannot have choices Group , Entry , or Abstract may have multiple Property fields, but no Value These differences are illustrated in this example: Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Element: Direction Description: \"The direction from the landmark to the body location of interest.\" Value: concept from AnatomicalDirectionVS (preferred) Summary: Keyword Appears with How Many Times? Has Cardinality? Has Choices? Can be a... Value Element Exactly Once No Yes (optionally) primitive, Element, Group, or Entry Property Group , Entry , or Abstract Zero or more Yes No Element, Group, or Entry Naming Recommendations All classes in CIMPL, from Element to Entry , are reusable outside of their original context. To promote reuse, try to choose names that are self-explanatory and context-independent. For example, a Property named Text is too vague, whereas DisplayText and InstructionText are more self-explanatory and may be completely understandable when placed into a specific context. However, an overly-specific name like AddressDisplayText could inhibit reuse because it affixes the context of an address to the concept of a display text. Value Set File Value set files are used to define custom value sets and codes when existing value set sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient, and a new value set must be defined. Value Set File Example A (truncated) example value set file is shown below: Grammar: ValueSet 5.1 Namespace: onco.core CodeSystem: SCT = http://snomed.info/sct CodeSystem: ICD10CM = http://hl7.org/fhir/sid/icd-10-cm ValueSet: CancerDiseaseStatusEvidenceTypeVS Description: \"The type of evidence backing up the clinical determination of cancer progression.\" SCT#363679005 \"Imaging (procedure)\" SCT#252416005 \"Histopathology test (procedure)\" SCT#711015009 \"Assessment of symptom control (procedure)\" SCT#5880005 \"Physical examination procedure (procedure)\" SCT#250724005 \"Tumor marker measurement (procedure)\" SCT#386344002 \"Laboratory data interpretation (procedure)\" ValueSet: SecondaryCancerDisorderVS Description: \"Types of secondary malignant neoplastic disease\" Includes codes descending from SCT#128462008 \"Secondary malignant neoplastic disease (disorder)\" ICD10CM#C7B00 \"Secondary carcinoid tumors, unspecified site\" ICD10CM#C7B01 \"Secondary carcinoid tumors of distant lymph nodes\" ICD10CM#C7B02 \"Secondary carcinoid tumors of liver\" ICD10CM#C7B03 \"Secondary carcinoid tumors of bone\" ICD10CM#C7B04 \"Secondary carcinoid tumors of peritoneum\" Value Set File Header Grammar and Namespace are required keywords in a Value Set file header. A CodeSystem declaration is required for every Code System referenced in a value set defined in the Value Set file. For a further description, see Code System Keyword . Value Set Definition Following the header, the Value Set file contains value set definitions. The order of definitions does not matter. Each definition follows a set sequence of declarations. Follow the links for further explanation of each item: Value Set Declaration (required) Description (optional but highly recommended) Code Declarations (optional) Includes Codes statements (optional) Explicit Codes Explicit code declarations are used to add specific codes to a value set. This method of defining a value set is sometimes called extensional . Codes can either be locally-defined, or selected from external code systems, such as ICD10CM#C7B00 , in which C7B00 is an existing code within the ICD10CM code system. If the code is defined locally, the value set name serves as the code system. For the syntax of concept codes, see Concept Codes . Type Example Locally-defined code #proposed \"The proposal has been proposed, but not accepted or rejected.\" Externally-defined code ICD10CM#C7B00 \"Secondary carcinoid tumors, unspecified site\" Locally Defined Value Set Within a custom value set (one specific to an IG), the individual codes (denoted by # symbol) are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or Other Radiation Source\" #swimming_pool \"Swimming Pool\" Implicit Codes Implicit code declarations adds codes to a value set using an expression rather than a list. This allows you to, for example, add all codes from a code system, add all codes descending from a point in a hierarchy (currently, only supported in SNOMED-CT). This method of defining a value set is sometimes called intensional . There are three variants involving the Includes codes phrase: Phrase Example Result Includes codes from Includes codes from MDR Value set contains all codes from MDR code system Includes codes descending from Includes codes descending from SCT#105590001 Value set contains SCT#1055900001 and all codes below it in the SNOMED-CT hierarchy and not descending from Includes codes descending from SCT#363346000 \"Malignant neoplastic disease\" and not descending from SCT#128462008 \"Secondary malignant neoplastic disease\" Value set contains SCT#363346000 and all codes below it in the SNOMED-CT hierarchy, except code SCT#128462008 and all codes below it Map File Map files control how classes defined in CIMPL are expressed as FHIR profiles. Map files are FHIR-version dependent. Currently, you can map to FHIR DSTU 2, STU 3, R4. If you use the supplied Objective FHIR base classes , you many not need to create a map file. Inheritance of Mapping Rules Maps are defined in a series of mapping rules. A powerful feature of CIMPL is that mapping rules are inherited. If your class inherits from a parent class that already is mapped, you do not need to create a new map for your class. However, if you want to specify mappings for a new Property , or override the inherited map, you may do so. The inheritance of mapping rules follows the class hierarchy. If there is no map for a class or attribute, CIMPL tooling automatically looks to the parent class to try and find a mapping. The first mapping rule found will be applied. If no mapping rule is found for a Property defined in CIMPL, a FHIR extension will be created. If no mapping is found for an Entry , that Entry will be mapped to the Basic resource . In general, mapping to Basic is not recommended because it has no inherent semantic meaning for implementers. Mapping CIMPL Primitives to FHIR CIMPL follows somewhat flexible rules on how CIMPL primitives map to FHIR. For example, a unsignedInt in CIMPL can map to an integer type in FHIR (since every unsignedInt is an integer, there is no loss of information). However, mappings that lose information, such as integer in CIMPL to unsignedInt in FHIR, generally will trigger mapping errors. An exception is that CIMPL concept is allowed to map to FHIR code . The following table shows the acceptable mappings between CIMPL and FHIR: CIMPL Primitive Can map to FHIR... concept code, Coding, CodableConcept boolean boolean, code integer integer, Quantity string string decimal decimal uri uri base64Binary base64Binary instant instant date date dateTime dateTime, date, instant time time oid oid id id markdown markdown, string unsignedInt unsignedInt, integer, Quantity positiveInt positiveInt, unsignedInt, integer, Quantity xtml xtml Map File Example The following example demonstrates how the class Dosage, defined in the OBF namespace, maps to the FHIR 4.0 data type with the same name. The second example demonstrates mapping between the OBF MedicationStatement class and the FHIR 4.0 US Core MedicationStatement profile. Grammar: Map 5.1 Namespace: obf Target: FHIR_R4 Dosage maps to Dosage: DoseSequenceNumber maps to sequence InstructionText maps to text InstructionCode maps to additionalInstruction PatientInstruction maps to patientInstruction Timing maps to timing AsNeeded maps to asNeeded[x] AdministrationSite maps to site RouteIntoBody maps to route Method maps to method MaxDosePerPeriod maps to maxDosePerPeriod MaxDosePerAdministration maps to maxDosePerAdministration MaxDosePerLifetime maps to maxDosePerLifetime constrain doseAndRate to 0..1 DoseAndRate.DoseAmount maps to doseAndRate.dose[x] DoseAndRate.DoseRate maps to doseAndRate.rate[x] MedicationStatement maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-medicationstatement: Identifier maps to identifier MedicationBasedOn maps to basedOn MedicationStatementPartOf maps to partOf Status maps to status StatusReason maps to statusReason Category maps to category MedicationCodeOrReference maps to medication[x] SubjectOfRecord maps to subject CareContext maps to context OccurrenceTimeOrPeriod maps to effective[x] StatementDateTime maps to dateAsserted MedicationInformationSource maps to informationSource SupportingInformation maps to derivedFrom ReasonCode maps to reasonCode MedicationReasonReference maps to reasonReference Annotation maps to note Dosage maps to dosage Map File Header The header of a map file must include the Grammar , Namespace , and Target keywords. The Grammar keyword declares the CIMPL Mapping Grammar Version. This version is currently 5.1. The Namespace keyword relates the maps defined in this file to the Class file in the same namespace. The Target keyword provides the version of FHIR that the CIMPL model is mapped to, either FHIR_DSTU_2 , FHIR_STU_3 , or FHIR_R4 . For a further description of the header keywords, see Keywords . Setting the Mapping Target Each section in a mapping file begins with a statement that establishes a resource, profile, or complex data type that is the target for the mapping. In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in the target output. The mapping target can be a FHIR resource, profile, or complex data type that is part of the target FHIR release version. The initial statement in each mapping block must end with a colon (:). CIMPL Class FHIR Target Example Entry Resource SocialHistoryObservation maps to Observation: Entry Profile LaboratoryObservation maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-observationresults: Group Complex Datatype Timing maps to Timing: Mapping Properties After the first line, which establishes the class to be mapped, the remainder of the section consists of statements that map CIMPL properties to FHIR elements. Each statement begins with a CIMPL path , followed by the phrase maps to , and ending with the target FHIR path. With FHIR as the target output, the right-hand side of the map statement can point to any element of a FHIR resource, including: Elements that are at the root of the resource (e.g., maritalStatus ) Elements that are child elements of root elements on the resource (e.g., reaction.substance ) Elements that have a choice of data types (e.g., multipleBirth[x].boolean ) Elements that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity ) Elements that support FHIR Reference() types. CIMPL type FHIR type Example Property element MaritalStatus maps to maritalStatus Property extension Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity Path element Value.ActiveFlag maps to active Path path AdverseReaction.AllergenIrritant maps to reaction.substance Value choice element BodySiteOrCode.concept maps to bodySite Note: The mapping grammar is still at version 5.1, so the bracketed value syntax cannot be used in paths. This is why the above example uses BodySiteOrCode.concept rather than BodySiteOrCode[concept] . Mapping to References FHIR resources and profiles require an explicit Reference() indicator when referring to another resource or profile. In CIMPL, whenever a property is an Entry, that property is mapped as a reference in FHIR. There is no need to create an explicit Reference() . Example: CIMPL Definition Corresponding FHIR Property: Encounter 0..1 encounter: 0..1 Reference(Encounter) Placement of Extensions As mentioned above, if no mapping rule is found for a property, an extension to the FHIR resource or profile will be automatically created. By default, the extension will be a top-level element in the FHIR profile. Sometimes you may want the extension to appear in a different place, perhaps inside a nested element. To put the extension precisely where you want it, you can map to FHIR paths that include extension . Here's an example involving the FHIR resource AdverseEvent : PotentialCause.CauseCategory maps to suspectEntity.extension This rule will create an extension named CauseCategory under AdverseEvent.suspectEntity. Note that rules such as this: DetectionTime maps to extension leave the default behavior unchanged, and are not required. However, they can be used to document the intent to create an extension. Special Mapping Statements fix fix allows FHIR fields to be assigned a value. Note that it is the FHIR profile that is getting the value, not the CIMPL class. This enables you to fix a FHIR value without having to change the class definition, which would affect all potential mappings. This also allows you to fix FHIR values for properties that have no corresponding property in the CIMPL definition. Example: fix status to #completed constrain constrain allows users to constrain the cardinality of FHIR elements. Note that it is the FHIR resource that is getting the constraint, not the CIMPL class. The cardinality is expressed in {min}..{max} form. Keyword Example constrain constrain explanation to 0..1 Slicing Slicing involves specifying the the type of elements that can be contained in an array. An array is a property whose upper cardinality is greater than one can potentially be sliced. In CIMPL, the includes constraint creates slices. This section discusses how slices in CIMPL are be mapped to FHIR. See the FHIR documentation for more detail about slicing . Slicing Rules Slicing is used when there is a variation of how an individual element is represented and a need to model it as a sub-list. An example of this is the FHIR Blood Pressure profile , which can be considered an observation with two components which are identical in structure other than their represented code. In CIMPL, slicing rules are specified in the map file. Four reserved phrases are used in conjunction to specify the slice: slice on (required) slice on type (optional) slice strategy (optional) slice at (optional) Declaring a Discriminator (slice on, slice on type) Discriminators are used to indicate how each slice can be distinguished from the others. FHIR requires discriminators to uniquely identify the slice to which an instance of data belongs. To perform any slicing, a discriminator path needs to be declared, using slice on followed by the discriminator path. This is the path to the property whose data identifies the slice an instance belongs to. For example, if slice on = code.coding.code , the code in each slice must be a unique, fixed value, and every instance must have a code that matches one of the defined slices. For more explanation of how discriminators are defined in FHIR, see discriminators . FHIR also requires a discriminator type to be indicated. By default, CIMPL uses the value discriminator type. However, a different discriminator type can be declared using slice on type followed by one of the following FHIR-defined discriminator types: Slice on type Definition value The slices have different values in the nominated element exists The slices are differentiated by the presence or absence of the nominated element pattern The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x] type The slices are differentiated by type of the nominated element to a specified profile profile The slices are differentiated by conformance of the nominated element to a specified profile (not recommended) Slice Strategy The slice_strategy indicates how the CIMPL property should map to slices in the target FHIR property. The default slice strategy adds a single slice, corresponding to the CIMPL type, in the target FHIR array. To map a CIMPL property with includes constraints such that each included CIMPL type becomes a slice in the target FHIR array, specify slice strategy = includes . Reserved Phrase Example slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) In the above example, each included ObservationComponent subtype will create a new slice in the FHIR component array. Each slice is distinguished by the value at the path component.code.coding.code . Moving the Slice Location (slice at) If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Reserved Phrase Example slice at Members.Observation maps to related.target (slice at = related; slice on = type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occurring at related.target . Instead, the slice at = related ensures that the slicing is occurring at the related element. Slicing Examples Phrase Example slice on / slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) slice on / slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) slice on Laterality maps to qualifier (slice on = concept) Appendix A: Changes from CIMPL 5.x For those who have created detailed models using CIMPL 5.0, there have been significant grammar changes to CIMPL 6.0. The table below summarizes these changes: Change Type Change Description CIMPL 5.0 Example CIMPL 6.0 Example Section New keyword only eliminates all value choices except one None FindingResult only concept Only Constraint New keyword Property is required to define properties for an Entry or Element. 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword New keyword Group is required to a reusable collection of properties, that is not an Entry . None Group: Address Group Keyword Replace EntryElement keyword replaced by Entry EntryElement: CourseOfTreatmentPerformed Entry: CourseOfTreatmentPerformed Element Keyword Replace Based on keyword replaced by Parent Based on: Observation Parent: Observation Parent Keyword Syntax change Cardinality is specified after the property or class name 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword , Cardinality Constraint Replace is constraint for fixed values replaced by = FindingTopicCode is LNC#48676-1 FindingTopicCode = LNC#48676-1 Field Constraints Replace substitution of a more specific element derived from a parent element using is type keyword replaced by substitute . Specimen is type BreastSpecimen Specimen substitute BreastSpecimen Substitute Replace code , Coding , and CodeableConcept are replaced by a new primitive concept Value: CodeableConcept from AttributionCategoryVS Value: concept from AttributionCategoryVS Primitives Replace must be , should be , could be , and if covered value set constraints are obsolete and replaced by (required) , (preferred) , (extensible) , and (example) Type from BreastSpecimenTypeVS if covered Type from BreastSpecimenTypeVS (extensible) Value Set Binding Constraint Replace ref() is now obsolete. value is type replaced by substitute and bracket notation denoting value choices SourceSpecimen value is type ref(BreastSpecimen) SourceSpecimen[Specimen] substitute BreastSpecimen Mapping to References","title":"CIMPL 6.0 Language Reference"},{"location":"cimpl6LanguageReference/#cimpl-60-language-reference","text":"","title":"CIMPL 6.0 Language Reference"},{"location":"cimpl6LanguageReference/#preface","text":"CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a specially-designed language for defining clinical information models. It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles, extensions and implementation guides (IG). Because it is a language , written in text statements, CIMPL encourages distributed, team-based development using conventional source-code control tools such as Github. CIMPL provides tooling that enables you to define a model once, and publish that model to multiple versions of FHIR.","title":"Preface"},{"location":"cimpl6LanguageReference/#purpose-of-this-document","text":"This document is a comprehensive guide to the CIMPL language, covering the syntax used to specify clinical models, value sets, and mappings to FHIR.","title":"Purpose of this Document"},{"location":"cimpl6LanguageReference/#intended-audience","text":"The CIMPL Language Reference is targeted to the users of CIMPL, involved with creating or reviewing models expressed in the CIMPL language.","title":"Intended Audience"},{"location":"cimpl6LanguageReference/#prerequisite","text":"This guide assumes you have: Installed the latest version of the SHR-CLI software as documented in CIMPL SetUp and Installation (preferably installed in the ~/cimpl/shr-cli directory). A text editor to create your CIMPL files (preferably VSCode with the vs-code-language-cimpl extension, but not required). Reviewed the In-Depth Tutorial .","title":"Prerequisite"},{"location":"cimpl6LanguageReference/#table-of-contents","text":"CIMPL 6.0 Language Reference Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Fundamentals Versioning File Types Classes Namespaces Naming Conventions File Names Namespace Names Class Names Fully Qualified Names Value Set Names Local Code Names Language Basics Whitespace Comments Reserved Words Primitives Concept Codes Keywords Abstract CodeSystem Concept Description Element Entry Grammar Group Namespace Parent Path Property Uses Value ValueSet CIMPL Paths Dot Notation Entries Terminate Paths Bracket Notation for Value Choices Path Example Constraints Cardinality Constraint Fixed Value Constraint Append Constraint Substitute Constraint Value Set Binding Constraint Value Set Binding in Elements Value Set Binding in Entry, Abstract, or Group Includes Constraint Only Constraint Class File Class File Example Class File Header Class Definitions Class Type and Name Declaration Properties and Values Naming Recommendations Value Set File Value Set File Example Value Set File Header Value Set Definition Explicit Codes Locally Defined Value Set Implicit Codes Map File Inheritance of Mapping Rules Mapping CIMPL Primitives to FHIR Map File Example Map File Header Setting the Mapping Target Mapping Properties Mapping to References Placement of Extensions Special Mapping Statements fix constrain Slicing Slicing Rules Declaring a Discriminator (slice on, slice on type) Slice Strategy Moving the Slice Location (slice at) Slicing Examples Appendix A: Changes from CIMPL 5.x","title":"Table of Contents"},{"location":"cimpl6LanguageReference/#fundamentals","text":"","title":"Fundamentals"},{"location":"cimpl6LanguageReference/#versioning","text":"CIMPL follows the semantic versioning convention (MAJOR.MINOR.PATCH). MAJOR: A major release has significant new functionality and potentially, grammar changes or other non-backward-compatible changes. MINOR: Contains new or modified features, while maintaining backwards compatability within the major version. PATCH: Contains minor updates and bug fixes, while maintaining backwards compatability within the major version. CIMPL is currently on major version 6. For a full change log, see the Release Notes .","title":"Versioning"},{"location":"cimpl6LanguageReference/#file-types","text":"Model information in CIMPL is stored in the following three file types: Class files (.txt): contain definitions of CIMPL classes. Value Set files (.txt): contain definitions of value sets defined in the namespace. Map files (.txt): contain information on how the CIMPL classes relate to FHIR resources, profiles, and elements. Each namespace will typically have one or more class files, and if needed, a value set and map file.","title":"File Types"},{"location":"cimpl6LanguageReference/#classes","text":"CIMPL models consist of classes. Classes define clinical information at some granularity. Classes can be combined in various ways (composition and specialization) to create meaningful structures.","title":"Classes"},{"location":"cimpl6LanguageReference/#namespaces","text":"CIMPL organizes information into namespaces. Namespaces are used to organize code and classes into logical collections and to prevent name collisions.","title":"Namespaces"},{"location":"cimpl6LanguageReference/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"cimpl6LanguageReference/#file-names","text":"File names must begin with lower case and typically include the namespace: Class files: namespace.txt or namespace-something.txt Value Set files: namespace-vs.txt or namespace-something-vs.txt Mapping files: namespace-map.txt or namespace-something-map.txt Any periods in the namespace should be replaced by dashes. For example, a namespace called odh.occupation , the recommended value set file name is odh-occupation-vs.txt . The something is useful when you want to break up the contents of a single namespace into multiple files, for example: obf-action.txt obf-finding.txt Note: obf stands for Objective FHIR , a set of classes provided with CIMPL that can help you create FHIR profiles. For more information, see Objective FHIR Overview Additional files for configuring and producing FHIR implementation guides (IGs), and their naming conventions include: Configuration files: ig-igname-config.json Content profile files: ig-igname-cp.json IG examples: ignameExampleName.json IG HTML pages: anyName.html","title":"File Names"},{"location":"cimpl6LanguageReference/#namespace-names","text":"Best practice is to follow the naming convention pattern of organization.domain or project.domain (followed by subdomains if necessary). Example Purpose obf.lab Laboratory profiles belonging to Objective FHIR odh Occupational Data for Health onco.core Core namespace for oncology-related profiles","title":"Namespace Names"},{"location":"cimpl6LanguageReference/#class-names","text":"Elements, Groups and Entries are conventionally defined in PascalCase . For example: * Element: DetectionTime * Group: Dosage * Entry: AdverseEvent Note: Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter.","title":"Class Names"},{"location":"cimpl6LanguageReference/#fully-qualified-names","text":"CIMPL does not support duplicate class names within a single namespace. However, the same name may occur in different namespaces. In the case of naming collisions due to an included namespace in Uses , you have to refer to the class by its fully qualified name (FQN). The FQN is a combination of the element's namespace and its declared name (through concatenation delimited by a period). For example, the element CancerCondition in the namespace onco.core has the following FQN: onco.core.CancerCondition FQNs are only required in case of naming collisions between namespaces.","title":"Fully Qualified Names"},{"location":"cimpl6LanguageReference/#value-set-names","text":"Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: Value Set names must begin with an uppercase letter.","title":"Value Set Names"},{"location":"cimpl6LanguageReference/#local-code-names","text":"Within a custom value set, the individual codes (denoted by # symbol) are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or Other Radiation Source\" #swimming_pool \"Swimming Pool\"","title":"Local Code Names"},{"location":"cimpl6LanguageReference/#language-basics","text":"","title":"Language Basics"},{"location":"cimpl6LanguageReference/#whitespace","text":"Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 6.0 Namespace: myExampleNamespace is equivalent to this: Grammar: DataElement 6.0 Namespace: myExampleNamespace","title":"Whitespace"},{"location":"cimpl6LanguageReference/#comments","text":"CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */","title":"Comments"},{"location":"cimpl6LanguageReference/#reserved-words","text":"CIMPL has a number of reserved words and phrases that are part of CIMPL's grammar (e.g., boolean , or , from , maps to ). For a complete list of reserved words, refer to the ANTLR4 grammar .","title":"Reserved Words"},{"location":"cimpl6LanguageReference/#primitives","text":"Primitives are data types, distinguished by starting with lower case letter. CIMPL defines the following primitive data types. With the exception of concept (a simplified representation of code, Coding, and CodeableConcept), the primitive types in CIMPL align with FHIR: concept boolean integer string decimal uri base64Binary instant date dateTime time oid id markdown unsignedInt positiveInt xhtml Note: CIMPL does not have an explicit \"Reference\" type. References are determined during the mapping process.","title":"Primitives"},{"location":"cimpl6LanguageReference/#concept-codes","text":"CIMPL uses a single primitive type, concept to represent coded terms from controlled vocabularies. A concept combines three elements: code system, code, and optional display text. The grammar for specifying concepts is: SYSTEM#code \"Display text\" For example: SCT#363346000 \"Malignant neoplastic disease (disorder)\" ICD10CM#C004 \"Malignant neoplasm of lower lip, inner aspect\" The SYSTEM is an alias for a canonical URI that represents a controlled vocabulary. Aliases must be declared in the file header using the CodeSystem keyword . You cannot use the canonical URI directly in the concept grammar. Unlike FHIR, CIMPL does not differentiate between code, Coding, and CodeableConcept. See Mapping Concept Codes for information on how CIMPL maps concept to these FHIR types. Note: Future versions of CIMPL will expand concept to include the code system version.","title":"Concept Codes"},{"location":"cimpl6LanguageReference/#keywords","text":"Keywords are used to make various declarations. Keywords always appear at the beginning of a line and are followed by a colon. Keyword Summary: Keyword Purpose File Type(s) Abstract Declare an non-instantiable class Class CodeSystem Define a code system alias Class, Value Set Concept Express the meaning of a class Class Description Provide a human-readable description Class, Value Set Element Declare lowest-level (elemental) model building block Class Entry Declare a stand-alone class Class Grammar Define how a file should be parsed All Group Declare mid-level, non-stand-alone model building block Class Namespace Associate a file with a namespace All Parent Specify inheritance Class Path Alias long URLs Class, Value Set Property Define an attribute in a class Class Uses Import namespace(s) Class Value Define data type(s) of Elements Class ValueSet Define a value set Value Set","title":"Keywords"},{"location":"cimpl6LanguageReference/#abstract","text":"The Abstract keyword is used to declare a new Abstract class. Abstract classes are identical to Entries, except they are not instantiable. For details, see Class File . Example: Abstract: ActionStatement","title":"Abstract"},{"location":"cimpl6LanguageReference/#codesystem","text":"The CodeSystem keyword provides an alias or shorthand for the canonical URI of a code system. You must define a code system alias before you can use codes from that system in constraints or value sets. By convention, the alias should be be UPPER CASE, although the tooling does allow for numbers and hyphens after the first upper case letter. Examples: CodeSystem: LNC = http://loinc.org CodeSystem: SCT = http://snomed.info/sct","title":"CodeSystem"},{"location":"cimpl6LanguageReference/#concept","text":"The Concept keyword (not to be confused with the concept primitive ) establishes the meaning of a class in terms of a code (or codes) from controlled vocabularies. Assigning a concept allows the meaning of the class to be understood without inferring it from the class name. If multiple concept codes are used, they should appear as a comma-separated list. This keyword is optional. Examples: Concept: MTH#C3858779 \"Security classification\"","title":"Concept"},{"location":"cimpl6LanguageReference/#description","text":"The Description keyword is used for a narrative that defines the namespace, class, or value set. Example: Description: \"Oncology data elements that broadly apply to most cancer cases.\" Note: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.)","title":"Description"},{"location":"cimpl6LanguageReference/#element","text":"The Element keyword is used to declare a new class of type Element, the lowest-level building block in CIMPL. For details, see Class File . Example: Element: EvidenceType","title":"Element"},{"location":"cimpl6LanguageReference/#entry","text":"The Entry keyword is used to declare a new stand-alone class, analogous to a Resource or Profile in FHIR. For details, see Class File . Example: Entry: GenomicsReport","title":"Entry"},{"location":"cimpl6LanguageReference/#grammar","text":"The Grammar keyword defines how the file is to be parsed. The grammar declaration must be the first line in each CIMPL file. File Type Required First Line Current Version # Class Grammar: DataElement #.# 6.0 Value Set Grammar: ValueSet #.# 5.1 Map Grammar: Map #.# 5.1 Note: no space in ValueSet The version details the MAJOR and MINOR version of the grammar the file was written for. The grammar version is typically not the same as the CIMPL release. Generally, the major version of the Grammar matches the major version number of CIMPL, however, at the time of the CIMPL 6.0 release, the ValueSet and Map grammar remain at 5.1.","title":"Grammar"},{"location":"cimpl6LanguageReference/#group","text":"The Group keyword is used to declare a building block comprised of one or more properties, similar to a complex data type in FHIR. For details, see Class File . Example: Group: Dosage","title":"Group"},{"location":"cimpl6LanguageReference/#namespace","text":"The Namespace keyword defines the association of the file with a namespace, and is required in DataElement , ValueSet and Map files. The namespace can be any number of lowercase period-delimited words. Examples: Namespace: odh Namespace: onco.core Note: While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens.","title":"Namespace"},{"location":"cimpl6LanguageReference/#parent","text":"Through the Parent keyword, CIMPL provides a mechanism for basing a class on another class, the child inheriting all properties and constraints from the parent. The child class can then extend information inherited from the parent by adding additional properties and applying additional constraints. Additionally, mappings are inherited alongside properties. At most one parent class can be specified. The Parent declaration is optional There are restrictions on which building blocks can inherit from other building blocks. The rules can be summarized as like inherits from like : Building Block Can Inherit From Element Element Group Group Entry Abstract or Entry Abstract Abstract Note: Although the CIMPL 6.0 tooling does not currently enforce these inheritance rules, they will be enforced in future releases. You are strongly encouraged to comply to these rules, and refactor any definitions ported from CIMPL 5.x that do not comply. Example: Parent: LaboratoryObservation","title":"Parent"},{"location":"cimpl6LanguageReference/#path","text":"The Path keyword allows for abbreviations of long URLs. This functionality is completely optional, but it is provided to make authoring easier. By convention, the alias should be be an all UPPER CASE word, although the tooling does allow for numbers and hyphens after the first letter. Example: Path: FHIR = http://hl7.org/fhir/ValueSet","title":"Path"},{"location":"cimpl6LanguageReference/#property","text":"Classes based on Group, Entry, and Abstract are composed of one or more properties (called fields or attributes in object-oriented programming). A property can be any Element, Group, or Entry, but never a primitive. Each property must have a specified cardinality range, represented as min..max , indicating the number of repeats of the property. The Property keyword cannot be used in Elements. In the following example, StudyArm has four properties: Name , Type , Comment and ResearchStudy . Name is singular and required, Type is optional and repeating, and Comment is singular and optional: Group: StudyArm Description: \"Refers to participant(s) in a clinical trial assigned to receive specific interventions according to a protocol.\" Property: Name 1..1 Property: Type 0..* Property: Comment 0..1 Property: ResearchStudy 1..1 A property that refers to an Entry (such as ResearchStudy, above) is implicitly a reference (pointer) to an instance of that Entry, rather than implying the Entry is \"in-lined\" into the class. Note: CIMPL 5.0 Grammar use of the keyword ref() is now obsolete.","title":"Property"},{"location":"cimpl6LanguageReference/#uses","text":"The Uses keyword appears in the Class file and provides a comma-separated list of the namespaces imported to the current namespace. This keyword allows you to use the classes and value sets defined in other namespaces. The list order has no effect. Examples: Uses: obf.datatype Uses: obf.datatype, obf, onco.core","title":"Uses"},{"location":"cimpl6LanguageReference/#value","text":"Value represents the data type(s) an Element can accept. This keyword can only be used when defining an Element. Each Element must have exactly one Value , although the value itself can be a choice of several data types. Value choices can be Primitives , Elements , Groups , or Entries . A value may be inherited and constrained in the child class. Examples: Element: DetectionTime Description: \"The date on which the condition was first observed.\" Value: dateTime Element: ExpectedPerformanceTime Description: \"When an action should be performed.\" Value: dateTime or TimePeriod or Timing Element: SubstanceOrCode Description: \"A code or substance reference identifying the ingredient.\" Value: concept or Substance or Medication Although in general, constraints cannot be applied to a property or value at the same time the item is defined, you are allowed to bind a value set to a concept value choice at the same time the value is defined, as follows: Element: IsPrimaryTumor Description: \"Whether the tumor is the original or first tumor in the body, for a particular cancer.\" Value: concept from YesNoUnknownVS (required) For more information on binding, see Value Set Binding Constraint . Note: CIMPL 5.0 Grammar associating a cardinality to a Value is now obsolete.","title":"Value"},{"location":"cimpl6LanguageReference/#valueset","text":"Defines the name of a value set defined inside CIMPL (references to external value sets are also allowed). By convention, all value sets should be Pascal case, start with the name of the corresponding concept-type Element that is being bound to the value set, and end with VS . Example: ValueSet: ProposedStatusVS","title":"ValueSet"},{"location":"cimpl6LanguageReference/#cimpl-paths","text":"CIMPL provides grammar that allows you to refer to any part of a CIMPL class, regardless of nesting. This section outlines CIMPL Path Grammar, which is used in constraints and mapping .","title":"CIMPL Paths"},{"location":"cimpl6LanguageReference/#dot-notation","text":"Dot notation is used to denote nested properties. The path lists the properties in order, separated by a dot (.) For example, if Patient has a ContactPoint , and ContactPoint has a Priority , then the path to Priority is Patient.ContactPoint.Priority .","title":"Dot Notation"},{"location":"cimpl6LanguageReference/#entries-terminate-paths","text":"An Entry can appear in a path only as its final element. Paths represent nested containment within one class, and Entries are independent objects. Paths cannot \"hop\" from one Entry to another. For example, Procedure has a Patient property, and while Procedure.Patient is a valid path, Procedure.Patient.gender is not. The former path can be used to set the cardinality of Patient within the Procedure class, but the latter would (illegally) constrain an attribute within Patient from inside Procedure .","title":"Entries Terminate Paths"},{"location":"cimpl6LanguageReference/#bracket-notation-for-value-choices","text":"Values can offer a choice of data types . Bracket notation is used to refer to a particular value choice. Bracket notation must always be used when an Element is part of a CIMPL path. How value choices appear in paths depends on whether the path appears with an Element definition or not. Inside an: Refer to the Value choices as: Element Value[choice] Entry or Group ElementName[choice] Example: Entry: Procedure Property: Priority 0..1 Priority[concept] = SCT#394849002 \"High Priority\" // not Value[concept] Element: Priority Value: integer or concept Value[concept] from PriorityVS (required) // not Priority[concept] Note: The requirement in CIMPL 6.0 to use bracket notation even when the value has only one choice is a change from CIMPL 5.","title":"Bracket Notation for Value Choices"},{"location":"cimpl6LanguageReference/#path-example","text":"Entry: Procedure Property: Landmark Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Group: Location Description: \"Location of the landmark\" Property: Code 0..1 Property: Laterality 0..1 Property: Orientation 0..1 Element: Distance Description: \"How far the body location of interest is from the given landmark.\" Value: Quantity Element: Direction Description: \"The direction from the landmark to the body location of interest.\" Value: ClockFaceDirection or AnatomicalDirection Element: ClockFaceDirection Description: \"A direction indicated by o'clock position or degrees relative to 12 o'clock.\" Value: concept or Angle Group: Quantity Description: \"A quantity with units.\" Property: Number 0..1 Property: Comparator 0..1 Property: Units 0..1 This example assumes all paths begin at Procedure, which is an Entry, but the same patterns would apply if the path started elsewhere, for example, at Landmark. Path to Path Direction Procedure.Landmark.Direction Laterality Procedure.Landmark.Location.Laterality ClockFaceDirection Procedure.Landmark.Direction[ClockFaceDirection] Angle Procedure.Landmark.Direction[ClockFaceDirection][Angle] Units Procedure.Landmark.Distance[Quantity].Units A reliable method to create a CIMPL path is to first view it as a dot path, then bracket any part of the path that is a Value, and finally, remove the dot before each left (open) bracket. Here's an example of that process, for the path from Landmark to Units: Find the path: Landmark to Distance , Distance to Quantity , Quantity to Units . Reduce to dot path: Landmark.Distance.Quantity.Units Bracket each Value: Landmark.Distance.[Quantity].Units Remove dot before left (open) bracket: Landmark.Distance[Quantity].Units","title":"Path Example"},{"location":"cimpl6LanguageReference/#constraints","text":"Constraints are a way to shape a general model for a particular purpose. Properties, values, and value choices can be constrained. Constraint targets can be be top-level or deeply nested (the latter referred to using CIMPL paths ), inherited or locally-defined. Unlike keyword declarations, constraint statements do not begin with a keyword. Most constraint statements have three parts: The subject of the constraint A reserved word or phrase indicating the type of constraint The constraint value being applied Here are several examples of this pattern: Example Subject Reserved word Value applied IsPrimaryTumor = true IsPrimaryTumor = true Specimen substitute TumorSpecimen Specimen substitute TumorSpecimen BodyLocation from BodyLocationVS BodyLocation from BodyLocationVS LanguageUsed 0..1 LanguageUsed (implicit) 0..1 Here is a summary of supported constraints: To do this.. Use this Keyword or Symbol Applies to Narrow cardinality {min}..{max} Property Assign a fixed value = Property or Value[Choice] Append a fixed value to an array += Array Property Narrow a data type substitute Property or Value[Choice] Bind a value set from Property or Value[Choice] Slice an array includes Array Property Narrow choices for a value only Value","title":"Constraints"},{"location":"cimpl6LanguageReference/#cardinality-constraint","text":"Cardinality defines the number of repeats that can exist for a Property. Cardinality is specified using FHIR syntax, {min}..{max}, where the first integer indicates the minimum repeats (0 implying optional), and the second digit expresses the upper bound on the number of repeats. To express no upper bound, a * is used. When constraining cardinality, you can only narrow the previously declared cardinality. The cardinality constraint only applies to properties. Declaration Constraint Subsequent Constraint Property: LanguageUsed 0..* LanguageUsed 0..1 LanguageUsed 0..0 Property: GovernmentIssuedID 0..* GovernmentIssuedID 1..* GovernmentIssuedID 1..1 Property: Status 1..1 Status 0..1 invalid Note: By constraining a property to 0..0, you effectively remove the property. Use 0..0 with caution, because if an instance does include that property, the instance will fail validation and may be rejected.","title":"Cardinality Constraint"},{"location":"cimpl6LanguageReference/#fixed-value-constraint","text":"The = operator fixes an Element's value to a specific concept, boolean, string, integer, decimal, or URL. The assigned value must be consistent with the defined data type, and is always a primitive. Example Syntax Fix a code to an Element ObservationCode = LNC#82810-3 Fix a boolean value to an Element IsPrimaryTumor = true Fix a code to an Element's Value Value[concept] = SCT#233613009 \"Pneumonia\" Fix the units associated with a Quantity Value Choice Value[Quantity].Units = UCUM#cm Notes: Bracket notation must always be used when applying a constraint to a value choice, even if the value has only one choice . CIMPL allows fixed concept values to be overridden in child classes. Although this seems to violate the notion that constraints should get progressively tighter in subclasses, it is necessary when narrowing the meaning of a class characterized by a concept code. For example, the class Pneumonia , with fixed code, SCT#233604007 , may have a child, Fungal Pneumonia , with fixed code SCT#233613009 , the latter overriding the former. CIMPL will assume, without checking, that the code describing the child class has more constrained semantics than the code it replaces. Fixing numerical types and strings (including URLs) is not yet supported, although this feature is planned. If you only need to fix a code in one particular mapping (one version of FHIR, for example), do so using the fix keyword in the mapping file and not as a constraint.","title":"Fixed Value Constraint"},{"location":"cimpl6LanguageReference/#append-constraint","text":"The append += operator appends a fixed concept to a property array whose value is concept . You can use the += operation repeatedly on the same array, limited only be the cardinality of the array. The append operator can only be applied to repeating properties. For example, use += to insert a specific Category value into an array of categories. Example Syntax Insert \"Behavior\" into Category array Category += LNC#54511-1 \"Behavior\" Add \"Social History\" to same array Category += OBSCAT#social-history \"Social History\" Note: Appending other data types is not yet supported, although this feature is planned.","title":"Append Constraint"},{"location":"cimpl6LanguageReference/#substitute-constraint","text":"The substitute keyword constrains value data type of an element. The new data type that is substituted for the original must be a subclass of the original data type. Example Syntax Constrain the element Specimen to be a TumorSpecimen Specimen substitute TumorSpecimen note: TumorSpecimen must be a subclass of Specimen Constrain a Value choice of type Quantity to SimpleQuantity Value[Quantity] substitute SimpleQuantity note: SimpleQuantity is a subclass of Quantity","title":"Substitute Constraint"},{"location":"cimpl6LanguageReference/#value-set-binding-constraint","text":"Binding is the process of associating an Element with a set of possible values. Binding uses the keyword from . The object of a binding must be an Element whose Value is a concept . The value set that is being bound can be a value set defined in a CIMPL Value Set file, or a canonical URL external to CIMPL. CIMPL uses the binding strengths defined in FHIR , namely: required (strongest) indicates that the code must come from the specified value set. extensible indicates that the code must come from the specified set if the value set contains a relevant code ; otherwise a code outside the value set may be chosen. preferred indicates that the code should ideally come from the specified value set, but codes outside the value set may also be chosen. example (weakest) indicates that the code may come from anywhere; the specified value set is for example purposes only. The following rules apply to binding in CIMPL: If no binding strength is specified, the binding is assumed to be required . When further constraining an existing binding, the binding strength can stay the same or be made tighter (e.g., replacing an preferred binding with an extensible or required binding), but never loosened. Constraining may leave the binding strength the same and change the value set instead. However, certain changes permitted in CIMPL may violate FHIR profiling principles . In particular, FHIR will permit a required value set to be replaced by another required value set only if the codes in the new value set are a subset of the codes in the original value set. For extensible bindings, the new value set can contain codes not in the existing value set, but additional codes SHOULD NOT have the same meaning as existing codes in the base value set. The syntax for binding is different depending on whether the binding is in an Element or another class (Abstract, Entry, or Group).","title":"Value Set Binding Constraint"},{"location":"cimpl6LanguageReference/#value-set-binding-in-elements","text":"The following syntax is allowable when binding inside an Element: Value from <value set reference> Value from <value set reference> (binding strength) Value[choice] from <value set reference> (binding strength) For example: Value from TerminationReasonVS Value from http://hl7.org/fhir/ValueSet/condition-clinical (preferred) Value[AgeGroup] from AgeGroupVS (extensible) Note: You must explicitly specify which value choice the binding applies to if the value has multiple choices (the third pattern, above).","title":"Value Set Binding in Elements"},{"location":"cimpl6LanguageReference/#value-set-binding-in-entry-abstract-or-group","text":"The following syntax is allowable when binding inside an Entry, Abstract, or Group: <Property> from <value set reference> <Property> from <value set reference> (binding strength) For example: ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical ReasonCode from ReasonCodeVS (extensible) BodyLocation from BodyLocationVS (preferred)","title":"Value Set Binding in Entry, Abstract, or Group"},{"location":"cimpl6LanguageReference/#includes-constraint","text":"The includes constraint is used to specify that a repeating property (array) should contain a certain class or classes. FHIR refers to this as slicing . In CIMPL, slicing is accomplished by declaring that an array includes certain types of components. The includes statement has several requirements: The classes included in the array must conform to the data type of the array. For example, if the array is Identifier 0..* , the classes included in the array must inherit from Identifier. Cardinality of each inclusion must be specified, and must fit the cardinality of the array. For example, if the array property has a finite maximum cardinality, you cannot include an element with cardinality 0..*. The keyword includes is repeated for each item the array should contain. The includes constraint does not apply to Element Values. Here is an example: Property: Measurement 0..* // the array property ... Measurement includes TumorLength 1..1 includes TumorWidth 0..1 includes TumorDepth 0..1 Note: TumorLength, TumorWidth, and TumorDepth all must inherit from Measurement, because the members of the Measurement array must be Measurements. Here is another example: Property: Identifier 1..* // the array property ... Identifier includes NationalProviderIdentifier 0..1 includes TaxIdentificationNumber 0..1 In this case, both NationalProviderIdentifier and TaxIdentificationNumber must have Identifier as their parent. Note: When using includes , special mapping syntax is required. See Slicing .","title":"Includes Constraint"},{"location":"cimpl6LanguageReference/#only-constraint","text":"Values can have multiple data types. Use the only constraint in an Element to narrow the choice of data types. The only constraint can only be applied to a value that has multiple choices. The grammar of only constraints varies depending on whether the constraint appears in an Element, or another class type. | In the class... | Use the grammar... | |----------|---------|--------| | Element | Value only <datatype> | | Element | Value only <datatype1> or <datatype2> or <datatype3> etc. | | Entry or Group | <Property> only <datatype> note : this is allowed only for a single datatype; to constrain to multiple choices, use the substitute constraint (see Example 2, below) | Example 1: Multiple value choices narrowed to a single choice Element: Priority Value: integer or concept Element: IntegerPriority Parent: Priority Value only integer // Both of the following are legal and have the same effect: Group: Alarm-One Property: Priority Priority only integer Group: Alarm-Two Property: Priority Priority substitute IntegerPriority Example 2: Multiple value choices narrowed to smaller number of choices Element: Answer Description: \"A potential answer with many different allowed datatypes.\" Value: integer or date or time or string or concept or Resource Element: TemporalAnswer Parent: Answer Description: \"An answer that's either a date or time\" Value only date or time // legal way to reduce multiple choice! Group: QuestionAndAnswer Property: Question // dummy - not defined Property: Answer Group: QuestionWithTemporalAnswer Parent: QuestionAndAnswer Answer substitute TemporalAnswer // NOT: \"Answer only date or time\" and NOT \"Answer only TemporalAnswer\"","title":"Only Constraint"},{"location":"cimpl6LanguageReference/#class-file","text":"Class files contain definitions of the information model. Every model defined in CIMPL must have at least one class file.","title":"Class File"},{"location":"cimpl6LanguageReference/#class-file-example","text":"Here is an abbreviated example of a class file: Grammar: DataElement 6.0 Namespace: obf.lab Description: \"Profiles of laboratory tests and panels.\" Uses: datatype, obf CodeSystem: LNC = http://loinc.org CodeSystem: UCUM = http://unitsofmeasure.org Abstract: SimpleQuantLabWithRequiredUnits Parent: SimpleQuantitativeLaboratoryObservation Description: \"Laboratory tests that must be reported with units.\" DataValue 1..1 DataValue only QuantityWithRequiredUnits DataAbsentReason 0..0 Group: QuantityWithRequiredUnits Parent: Quantity Description: \"A quantity with that requires a coded unit of measure.\" Units 1..1 Entry: GlobulinMCncPtSerQnCalculatedLabObs Parent: SimpleQuantLabWithRequiredUnits Description: \"Globulin [Mass/\u200bvolume] in Serum by calculation\" Code = LNC#10834-0 \"Globulin [Mass/\u200bvolume] in Serum by calculation\" DataValue[Quantity].Units from EquivalentUnitsVS-g-per-L (required)","title":"Class File Example"},{"location":"cimpl6LanguageReference/#class-file-header","text":"The elements of the class file header are (in order): Grammar (required) Namespace (required) Description (recommended; once per namespace) Uses (optional; as needed) CodeSystem (optional; as needed) Path (optional) For a further description, see Keywords . Note: Uses imports namespaces whose classes can be used as if they were locally defined. However, if a class name in an imported namespace collides with a local class name, you must refer to that element by its fully qualified name .","title":"Class File Header"},{"location":"cimpl6LanguageReference/#class-definitions","text":"Following the header, the class file contains class definitions. The order of the class definitions does not matter. Each class definition consists of declarations. Follow the links for further explanation of each item: Class Type and Name Declaration (required, must be first) Parent Declaration (optional) Concept Declaration (optional) Description (optional but highly recommended) Property Declarations (for Entry, Abstract and Group), or Value Declaration (for Element) (optional, but typically present) Constraint statements (optional)","title":"Class Definitions"},{"location":"cimpl6LanguageReference/#class-type-and-name-declaration","text":"The first line of all class definitions is a keyword representing the type of class, followed by a descriptive name you choose. Class names must be unique within a given namespace. CIMPL provides four class types: Class Description Has... Analogous FHIR Type Element The lowest-level class, representing a property-value pair. Value Element or simple extension Group A class comprised of other classes, specifically, other Groups, Elements, and Entries. Properties Backbone element or complex extension Entry A class representing a group of related information, complete enough to support stand-alone interpretation. Properties Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Properties none","title":"Class Type and Name Declaration"},{"location":"cimpl6LanguageReference/#properties-and-values","text":"When defining classes, bear in mind that: An Element has exactly one Value field and no Property fields The Value field may have more than one choice (using or ) A Property cannot have choices Group , Entry , or Abstract may have multiple Property fields, but no Value These differences are illustrated in this example: Group: Landmark Description: \"A point on the body that helps determine a body location.\" Property: Location 0..1 Property: Direction 0..1 Property: Distance 0..1 Element: Direction Description: \"The direction from the landmark to the body location of interest.\" Value: concept from AnatomicalDirectionVS (preferred) Summary: Keyword Appears with How Many Times? Has Cardinality? Has Choices? Can be a... Value Element Exactly Once No Yes (optionally) primitive, Element, Group, or Entry Property Group , Entry , or Abstract Zero or more Yes No Element, Group, or Entry","title":"Properties and Values"},{"location":"cimpl6LanguageReference/#naming-recommendations","text":"All classes in CIMPL, from Element to Entry , are reusable outside of their original context. To promote reuse, try to choose names that are self-explanatory and context-independent. For example, a Property named Text is too vague, whereas DisplayText and InstructionText are more self-explanatory and may be completely understandable when placed into a specific context. However, an overly-specific name like AddressDisplayText could inhibit reuse because it affixes the context of an address to the concept of a display text.","title":"Naming Recommendations"},{"location":"cimpl6LanguageReference/#value-set-file","text":"Value set files are used to define custom value sets and codes when existing value set sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient, and a new value set must be defined.","title":"Value Set File"},{"location":"cimpl6LanguageReference/#value-set-file-example","text":"A (truncated) example value set file is shown below: Grammar: ValueSet 5.1 Namespace: onco.core CodeSystem: SCT = http://snomed.info/sct CodeSystem: ICD10CM = http://hl7.org/fhir/sid/icd-10-cm ValueSet: CancerDiseaseStatusEvidenceTypeVS Description: \"The type of evidence backing up the clinical determination of cancer progression.\" SCT#363679005 \"Imaging (procedure)\" SCT#252416005 \"Histopathology test (procedure)\" SCT#711015009 \"Assessment of symptom control (procedure)\" SCT#5880005 \"Physical examination procedure (procedure)\" SCT#250724005 \"Tumor marker measurement (procedure)\" SCT#386344002 \"Laboratory data interpretation (procedure)\" ValueSet: SecondaryCancerDisorderVS Description: \"Types of secondary malignant neoplastic disease\" Includes codes descending from SCT#128462008 \"Secondary malignant neoplastic disease (disorder)\" ICD10CM#C7B00 \"Secondary carcinoid tumors, unspecified site\" ICD10CM#C7B01 \"Secondary carcinoid tumors of distant lymph nodes\" ICD10CM#C7B02 \"Secondary carcinoid tumors of liver\" ICD10CM#C7B03 \"Secondary carcinoid tumors of bone\" ICD10CM#C7B04 \"Secondary carcinoid tumors of peritoneum\"","title":"Value Set File Example"},{"location":"cimpl6LanguageReference/#value-set-file-header","text":"Grammar and Namespace are required keywords in a Value Set file header. A CodeSystem declaration is required for every Code System referenced in a value set defined in the Value Set file. For a further description, see Code System Keyword .","title":"Value Set File Header"},{"location":"cimpl6LanguageReference/#value-set-definition","text":"Following the header, the Value Set file contains value set definitions. The order of definitions does not matter. Each definition follows a set sequence of declarations. Follow the links for further explanation of each item: Value Set Declaration (required) Description (optional but highly recommended) Code Declarations (optional) Includes Codes statements (optional)","title":"Value Set Definition"},{"location":"cimpl6LanguageReference/#explicit-codes","text":"Explicit code declarations are used to add specific codes to a value set. This method of defining a value set is sometimes called extensional . Codes can either be locally-defined, or selected from external code systems, such as ICD10CM#C7B00 , in which C7B00 is an existing code within the ICD10CM code system. If the code is defined locally, the value set name serves as the code system. For the syntax of concept codes, see Concept Codes . Type Example Locally-defined code #proposed \"The proposal has been proposed, but not accepted or rejected.\" Externally-defined code ICD10CM#C7B00 \"Secondary carcinoid tumors, unspecified site\"","title":"Explicit Codes"},{"location":"cimpl6LanguageReference/#locally-defined-value-set","text":"Within a custom value set (one specific to an IG), the individual codes (denoted by # symbol) are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or Other Radiation Source\" #swimming_pool \"Swimming Pool\"","title":"Locally Defined Value Set"},{"location":"cimpl6LanguageReference/#implicit-codes","text":"Implicit code declarations adds codes to a value set using an expression rather than a list. This allows you to, for example, add all codes from a code system, add all codes descending from a point in a hierarchy (currently, only supported in SNOMED-CT). This method of defining a value set is sometimes called intensional . There are three variants involving the Includes codes phrase: Phrase Example Result Includes codes from Includes codes from MDR Value set contains all codes from MDR code system Includes codes descending from Includes codes descending from SCT#105590001 Value set contains SCT#1055900001 and all codes below it in the SNOMED-CT hierarchy and not descending from Includes codes descending from SCT#363346000 \"Malignant neoplastic disease\" and not descending from SCT#128462008 \"Secondary malignant neoplastic disease\" Value set contains SCT#363346000 and all codes below it in the SNOMED-CT hierarchy, except code SCT#128462008 and all codes below it","title":"Implicit Codes"},{"location":"cimpl6LanguageReference/#map-file","text":"Map files control how classes defined in CIMPL are expressed as FHIR profiles. Map files are FHIR-version dependent. Currently, you can map to FHIR DSTU 2, STU 3, R4. If you use the supplied Objective FHIR base classes , you many not need to create a map file.","title":"Map File"},{"location":"cimpl6LanguageReference/#inheritance-of-mapping-rules","text":"Maps are defined in a series of mapping rules. A powerful feature of CIMPL is that mapping rules are inherited. If your class inherits from a parent class that already is mapped, you do not need to create a new map for your class. However, if you want to specify mappings for a new Property , or override the inherited map, you may do so. The inheritance of mapping rules follows the class hierarchy. If there is no map for a class or attribute, CIMPL tooling automatically looks to the parent class to try and find a mapping. The first mapping rule found will be applied. If no mapping rule is found for a Property defined in CIMPL, a FHIR extension will be created. If no mapping is found for an Entry , that Entry will be mapped to the Basic resource . In general, mapping to Basic is not recommended because it has no inherent semantic meaning for implementers.","title":"Inheritance of Mapping Rules"},{"location":"cimpl6LanguageReference/#mapping-cimpl-primitives-to-fhir","text":"CIMPL follows somewhat flexible rules on how CIMPL primitives map to FHIR. For example, a unsignedInt in CIMPL can map to an integer type in FHIR (since every unsignedInt is an integer, there is no loss of information). However, mappings that lose information, such as integer in CIMPL to unsignedInt in FHIR, generally will trigger mapping errors. An exception is that CIMPL concept is allowed to map to FHIR code . The following table shows the acceptable mappings between CIMPL and FHIR: CIMPL Primitive Can map to FHIR... concept code, Coding, CodableConcept boolean boolean, code integer integer, Quantity string string decimal decimal uri uri base64Binary base64Binary instant instant date date dateTime dateTime, date, instant time time oid oid id id markdown markdown, string unsignedInt unsignedInt, integer, Quantity positiveInt positiveInt, unsignedInt, integer, Quantity xtml xtml","title":"Mapping CIMPL Primitives to FHIR"},{"location":"cimpl6LanguageReference/#map-file-example","text":"The following example demonstrates how the class Dosage, defined in the OBF namespace, maps to the FHIR 4.0 data type with the same name. The second example demonstrates mapping between the OBF MedicationStatement class and the FHIR 4.0 US Core MedicationStatement profile. Grammar: Map 5.1 Namespace: obf Target: FHIR_R4 Dosage maps to Dosage: DoseSequenceNumber maps to sequence InstructionText maps to text InstructionCode maps to additionalInstruction PatientInstruction maps to patientInstruction Timing maps to timing AsNeeded maps to asNeeded[x] AdministrationSite maps to site RouteIntoBody maps to route Method maps to method MaxDosePerPeriod maps to maxDosePerPeriod MaxDosePerAdministration maps to maxDosePerAdministration MaxDosePerLifetime maps to maxDosePerLifetime constrain doseAndRate to 0..1 DoseAndRate.DoseAmount maps to doseAndRate.dose[x] DoseAndRate.DoseRate maps to doseAndRate.rate[x] MedicationStatement maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-medicationstatement: Identifier maps to identifier MedicationBasedOn maps to basedOn MedicationStatementPartOf maps to partOf Status maps to status StatusReason maps to statusReason Category maps to category MedicationCodeOrReference maps to medication[x] SubjectOfRecord maps to subject CareContext maps to context OccurrenceTimeOrPeriod maps to effective[x] StatementDateTime maps to dateAsserted MedicationInformationSource maps to informationSource SupportingInformation maps to derivedFrom ReasonCode maps to reasonCode MedicationReasonReference maps to reasonReference Annotation maps to note Dosage maps to dosage","title":"Map File Example"},{"location":"cimpl6LanguageReference/#map-file-header","text":"The header of a map file must include the Grammar , Namespace , and Target keywords. The Grammar keyword declares the CIMPL Mapping Grammar Version. This version is currently 5.1. The Namespace keyword relates the maps defined in this file to the Class file in the same namespace. The Target keyword provides the version of FHIR that the CIMPL model is mapped to, either FHIR_DSTU_2 , FHIR_STU_3 , or FHIR_R4 . For a further description of the header keywords, see Keywords .","title":"Map File Header"},{"location":"cimpl6LanguageReference/#setting-the-mapping-target","text":"Each section in a mapping file begins with a statement that establishes a resource, profile, or complex data type that is the target for the mapping. In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in the target output. The mapping target can be a FHIR resource, profile, or complex data type that is part of the target FHIR release version. The initial statement in each mapping block must end with a colon (:). CIMPL Class FHIR Target Example Entry Resource SocialHistoryObservation maps to Observation: Entry Profile LaboratoryObservation maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-observationresults: Group Complex Datatype Timing maps to Timing:","title":"Setting the Mapping Target"},{"location":"cimpl6LanguageReference/#mapping-properties","text":"After the first line, which establishes the class to be mapped, the remainder of the section consists of statements that map CIMPL properties to FHIR elements. Each statement begins with a CIMPL path , followed by the phrase maps to , and ending with the target FHIR path. With FHIR as the target output, the right-hand side of the map statement can point to any element of a FHIR resource, including: Elements that are at the root of the resource (e.g., maritalStatus ) Elements that are child elements of root elements on the resource (e.g., reaction.substance ) Elements that have a choice of data types (e.g., multipleBirth[x].boolean ) Elements that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity ) Elements that support FHIR Reference() types. CIMPL type FHIR type Example Property element MaritalStatus maps to maritalStatus Property extension Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity Path element Value.ActiveFlag maps to active Path path AdverseReaction.AllergenIrritant maps to reaction.substance Value choice element BodySiteOrCode.concept maps to bodySite Note: The mapping grammar is still at version 5.1, so the bracketed value syntax cannot be used in paths. This is why the above example uses BodySiteOrCode.concept rather than BodySiteOrCode[concept] .","title":"Mapping Properties"},{"location":"cimpl6LanguageReference/#mapping-to-references","text":"FHIR resources and profiles require an explicit Reference() indicator when referring to another resource or profile. In CIMPL, whenever a property is an Entry, that property is mapped as a reference in FHIR. There is no need to create an explicit Reference() . Example: CIMPL Definition Corresponding FHIR Property: Encounter 0..1 encounter: 0..1 Reference(Encounter)","title":"Mapping to References"},{"location":"cimpl6LanguageReference/#placement-of-extensions","text":"As mentioned above, if no mapping rule is found for a property, an extension to the FHIR resource or profile will be automatically created. By default, the extension will be a top-level element in the FHIR profile. Sometimes you may want the extension to appear in a different place, perhaps inside a nested element. To put the extension precisely where you want it, you can map to FHIR paths that include extension . Here's an example involving the FHIR resource AdverseEvent : PotentialCause.CauseCategory maps to suspectEntity.extension This rule will create an extension named CauseCategory under AdverseEvent.suspectEntity. Note that rules such as this: DetectionTime maps to extension leave the default behavior unchanged, and are not required. However, they can be used to document the intent to create an extension.","title":"Placement of Extensions"},{"location":"cimpl6LanguageReference/#special-mapping-statements","text":"","title":"Special Mapping Statements"},{"location":"cimpl6LanguageReference/#fix","text":"fix allows FHIR fields to be assigned a value. Note that it is the FHIR profile that is getting the value, not the CIMPL class. This enables you to fix a FHIR value without having to change the class definition, which would affect all potential mappings. This also allows you to fix FHIR values for properties that have no corresponding property in the CIMPL definition. Example: fix status to #completed","title":"fix"},{"location":"cimpl6LanguageReference/#constrain","text":"constrain allows users to constrain the cardinality of FHIR elements. Note that it is the FHIR resource that is getting the constraint, not the CIMPL class. The cardinality is expressed in {min}..{max} form. Keyword Example constrain constrain explanation to 0..1","title":"constrain"},{"location":"cimpl6LanguageReference/#slicing","text":"Slicing involves specifying the the type of elements that can be contained in an array. An array is a property whose upper cardinality is greater than one can potentially be sliced. In CIMPL, the includes constraint creates slices. This section discusses how slices in CIMPL are be mapped to FHIR. See the FHIR documentation for more detail about slicing .","title":"Slicing"},{"location":"cimpl6LanguageReference/#slicing-rules","text":"Slicing is used when there is a variation of how an individual element is represented and a need to model it as a sub-list. An example of this is the FHIR Blood Pressure profile , which can be considered an observation with two components which are identical in structure other than their represented code. In CIMPL, slicing rules are specified in the map file. Four reserved phrases are used in conjunction to specify the slice: slice on (required) slice on type (optional) slice strategy (optional) slice at (optional)","title":"Slicing Rules"},{"location":"cimpl6LanguageReference/#declaring-a-discriminator-slice-on-slice-on-type","text":"Discriminators are used to indicate how each slice can be distinguished from the others. FHIR requires discriminators to uniquely identify the slice to which an instance of data belongs. To perform any slicing, a discriminator path needs to be declared, using slice on followed by the discriminator path. This is the path to the property whose data identifies the slice an instance belongs to. For example, if slice on = code.coding.code , the code in each slice must be a unique, fixed value, and every instance must have a code that matches one of the defined slices. For more explanation of how discriminators are defined in FHIR, see discriminators . FHIR also requires a discriminator type to be indicated. By default, CIMPL uses the value discriminator type. However, a different discriminator type can be declared using slice on type followed by one of the following FHIR-defined discriminator types: Slice on type Definition value The slices have different values in the nominated element exists The slices are differentiated by the presence or absence of the nominated element pattern The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x] type The slices are differentiated by type of the nominated element to a specified profile profile The slices are differentiated by conformance of the nominated element to a specified profile (not recommended)","title":"Declaring a Discriminator (slice on, slice on type)"},{"location":"cimpl6LanguageReference/#slice-strategy","text":"The slice_strategy indicates how the CIMPL property should map to slices in the target FHIR property. The default slice strategy adds a single slice, corresponding to the CIMPL type, in the target FHIR array. To map a CIMPL property with includes constraints such that each included CIMPL type becomes a slice in the target FHIR array, specify slice strategy = includes . Reserved Phrase Example slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) In the above example, each included ObservationComponent subtype will create a new slice in the FHIR component array. Each slice is distinguished by the value at the path component.code.coding.code .","title":"Slice Strategy"},{"location":"cimpl6LanguageReference/#moving-the-slice-location-slice-at","text":"If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Reserved Phrase Example slice at Members.Observation maps to related.target (slice at = related; slice on = type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occurring at related.target . Instead, the slice at = related ensures that the slicing is occurring at the related element.","title":"Moving the Slice Location (slice at)"},{"location":"cimpl6LanguageReference/#slicing-examples","text":"Phrase Example slice on / slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) slice on / slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) slice on Laterality maps to qualifier (slice on = concept)","title":"Slicing Examples"},{"location":"cimpl6LanguageReference/#appendix-a-changes-from-cimpl-5x","text":"For those who have created detailed models using CIMPL 5.0, there have been significant grammar changes to CIMPL 6.0. The table below summarizes these changes: Change Type Change Description CIMPL 5.0 Example CIMPL 6.0 Example Section New keyword only eliminates all value choices except one None FindingResult only concept Only Constraint New keyword Property is required to define properties for an Entry or Element. 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword New keyword Group is required to a reusable collection of properties, that is not an Entry . None Group: Address Group Keyword Replace EntryElement keyword replaced by Entry EntryElement: CourseOfTreatmentPerformed Entry: CourseOfTreatmentPerformed Element Keyword Replace Based on keyword replaced by Parent Based on: Observation Parent: Observation Parent Keyword Syntax change Cardinality is specified after the property or class name 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Keyword , Cardinality Constraint Replace is constraint for fixed values replaced by = FindingTopicCode is LNC#48676-1 FindingTopicCode = LNC#48676-1 Field Constraints Replace substitution of a more specific element derived from a parent element using is type keyword replaced by substitute . Specimen is type BreastSpecimen Specimen substitute BreastSpecimen Substitute Replace code , Coding , and CodeableConcept are replaced by a new primitive concept Value: CodeableConcept from AttributionCategoryVS Value: concept from AttributionCategoryVS Primitives Replace must be , should be , could be , and if covered value set constraints are obsolete and replaced by (required) , (preferred) , (extensible) , and (example) Type from BreastSpecimenTypeVS if covered Type from BreastSpecimenTypeVS (extensible) Value Set Binding Constraint Replace ref() is now obsolete. value is type replaced by substitute and bracket notation denoting value choices SourceSpecimen value is type ref(BreastSpecimen) SourceSpecimen[Specimen] substitute BreastSpecimen Mapping to References","title":"Appendix A: Changes from CIMPL 5.x"},{"location":"cimpl6ObjectiveFHIR/","text":"CIMPL Class Library (aka Objective FHIR) Note: This documentation is in draft form. Preface Purpose of this Document This document presents an overview of the CIMPL class library (also known as Objective FHIR, or OBF), a set of pre-mapped datatypes and classes that can be used as the basis for a clinical model. Use of OBF with CIMPL is optional, but recommended. Using only the OBF datatypes with CIMPL is also possible and appropriate for some projects. Intended Audience The CIMPL Class Library Guide is targeted to modelers with some familiarity with CIMPL. Experience with object-oriented modeling, concepts such as class inheritance, is assumed. Familiarity with FHIR is helpful as the tutorial references FHIR artifacts (such as Resources, Elements, etc.) Prerequisite This guide assumes you have: Installed the latest version of the SHR-CLI software as documented in CIMPL SetUp and Installation (preferably installed in the ~/cimpl/shr-cli directory) A text editor (preferably VSCode with the vs-code-language-cimpl extension, but not required) Reviewed the Hello World Tutorial . Table of Contents CIMPL Class Library (aka Objective FHIR) Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Overview Philosophy Meta-Model Mapping to FHIR Coverage Subclassing Subclassing, Part 2 Comparison Between Profiling Tools Key Concepts Data Types Naming OBF Actors OBF Event Times Building Blocks Class Hierarchy Resource, Domain Resource, Metadata Information Item EntityOrRole Clinical Statement Future Appendix: Relationship to Other Initiatives Overview Objective FHIR (\"OBF\") is an object-oriented abstraction of FHIR. It provides modelers a way to define a detailed clinical information model by subclassing, extending, and constraining a pre-existing class library. These classes can then be translated automatically into FHIR profiles, FHIR Implementation Guides, data dictionaries, schemas, and other assets, using a choice of the three major FHIR versions: DSTU 2, STU 3, and R4. OBF serves as the base class library for the Clinical Information Modeling and Profiling Language (CIMPL). Use of OBF with CIMPL is optional, but recommended. \"blank slate\" use of CIMPL is also possible and appropriate for some projects. ( TO DO: Move discussion of Blank Slate approach to here ) Philosophy OBF classes resemble FHIR R4, but differ in carefully considered ways that increase consistency and reusability of the resulting models and profiles. Objective FHIR allows data structures of all sorts to be reused. This means that individual data elements and frequently-occurring structures can be defined once and used repeatedly. Objective FHIR addresses one of the most frequent criticisms of FHIR, namely, its lack of consistency . FHIR not only uses different names for equivalent things in different resources, but sometimes, entirely different modeling approaches. This is almost certainly the result of having resources managed by separate HL7 work groups. OBF creates a layer that smooths over many of these differences, not for aesthetic or theoretical reasons, but to make the whole framework easier to learn, enable greater code reuse, and most importantly, to make the resulting clinical models more interoperable . OBF also insulates modelers from differences between FHIR versions. The OBF classes are based on FHIR R4, but the same content is mapped to DSTU 2 and STU 3. This means you can model once and publish the same content across multiple FHIR versions. Meta-Model Objective FHIR has been developed using the Clinical Information Modeling and Profiling Language (CIMPL). CIMPL is a powerful, FHIR-aware, high-level language for creating clinical models. Expressing the model in CIMPL means that Objective FHIR models can automatically be turned into FHIR Profiles, Implementation Guides, data dictionaries, and other useful artifacts, across multiple FHIR versions. Conceptually, there is nothing that prevents the same model from be expressed in other formalisms, some of which are mentioned in the Appendix . However, OBF with CIMPL is a complete, proven, ready-made solution that has created rich FHIR content, such as the mCODE Implementation Guide . Mapping to FHIR One of the significant benefits of the OBF framework, compared to using CIMPL tabula rasa , is that mapping to FHIR has already been done for you. In most cases, any model you create will be mapped to FHIR without additional effort. The only exceptions are when you create a new class that doesn't inherit from a pre-mapped OBF class (rare), override a previous mapping (very rare), or add an extension to a pre-mapped class that requires mapping to a nested extension (even more rare). Coverage Not all FHIR R4 resources are covered by Objective FHIR. We are working to expand the coverage. The model documentation is the best source to determine if OBF covers your needs. If you need additional class coverage for your project, please contact the project team . Subclassing To continue the scenario above, suppose you want a more specific concept of OccurrencePeriod applied to a surgical procedure. In this case, we can subclass: Element: SurgicalProcedureOccurrencePeriod Parent: OccurrencePeriod Description: The period of time for a surgery, from the first incision time to the last incision close time, as defined by https://manual.jointcommission.org/releases/archive/TJC2010B/DataElem0127.html. The structure and content of OccurrenceTime is inherited by the new class (cardinalities, data type, the fact that the start time must be less than the end time, etc.), so repeating that information is unnecessary. Don't repeat yourself (DRY) is a major benefit of inheritance. The DRY principle is stated as \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system\". Subclassing, Part 2 The previous example is trivial, but almost everything you do in OBF will involve creating new classes from existing ones. Here's a more involved example: Entry: GenomicsReport Parent: DiagnosticReport Description: \"Genetic analysis summary report. The report may include one or more tests, with two distinct test types... (truncated)\" Property: SpecimenType 0..1 Property: RegionStudied 0..* Code from https://www.ncbi.nlm.nih.gov/gtr (preferred) Category 1..1 Category = DS#GE \"Genetics\" Observation includes GeneticVariantFound 0..* includes GeneticVariantTested 0..* SpecimenType from GeneticSpecimenTypeVS (extensible) Although the purpose of this guide is not to teach CIMPL, this is worth pulling apart: The first two lines create the class GenomicsReport , based on DiagnosticReport . Entry is a CIMPL building block that roughly corresponds to a FHIR resource, and Parent obviously identifies the parent class. Following the Description , two new properties (with cardinalities) are introduced: SpecimenType and RegionStudied . Using CIMPL, you don't fuss with extensions -- that will happen automatically when the class is mapped to FHIR. After the keyword section, there is a series of constraint statements. Without delving into details, these statements say: The Code identifying the report should preferably come from the Genetic Test Registry . The Category will occur exactly once, and will be fixed to the code GE (Genetics) drawn from a code system aliased to DS (mapped elsewhere to http://terminology.hl7.org/CodeSystem/v2-0074 ). The Observation attribute should include zero or more GeneticVariantFound observations and zero or more GeneticVariantTested observations. The includes statement is the way CIMPL slices arrays. Finally, the SpecimenType, which we've just added as a new class property, is extensibly bound to the value set GeneticSpecimenTypeVS . We now have a general-purpose genomics report. We can use this class in the form of a FHIR profile, or use it as a parent for defining more specific genomics reports, perhaps AncestryDotComGenomicsReport . Comparison Between Profiling Tools In FHIR terms, subclassing is akin to profiling profiles, which can be achieved in a number of tools, notably Forge and Trifolia . Both these tools are extremely well-done, and supported by commercial entities. Forge and Trifolia are essentially graphical user interfaces on top of StructureDefinitions, the low-level \"assembly language\" of FHIR. By contrast, CIMPL is like a high-level programming language. Experience has shown that creating and maintaining a complex project is much easier when you use a language, compared to a visual editor. That's why programming languages are almost always text-based, while visual programming has had comparatively little uptake. Even Unified Modeling Language (UML) - a model-diagramming standard that has been around for decades - is fraught with portability problems , despite having its own exchange format, XMI . As stated by Thomas Beale , \"Architects these days tend to limit their use of UML to package diagrams and a few illustrative class diagrams, while developers tend to go straight to code or use tools that pretty-print extracted textual forms of software such as swagger and apiary.\" (emphasis added). CIMPL takes the latter approach, producing a variety of explanatory and implementable assets generated from CIMPL code, rather than vice versa. When clinical modeling projects grow to a certain size, activities increasingly revolve around repeatedly revisiting, revising, refactoring, and renaming. As a text language, CIMPL allows you to do global search and replace, which will become your new BFF . Using text also enables meaningful source code control. CIMPL files can be hosted in Github, which gives model developers the ability distribute work across multiple branches, compare changes (with meaningful diffs), and automatically merge contributions, allowing projects to scale in ways that visual editors can't support. Key Concepts Data Types The primitive types used in OBF are those defined in CIMPL, which correspond one-to-one with FHIR primitives, except for the way CIMPL handles coded types . Complex data types in OBF are also the same as FHIR R4. They are found in the obf.datatype namespace. Since complex types like Quantity are ubiquitous, you will almost certainly need to import the obf.datatype into your namespace. This is done using the Uses keyword. Naming Attribute names in OBF may differ from FHIR names. When they do so, it is usually to make the meaning of the attribute more explicit. OBF names are meant to be meaningful outside of the context of a single class. For example, the FHIR attribute Encounter.period is not entirely self-explanatory, especially when period is considered alone, outside of the context provided by Encounter . To be more reusable, OBF uses the name OccurrencePeriod . Coupled with a different event, such as a procedure, the renamed attribute's meaning is more clear. Although an attribute name is rarely a sufficient definition, OBF moves the needle in that direction. OBF Actors Name Description SubjectOfRecord Identifies the person whose clinical record contains the information. The SubjectOfRecord is often the same as the Patient or Subject, but in some cases, the subject of information (called the FocalSubject ) may be different than the SubjectOfRecord. InformationSource The originator or source of the information or request: a practitioner, patient, related person, organization, an algorithm, device, etc. Author The actor who created the item and it responsible for the content (regardless of the information source or who recorded it). If only the author is given, it is assumed the author is the information source and the recorder. FocalSubject The person or entity that the information in this resource relates to, if different than the person of record. Participant An actor (usually a Practitioner, Patient, or Organization but potentially a device or other entity) that participates in a healthcare task or activity. The participant is not necessarily the performer of the action. Performer The actor that carried out the observation or action. Note: Currently, OBF doesn't include the information recorder among the key actors. The recorder is the actor who physically enters the information, as opposed to creating or being responsible for the information. Author is occasionally mapped to a FHIR attribute named recorder when it is apparent that the resource designers assumed the author and recorder are the same. OBF Event Times Name Description CreationDateTime The point in time when an ancillary item (such as a report or image) was created. OccurrenceTimeOrPeriod The time or period when the event occurred. StatementDateTime The time when the documentation of an event, action, or situation was created. RelevantTime The time or time period that the statement addresses, not necessarily when the information is gathered. LastUpdated The last time a record was updated. Building Blocks OBF classes fall into one of four categories, which are the building blocks of CIMPL: Building Block Description Inherits from Analogous FHIR Type Element The lowest-level building block, representing a property-value pair. Element Property or simple extension Group A building block comprised of other building blocks, specifically, other Groups, Elements, and Entries. Group Backbone element or complex extension Entry A building block representing a group of related information, complete enough to support stand-alone interpretation. Entry or Abstract Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Abstract none Class Hierarchy In this section, we describe the overall organization and some key classes in Objective FHIR. A pared-down view of the OBF hierarchy is shown below. For full details of each class, please refer to the OBF Reference Model Specification . The purpose of the hierarchy is two-fold: To define properties uniformly across multiple classes. For example, almost every FHIR resource should have an author, but many don't, and those that do use a variety of different names . It shouldn't be left up to individual resources, managed by different work groups, to each define author themselves. Inevitably, they will define it differently, or forget entirely, as FHIR R4 shows. Inheriting from a common parent prevents that. To provide a set of ready-made classes that users can extend. An example is QuantitativeLaboratoryObservation , based on Observation . FHIR's approach to uniformity is to define certain patterns, such as the request pattern . However, FHIR stops short of actually implementing these patterns across resources. Implementations can't assume all requests have the same core properties, and can't write generic methods for processing requests. Instead, each type of request must be implemented as a one-off. Resource, Domain Resource, Metadata At the top of the OBF hierarchy are the classes Resource and DomainResource. They involve the Metadata group. These classes align with FHIR. Information Item InformationItem includes definitional items, value set definitions, questionnaire, research study, entities such as locations and organizations, people, financial information, etc. While InformationItem has no attributes itself, it serves as a conceptual grouper for things that exist in the clinical world that are not statements about a patient's health or healthcare. EntityOrRole This branch of the hierarchy, which splits into Entity and Role, represent the potential actors in healthcare scenarios. Entities include organizations, locations, devices, medications, and other \"things\", physical and conceptual. Roles are patient, practitioner, related person, and research subject. FHIR models these resources by conflating the role with the person playing the role. Although this is not the optimal model, OBF continues that practice, just to make OBF more obvious to FHIR users. Earlier versions of OBF modeled a person separately from the role(s) that person could play. Clinical Statement ClinicalStatement provides properties and behaviors common to entries in a medical record. This class also allows for common representation of simple data provenance elements: SubjectOfRecord , CareContext ( Encounter or EpisodeOfCare ), and StatementDateTime . Below ClinicalStatement are two classes, SituationStatement and ActionStatement : SituationStatements covers many types of descriptive information, including opinions, evaluations, laboratory results, genomic data, and social information. ActionStatements covers requested and performed actions, such as prescribing and taking medications, performing procedures, requesting a service. Future Current work is focused on using the classes defined in Objective FHIR directly in implementations, leveraging automatically generated Javascript classes and methods that, at runtime, translate FHIR resources to and from the logical model classes. This would allow implementers to use object oriented programming in much more powerful ways than available in native FHIR, with its flat class structure and complex extension representations. Appendix: Relationship to Other Initiatives Conceptually, Objective FHIR could be expressed in other modeling frameworks, besides CIMPL. Some of the potential frameworks include: Unified Modeling Language (UML) for structure coupled with Object Constraint Language (OCL) for constraint representation. The Federal Health Information Model initiative (FHIM) has conducted some experiments using Model-Driven Health Tools to try and convert UML/OCL models into FHIR profiles. Basic Meta-Model (BMM) for class hierarchy, coupled with Archetype Description Language (ADL) for constraint representation. BMM/ADL has been used in openEHR . Claude Nanjo of University of Utah has conducted some experiments to try to convert ADL/BMM models into FHIR profiles. Clinical Element Models . CEMs are being used to produce some Clinical Information Modeling Initiative (CIMI) FHIR Implementation Guides . Essential parts of CEM-related tooling are internal to Intermountain Healthcare. Objective FHIR is an open source project , and we welcome contributions.","title":"CIMPL Class Library (aka Objective FHIR)"},{"location":"cimpl6ObjectiveFHIR/#cimpl-class-library-aka-objective-fhir","text":"Note: This documentation is in draft form.","title":"CIMPL Class Library (aka Objective FHIR)"},{"location":"cimpl6ObjectiveFHIR/#preface","text":"","title":"Preface"},{"location":"cimpl6ObjectiveFHIR/#purpose-of-this-document","text":"This document presents an overview of the CIMPL class library (also known as Objective FHIR, or OBF), a set of pre-mapped datatypes and classes that can be used as the basis for a clinical model. Use of OBF with CIMPL is optional, but recommended. Using only the OBF datatypes with CIMPL is also possible and appropriate for some projects.","title":"Purpose of this Document"},{"location":"cimpl6ObjectiveFHIR/#intended-audience","text":"The CIMPL Class Library Guide is targeted to modelers with some familiarity with CIMPL. Experience with object-oriented modeling, concepts such as class inheritance, is assumed. Familiarity with FHIR is helpful as the tutorial references FHIR artifacts (such as Resources, Elements, etc.)","title":"Intended Audience"},{"location":"cimpl6ObjectiveFHIR/#prerequisite","text":"This guide assumes you have: Installed the latest version of the SHR-CLI software as documented in CIMPL SetUp and Installation (preferably installed in the ~/cimpl/shr-cli directory) A text editor (preferably VSCode with the vs-code-language-cimpl extension, but not required) Reviewed the Hello World Tutorial .","title":"Prerequisite"},{"location":"cimpl6ObjectiveFHIR/#table-of-contents","text":"CIMPL Class Library (aka Objective FHIR) Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Overview Philosophy Meta-Model Mapping to FHIR Coverage Subclassing Subclassing, Part 2 Comparison Between Profiling Tools Key Concepts Data Types Naming OBF Actors OBF Event Times Building Blocks Class Hierarchy Resource, Domain Resource, Metadata Information Item EntityOrRole Clinical Statement Future Appendix: Relationship to Other Initiatives","title":"Table of Contents"},{"location":"cimpl6ObjectiveFHIR/#overview","text":"Objective FHIR (\"OBF\") is an object-oriented abstraction of FHIR. It provides modelers a way to define a detailed clinical information model by subclassing, extending, and constraining a pre-existing class library. These classes can then be translated automatically into FHIR profiles, FHIR Implementation Guides, data dictionaries, schemas, and other assets, using a choice of the three major FHIR versions: DSTU 2, STU 3, and R4. OBF serves as the base class library for the Clinical Information Modeling and Profiling Language (CIMPL). Use of OBF with CIMPL is optional, but recommended. \"blank slate\" use of CIMPL is also possible and appropriate for some projects. ( TO DO: Move discussion of Blank Slate approach to here )","title":"Overview"},{"location":"cimpl6ObjectiveFHIR/#philosophy","text":"OBF classes resemble FHIR R4, but differ in carefully considered ways that increase consistency and reusability of the resulting models and profiles. Objective FHIR allows data structures of all sorts to be reused. This means that individual data elements and frequently-occurring structures can be defined once and used repeatedly. Objective FHIR addresses one of the most frequent criticisms of FHIR, namely, its lack of consistency . FHIR not only uses different names for equivalent things in different resources, but sometimes, entirely different modeling approaches. This is almost certainly the result of having resources managed by separate HL7 work groups. OBF creates a layer that smooths over many of these differences, not for aesthetic or theoretical reasons, but to make the whole framework easier to learn, enable greater code reuse, and most importantly, to make the resulting clinical models more interoperable . OBF also insulates modelers from differences between FHIR versions. The OBF classes are based on FHIR R4, but the same content is mapped to DSTU 2 and STU 3. This means you can model once and publish the same content across multiple FHIR versions.","title":"Philosophy"},{"location":"cimpl6ObjectiveFHIR/#meta-model","text":"Objective FHIR has been developed using the Clinical Information Modeling and Profiling Language (CIMPL). CIMPL is a powerful, FHIR-aware, high-level language for creating clinical models. Expressing the model in CIMPL means that Objective FHIR models can automatically be turned into FHIR Profiles, Implementation Guides, data dictionaries, and other useful artifacts, across multiple FHIR versions. Conceptually, there is nothing that prevents the same model from be expressed in other formalisms, some of which are mentioned in the Appendix . However, OBF with CIMPL is a complete, proven, ready-made solution that has created rich FHIR content, such as the mCODE Implementation Guide .","title":"Meta-Model"},{"location":"cimpl6ObjectiveFHIR/#mapping-to-fhir","text":"One of the significant benefits of the OBF framework, compared to using CIMPL tabula rasa , is that mapping to FHIR has already been done for you. In most cases, any model you create will be mapped to FHIR without additional effort. The only exceptions are when you create a new class that doesn't inherit from a pre-mapped OBF class (rare), override a previous mapping (very rare), or add an extension to a pre-mapped class that requires mapping to a nested extension (even more rare).","title":"Mapping to FHIR"},{"location":"cimpl6ObjectiveFHIR/#coverage","text":"Not all FHIR R4 resources are covered by Objective FHIR. We are working to expand the coverage. The model documentation is the best source to determine if OBF covers your needs. If you need additional class coverage for your project, please contact the project team .","title":"Coverage"},{"location":"cimpl6ObjectiveFHIR/#subclassing","text":"To continue the scenario above, suppose you want a more specific concept of OccurrencePeriod applied to a surgical procedure. In this case, we can subclass: Element: SurgicalProcedureOccurrencePeriod Parent: OccurrencePeriod Description: The period of time for a surgery, from the first incision time to the last incision close time, as defined by https://manual.jointcommission.org/releases/archive/TJC2010B/DataElem0127.html. The structure and content of OccurrenceTime is inherited by the new class (cardinalities, data type, the fact that the start time must be less than the end time, etc.), so repeating that information is unnecessary. Don't repeat yourself (DRY) is a major benefit of inheritance. The DRY principle is stated as \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system\".","title":"Subclassing"},{"location":"cimpl6ObjectiveFHIR/#subclassing-part-2","text":"The previous example is trivial, but almost everything you do in OBF will involve creating new classes from existing ones. Here's a more involved example: Entry: GenomicsReport Parent: DiagnosticReport Description: \"Genetic analysis summary report. The report may include one or more tests, with two distinct test types... (truncated)\" Property: SpecimenType 0..1 Property: RegionStudied 0..* Code from https://www.ncbi.nlm.nih.gov/gtr (preferred) Category 1..1 Category = DS#GE \"Genetics\" Observation includes GeneticVariantFound 0..* includes GeneticVariantTested 0..* SpecimenType from GeneticSpecimenTypeVS (extensible) Although the purpose of this guide is not to teach CIMPL, this is worth pulling apart: The first two lines create the class GenomicsReport , based on DiagnosticReport . Entry is a CIMPL building block that roughly corresponds to a FHIR resource, and Parent obviously identifies the parent class. Following the Description , two new properties (with cardinalities) are introduced: SpecimenType and RegionStudied . Using CIMPL, you don't fuss with extensions -- that will happen automatically when the class is mapped to FHIR. After the keyword section, there is a series of constraint statements. Without delving into details, these statements say: The Code identifying the report should preferably come from the Genetic Test Registry . The Category will occur exactly once, and will be fixed to the code GE (Genetics) drawn from a code system aliased to DS (mapped elsewhere to http://terminology.hl7.org/CodeSystem/v2-0074 ). The Observation attribute should include zero or more GeneticVariantFound observations and zero or more GeneticVariantTested observations. The includes statement is the way CIMPL slices arrays. Finally, the SpecimenType, which we've just added as a new class property, is extensibly bound to the value set GeneticSpecimenTypeVS . We now have a general-purpose genomics report. We can use this class in the form of a FHIR profile, or use it as a parent for defining more specific genomics reports, perhaps AncestryDotComGenomicsReport .","title":"Subclassing, Part 2"},{"location":"cimpl6ObjectiveFHIR/#comparison-between-profiling-tools","text":"In FHIR terms, subclassing is akin to profiling profiles, which can be achieved in a number of tools, notably Forge and Trifolia . Both these tools are extremely well-done, and supported by commercial entities. Forge and Trifolia are essentially graphical user interfaces on top of StructureDefinitions, the low-level \"assembly language\" of FHIR. By contrast, CIMPL is like a high-level programming language. Experience has shown that creating and maintaining a complex project is much easier when you use a language, compared to a visual editor. That's why programming languages are almost always text-based, while visual programming has had comparatively little uptake. Even Unified Modeling Language (UML) - a model-diagramming standard that has been around for decades - is fraught with portability problems , despite having its own exchange format, XMI . As stated by Thomas Beale , \"Architects these days tend to limit their use of UML to package diagrams and a few illustrative class diagrams, while developers tend to go straight to code or use tools that pretty-print extracted textual forms of software such as swagger and apiary.\" (emphasis added). CIMPL takes the latter approach, producing a variety of explanatory and implementable assets generated from CIMPL code, rather than vice versa. When clinical modeling projects grow to a certain size, activities increasingly revolve around repeatedly revisiting, revising, refactoring, and renaming. As a text language, CIMPL allows you to do global search and replace, which will become your new BFF . Using text also enables meaningful source code control. CIMPL files can be hosted in Github, which gives model developers the ability distribute work across multiple branches, compare changes (with meaningful diffs), and automatically merge contributions, allowing projects to scale in ways that visual editors can't support.","title":"Comparison Between Profiling Tools"},{"location":"cimpl6ObjectiveFHIR/#key-concepts","text":"","title":"Key Concepts"},{"location":"cimpl6ObjectiveFHIR/#data-types","text":"The primitive types used in OBF are those defined in CIMPL, which correspond one-to-one with FHIR primitives, except for the way CIMPL handles coded types . Complex data types in OBF are also the same as FHIR R4. They are found in the obf.datatype namespace. Since complex types like Quantity are ubiquitous, you will almost certainly need to import the obf.datatype into your namespace. This is done using the Uses keyword.","title":"Data Types"},{"location":"cimpl6ObjectiveFHIR/#naming","text":"Attribute names in OBF may differ from FHIR names. When they do so, it is usually to make the meaning of the attribute more explicit. OBF names are meant to be meaningful outside of the context of a single class. For example, the FHIR attribute Encounter.period is not entirely self-explanatory, especially when period is considered alone, outside of the context provided by Encounter . To be more reusable, OBF uses the name OccurrencePeriod . Coupled with a different event, such as a procedure, the renamed attribute's meaning is more clear. Although an attribute name is rarely a sufficient definition, OBF moves the needle in that direction.","title":"Naming"},{"location":"cimpl6ObjectiveFHIR/#obf-actors","text":"Name Description SubjectOfRecord Identifies the person whose clinical record contains the information. The SubjectOfRecord is often the same as the Patient or Subject, but in some cases, the subject of information (called the FocalSubject ) may be different than the SubjectOfRecord. InformationSource The originator or source of the information or request: a practitioner, patient, related person, organization, an algorithm, device, etc. Author The actor who created the item and it responsible for the content (regardless of the information source or who recorded it). If only the author is given, it is assumed the author is the information source and the recorder. FocalSubject The person or entity that the information in this resource relates to, if different than the person of record. Participant An actor (usually a Practitioner, Patient, or Organization but potentially a device or other entity) that participates in a healthcare task or activity. The participant is not necessarily the performer of the action. Performer The actor that carried out the observation or action. Note: Currently, OBF doesn't include the information recorder among the key actors. The recorder is the actor who physically enters the information, as opposed to creating or being responsible for the information. Author is occasionally mapped to a FHIR attribute named recorder when it is apparent that the resource designers assumed the author and recorder are the same.","title":"OBF Actors"},{"location":"cimpl6ObjectiveFHIR/#obf-event-times","text":"Name Description CreationDateTime The point in time when an ancillary item (such as a report or image) was created. OccurrenceTimeOrPeriod The time or period when the event occurred. StatementDateTime The time when the documentation of an event, action, or situation was created. RelevantTime The time or time period that the statement addresses, not necessarily when the information is gathered. LastUpdated The last time a record was updated.","title":"OBF Event Times"},{"location":"cimpl6ObjectiveFHIR/#building-blocks","text":"OBF classes fall into one of four categories, which are the building blocks of CIMPL: Building Block Description Inherits from Analogous FHIR Type Element The lowest-level building block, representing a property-value pair. Element Property or simple extension Group A building block comprised of other building blocks, specifically, other Groups, Elements, and Entries. Group Backbone element or complex extension Entry A building block representing a group of related information, complete enough to support stand-alone interpretation. Entry or Abstract Resource or Profile Abstract A special type of Entry that cannot be instantiated, and will not be present in the target mapping. Abstract none","title":"Building Blocks"},{"location":"cimpl6ObjectiveFHIR/#class-hierarchy","text":"In this section, we describe the overall organization and some key classes in Objective FHIR. A pared-down view of the OBF hierarchy is shown below. For full details of each class, please refer to the OBF Reference Model Specification . The purpose of the hierarchy is two-fold: To define properties uniformly across multiple classes. For example, almost every FHIR resource should have an author, but many don't, and those that do use a variety of different names . It shouldn't be left up to individual resources, managed by different work groups, to each define author themselves. Inevitably, they will define it differently, or forget entirely, as FHIR R4 shows. Inheriting from a common parent prevents that. To provide a set of ready-made classes that users can extend. An example is QuantitativeLaboratoryObservation , based on Observation . FHIR's approach to uniformity is to define certain patterns, such as the request pattern . However, FHIR stops short of actually implementing these patterns across resources. Implementations can't assume all requests have the same core properties, and can't write generic methods for processing requests. Instead, each type of request must be implemented as a one-off.","title":"Class Hierarchy"},{"location":"cimpl6ObjectiveFHIR/#resource-domain-resource-metadata","text":"At the top of the OBF hierarchy are the classes Resource and DomainResource. They involve the Metadata group. These classes align with FHIR.","title":"Resource, Domain Resource, Metadata"},{"location":"cimpl6ObjectiveFHIR/#information-item","text":"InformationItem includes definitional items, value set definitions, questionnaire, research study, entities such as locations and organizations, people, financial information, etc. While InformationItem has no attributes itself, it serves as a conceptual grouper for things that exist in the clinical world that are not statements about a patient's health or healthcare.","title":"Information Item"},{"location":"cimpl6ObjectiveFHIR/#entityorrole","text":"This branch of the hierarchy, which splits into Entity and Role, represent the potential actors in healthcare scenarios. Entities include organizations, locations, devices, medications, and other \"things\", physical and conceptual. Roles are patient, practitioner, related person, and research subject. FHIR models these resources by conflating the role with the person playing the role. Although this is not the optimal model, OBF continues that practice, just to make OBF more obvious to FHIR users. Earlier versions of OBF modeled a person separately from the role(s) that person could play.","title":"EntityOrRole"},{"location":"cimpl6ObjectiveFHIR/#clinical-statement","text":"ClinicalStatement provides properties and behaviors common to entries in a medical record. This class also allows for common representation of simple data provenance elements: SubjectOfRecord , CareContext ( Encounter or EpisodeOfCare ), and StatementDateTime . Below ClinicalStatement are two classes, SituationStatement and ActionStatement : SituationStatements covers many types of descriptive information, including opinions, evaluations, laboratory results, genomic data, and social information. ActionStatements covers requested and performed actions, such as prescribing and taking medications, performing procedures, requesting a service.","title":"Clinical Statement"},{"location":"cimpl6ObjectiveFHIR/#future","text":"Current work is focused on using the classes defined in Objective FHIR directly in implementations, leveraging automatically generated Javascript classes and methods that, at runtime, translate FHIR resources to and from the logical model classes. This would allow implementers to use object oriented programming in much more powerful ways than available in native FHIR, with its flat class structure and complex extension representations.","title":"Future"},{"location":"cimpl6ObjectiveFHIR/#appendix-relationship-to-other-initiatives","text":"Conceptually, Objective FHIR could be expressed in other modeling frameworks, besides CIMPL. Some of the potential frameworks include: Unified Modeling Language (UML) for structure coupled with Object Constraint Language (OCL) for constraint representation. The Federal Health Information Model initiative (FHIM) has conducted some experiments using Model-Driven Health Tools to try and convert UML/OCL models into FHIR profiles. Basic Meta-Model (BMM) for class hierarchy, coupled with Archetype Description Language (ADL) for constraint representation. BMM/ADL has been used in openEHR . Claude Nanjo of University of Utah has conducted some experiments to try to convert ADL/BMM models into FHIR profiles. Clinical Element Models . CEMs are being used to produce some Clinical Information Modeling Initiative (CIMI) FHIR Implementation Guides . Essential parts of CEM-related tooling are internal to Intermountain Healthcare. Objective FHIR is an open source project , and we welcome contributions.","title":"Appendix: Relationship to Other Initiatives"},{"location":"cimpl6ToolingReference/","text":"CIMPL 6.0 Tooling Reference Preface Purpose of this Document This reference manual is a comprehensive guide to the command line interface, auxiliary files, and configurations needed to create a FHIR Implementation Guide (IG) from CIMPL ( C linical I nformation M odeling P rofiling L anguage). Intended Audience The CIMPL Tooling Reference is targeted to people doing model development using CIMPL and producing FHIR Implementation Guides. Familiarity with FHIR is helpful as the tutorial references FHIR artifacts (such as Resources, Elements, etc.) Prerequisite This guide assumes you have: Installed the latest version of the SHR-CLI software as documented in CIMPL SetUp and Installation . Created set of CIMPL Language files (classes, value sets, and maps) representing your clinical model (see CIMPL Language Reference Manual for details). Reviewed the In-Depth Tutorial . Table of Contents CIMPL 6.0 Tooling Reference Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Overview Relationship of CIMPL Models and Implementation Guides Conventions Suggested Directory Structure Suggested File Naming Inputs to SHR-CLI CIMPL Files Setting up the VSCode Authoring Navigating a CIMPL Model within VSCode Configuration File Filter Strategy Configuration Parameters Implementation Guide Configuration Parameters Provenance Information Configuration Parameters Front Matter Files FHIR Examples Package List File Content Profile File Executing SHR-CLI Command Line Addressing Error Messages Outputs from SHR-CLI FHIR Export Logical Model Export Model Documentation Export Data Dictionary Export JSON Schema Export Creating the Implementation Guide Appendix A: Error Messages Table of Contents Error Code Structure Parsing Errors Warning Codes Compilation Error Codes Mapping Error Codes Overview The CIMPL Tooling, also called SHR-CLI (Standard Health Record Command Line Interface), is the engine that imports a set of inputs, including CIMPL language files, and exports FHIR and other outputs, as shown below: The inputs to SHR-CLI include: CIMPL Language files , including class files, value set files, and mapping files that define your clinical information model, A Configuration file that contains directives to the tooling, and points to other resources, An optional Content Profile file, which specifies Must-Support elements and profiling options specific to an IG, One or more Front Matter files, which are the narratives and graphics that introduce the IG, FHIR Examples that are to be included in the IG, and A Package List that has information required for building the IG. The inputs are processed in the following sequence: The user issues a build command through the command-line interface (CLI) to launch SHR-CLI. The CIMPL tooling imports definitions from CIMPL files (class, value set, and map files). SHR-CLI reports any errors in the CIMPL definitions. Continuing the build process, SHR-CLI selects a subset of the data models to include in the IG, according to the filter strategy . To complete the build process, SHR-CLI exports the selected CIMPL definitions into desired formats, such as FHIR profiles, data dictionaries, etc. The exports can be selected through command line options . The user issues a separate command to produce the IG. SHR-CLI produces one or all of the following outputs, depending on configuration parameters: FHIR Profiles, Extensions, Value Sets that form the core content of the IG, A Logical Model corresponding to the CIMPL class definitions, expressed as FHIR StructureDefinitions, JSON Schema for the profiles defined by the IG, A Data Dictionary that lists the Must-Support data elements in the IG, as well as value sets and value set members, Model Documentation in the form of a Javadoc-like browser that allows one to see the hierarchical class relationships in the logical model. Relationship of CIMPL Models and Implementation Guides It is important to understand the relationship between models defined in CIMPL and implementation guide(s) created from those models. The state-of-practice for FHIR IGs is still evolving, but currently, most IGs are developed by separate groups and define their own data models, as follows: The drawback of this approach is that different IGs can require very similar data models. If different data models are developed by different teams, interoperability will suffer. In CIMPL, data models are independent of IGs. IGs are consumers of models, rather than owners of models (although new models can certainly be created in the context of IG development). Each IG uses a different subset of models, reflecting the different use cases they address, but the commonality of data models assures interoperability between the use cases. This idea is illustrated below: Much of what is discussed subsequently reflects this conceptual picture of the relationship between CIMPL models and IGs. Conventions Suggested Directory Structure The SHR-CLI tooling does not require a particular directory structure. However, following conventions makes the process of managing the requisite files much easier. Here is an example of the suggested arrangement that assumes the same IG can be produced under FHIR STU3 and R4: \u251c\u2500\u2500 shr-cli-6.5.0 // Tooling location | ... | \u251c\u2500\u2500 spec // Main specification directory | \u251c\u2500\u2500 ns-namespace1 // Namespace directories | | \u251c\u2500\u2500 namespace1-foo.txt // class file(s) | | \u251c\u2500\u2500 namespace1-bar.txt | | \u251c\u2500\u2500 namespace1-foo-vs.txt // value set file(s) | | \u251c\u2500\u2500 namespace1-bar-vs.txt | | \u251c\u2500\u2500 namespace1-foo-map-stu3.txt // map(s) for FHIR STU3 | | \u251c\u2500\u2500 namespace1-bar-map-stu3.txt | | \u251c\u2500\u2500 namespace1-foo-map-r4.txt // map(s) for FHIR r4 | | \u2514\u2500\u2500 namespace1-bar-map-r4.txt | \u251c\u2500\u2500 ns-namespace2 | | ... | \u251c\u2500\u2500 ns-namespace3 | | ... | | ... | \u251c\u2500\u2500 ig-myguide1 // IG directories | | \u251c\u2500\u2500 myguide1-examples // directory of examples | | | \u251c\u2500\u2500 example1 | | | \u2514\u2500\u2500 example2 | | \u251c\u2500\u2500 myguide1-frontmatter // directory containing narratives | | | \u251c\u2500\u2500 index.html | | | \u251c\u2500\u2500 picture.png | | | \u2514\u2500\u2500 another-page.html | | \u251c\u2500\u2500 myguide1-stu3-cp.txt // content profile file for FHIR STU3 IG | | \u251c\u2500\u2500 myguide1-r4-cp.txt // content profile file for FHIR R4 IG | | \u251c\u2500\u2500 myguide1-stu3-plist.json // package list for FHIR STU3 IG | | \u251c\u2500\u2500 myguide1-r4-plist.json // package list for FHIR R4 IG | | \u251c\u2500\u2500 myguide1-stu3-config.json // config file for FHIR STU3 IG | | \u2514\u2500\u2500 myguide1-r4-config.json // config file for FHIR R4 IG | \u251c\u2500\u2500 ig-myguide2 | | ... In this reference guide, we will refer to several directories: Tooling Directory - this the directory where the SHR-CLI tooling has been installed. Any convenient directory can be used. For easy identification, we recommend the tooling version number be included in the directory name. Specification Directory - this is the top level directory where the input files and are located, usually arranged in sub-folders. Any convenient directory can be used. If you are using a source code control system such as Github to manage your development, this could be where the repository is checked out to your local machine. Namespace Directories - these directories, located under the Specification Directory, contains CIMPL language files for a single namespace. The name of the directory should be prefixed with ns- followed by the shortname or acronym of the namespace followed . IG Directories - these directories, under the specification directory contain files specific to a given implementation guide. There are subdirectories containing the front matter and examples, and individual configuration, content profile, and package list files. These files can be specific to a FHIR release, since the same IG could be created using different versions of FHIR. Note: There is currently no way to combine profiles for multiple FHIR versions in single IG. Suggested File Naming The naming of configuration, content profiles, and package list files is arbitrary, but it is useful for different teams to follow similar conventions. The suggested approach to naming uses variations on the same shortened IG name, as follows: Configuration file: ig-<guide-name>-config.json Content Profile file: ig-<guide-name>-cp.txt Package List file: ig-<guide-name>-plist.json If your project will support more than one FHIR version, the FHIR version should be included: Configuration file: ig-<guide-name>-<FHIR Version>-config.json Content Profile file: ig-<guide-name>-<FHIR Version>-cp.txt Package List file: ig-<guide-name>-<FHIR Version>-plist.json where FHIR version is dstu2, stu3, or r4. Inputs to SHR-CLI CIMPL Files Any text editor can be used to write CIMPL grammar. However, VSCode editor is recommended to take advantage of a CIMPL plug-in. Setting up the VSCode Authoring Note: VSCode UI screenshots in this section were taken from a MacOS environment. While the overall functionality is the same across supported OS platforms, installation and configuration specifics might differ. Reference the VSCode documentation pertinent to your OS platform. Download the VSCode editor . Open VSCode, open the extensions panel, and search for the extension vscode-lang-cimpl . The figure below shows where to find VSCode extensions on MacOS (on Windows, navigate View -> Extensions ). Alternatively, select the extension icon (the squarish icon on the far left). Navigating a CIMPL Model within VSCode The inherited properties of Groups and Entries can be previewed in the following ways: Hovering over the element : This provides a drop-down list of all properties and cardinality of a Group or Entry (including inherited properties). Placing the cursor on the class declaration, right-click and select Peek Definition : This will display a drop-down window with a preview of the definition. The name and location of the file will be displayed although the entire file will not be opened. Placing the cursor on a property declaration and right-clicking option Go to Definition : This will redirect the editor to location of the definition, opening the file if necessary. Hovering over the element: Using Peek Definition : Using Go to Definition : Configuration File SHR-CLI requires a configuration file to run. The name of this file is typically specified on the command line using the -c command line option . If the name is not specified, the tooling looks for a file named config.json in the working directory. If that cannot be found, or the contents of the configuration file are invalid, an error message is returned. The configuration file is a JSON file with the following parameters: Parameter Type Description projectName string The full, official name of the project, for example \"HL7 FHIR Implementation Guide: minimal Common Oncology Data Elements (mCODE) Release 1 - US Realm, STU Ballot 1\" projectShorthand string A shorthand name for the project, such as \"mcode\". projectURL string The primary URL for the project, such as \"http://hl7.org/fhir/us/mcode/\" fhirURL string The FHIR IG URL for the project, often the same as the projectURL. (TO DO: clarify the difference between projectURL, fhirURL, and entryTypeURL) fhirTarget string The FHIR version this IG will be based on, currently a choice of \"FHIR_R4\" , \"FHIR_STU_3\" , or \"FHIR_DSTU_2\" entryTypeURL string The root URL for the JSON schema EntryType field. (TO DO: clarify where and how this is used) filterStrategy {} A JSON object containing configuration for filtering ( see below ). contentProfile string The file name of the content profile for the project. implementationGuide {} A JSON object containing configuration for IG publishing ( see below ). copyrightYear string The copyright year to include in the documentation. publisher string The name of the publisher for the project, which for HL7 projects, should be the sponsoring workgroup, for example, \"HL7 International Clinical Interoperability Council\". contact [] A JSON array containing HL7 FHIR R4 ContactPoint objects . provenanceInfo {} A JSON object specifying author and other information ( see below ) Filter Strategy Configuration Parameters Between the import stage and the export stage, there is a filtering stage (see CIMPL Tooling Overview ). Filtering is useful when specification directory contains namespaces that or entries that are outside the scope of the current IG, and should not be included in the IG. Filtering removes unwanted namespaces and entries to limit the scope of the exports, and subsequently, the IG. The contents of the filterStrategy object are as follows: Parameter Type Description filter boolean A value indicating whether to enable filtering. If filter is true , then the filtering operation will occur. Otherwise, no filtering will occur. (Also, if the filterStrategy parameter is entirely omitted, no filtering will occur.) strategy string The strategy for specification filtering, either \"namespace\", \"element\", or \"hybrid\". target [] An array of strings containing the names of Entries, Namespaces, or both. The \"element\" strategy filters the imported classes to include each Entry listed in the target array, and their recursive dependencies. The \"namespace\" strategy filters the imported classes to include only Entries in the namespaces listed in the target array, and their recursive dependencies. The \"hybrid\" strategy filters the imported classes to include each Entry listed in the target array and all Entries in every namespace listed in the target array, and their recursive dependencies. When specifying an Entry in the target array, use the fully qualified name (FQN) format. Implementation Guide Configuration Parameters These configurations are used to control the production of the IG. The contents of the implementationGuide object are as follows: Parameter Type Description npmName string The assigned node package manager name for this IG, for example \"hl7.fhir.us.mcode\". The npm name is usually assigned by HL7. version string The version of this IG (not necessarily the version of FHIR), usually in the form major.minor.revision , for example, \"3.0.1\" ballotStatus string The HL7 ballot status of the IG (e.g., STU1 Ballot, Continuous Integration Build, etc.) packageList string The name of the file to use as the IG's package list , relative to the Specification Directory. includeLogicalModels boolean A \"true\" or \"false\" value indicating whether to include logical models in the IG. includeModelDoc boolean A \"true\" or \"false\" value indicating whether to include the model documentation in the IG. indexContent string The name of the file or folder containing the front matter , relative to the Specification Directory, for example, \"ig-mcode/IndexFolder-Oncocore\". If the indexContent is a folder, then it must contain an index.html file whose contents will be used as the body of the IG home page. extraResources string The name of the folder containing extra JSON resources to include in the IG, one file per resource. Currently, the following resource types are supported: SearchParameter , OperationDefinition , CapabilityStatement (STU3+), Conformance (DSTU2). If files are detected, links are added to the navigation menu as necessary. examples string The name of the folder containing examples (one example per file) to include in the IG, for example, \"ig-mcode/Examples-mCODE-r4\". We recommend the individual example file name match the id in the example file (with .json extension added). The example's meta.profile must match the canonical URL for the profile it exemplifies (e.g. \"meta\": { \"profile\": [ \"http://hl7.org/fhir/us/breastcancer/StructureDefinition/oncology-BreastCancerPresenceStatement\" ] } ). If no examples folder is specified, and a folder named \"fhir-examples\" exists in the specification directory, it will be used as the examples folder. historyLink string The URL for the page containing the IG's history information. (TO DO: clarify where and how this is used) changesLink string The URL to a site where users can request changes (shown in page footer) (TO DO: clarify where and how this is used) primarySelectionStrategy {} The strategy for selection of what is primary in the IG (see below). The primary selection strategy causes certain profiles to be displayed in a \"Primary\" section at the top list of profiles. All other exported profiles are listed in a \"Supporting\" section below the \"Primary\" section. The contents of the primarySelectionStrategy object are as follows: Parameter Type Description strategy string The strategy to follow for primary selection, either \"namespace\", \"hybrid\", or \"entry\" (default). primary [] An array of strings containing the namespaces and entries (only used for \"namespace\" and \"hybrid\" strategy). The strategy options are as follows: \"entry\" selects every exported profile as primary. \"namespace\" selects every profile found in the namespaces of the primary array as primary. \"hybrid\" selects every entry listed in the primary array or found in the namespaces in the primary array as primary. When specifying an Entry in the target array, use the fully qualified name (FQN) format. Provenance Information Configuration Parameters (TO DO: document what this structure can contain) Here is an example of provenanceInformation: \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } Front Matter Files Every IG contains some amount of narrative content, which we refer to as the \" front matter \". The front matter is typically a set of hyperlinked HTML files, graphics, and sometimes, downloads. These files are manually authored using any convenient tool; there are no special facilities in CIMPL to author the front matter. If multiple files are involved, they must be placed into a single folder, named in the indexContent parameter of the configuration file . This folder must contain a file named index.html whose contents will be used as the body of the IG home page (the header and footer of the pages are automatically generated). If a single file is used, the file should be named in the indexContent parameter of the configuration file, and a folder is not required. FHIR Examples Configuring FHIR examples to appear in the generated IG involves the following steps: Create a folder which will contain your FHIR examples Modify the CIMPL configuration file to specify the folder containing your examples The name of the folder is arbitrary, however, following directory structure and naming conventions is recommended. The folder location is specified using the \"examples:\" parameter in the CIMPL configuration file. This is illustrated below: Package List File The format and content of this file follows the FHIR specification for package lists . The package list is required for IGs published by HL7. The file containing the package list is named by the packageList parameter of the configuration file . If the packageList parameter is not supplied and no file is found at the default location (packageList.json), and fhirURL is an hl7.org or fhir.org URL (indicating it is an HL7 publication), then a basic package list file will be created. In this case, the IG author should review and modify the file as needed. Here is an example of a package list file: { \"package-id\": \"hl7.fhir.us.mcode\", \"title\": \"HL7 FHIR Implementation Guide: minimal Common Oncology Data Elements (mCODE) Release 1 - US Realm | STU Ballot 1\", \"canonical\": \"http://hl7.org/fhir/us/mcode\", \"list\": [ { \"version\": \"current\", \"desc\": \"Continuous Integration Build (latest in version control)\", \"path\": \"https://build.fhir.org/ig/HL7/fhir-mCODE-ig\", \"status\": \"ci-build\", \"current\": true }, { \"version\": \"0.9.1\", \"date\": \"2019-06-10\", \"desc\": \"Initial version\", \"path\": \"http://hl7.org/fhir/us/mcode/2019Sep\", \"status\": \"draft\", \"sequence\": \"STU 1\", \"fhir-version\": \"4.0.0\" } ] } Content Profile File In FHIR, Must-Support is a boolean flag which allows a profile to indicate that an implementation must be able to process that element in a FHIR instance if it exists. The Content Profile is where Must-Support elements are declared. Note that the Must-Supports are designated at the level of the IG, not the data model. This is because different elements are important for different use cases. For example, one use case may not require date of death to be supported, but another might. Note: Filtering is the mechanism by which entries (profiles) and namespaces are selected for an IG, and content profiles are the mechanism for declaring Must-Support. The syntax of a Content Profile file is: Grammar: ContentProfile 1.0 Namespace: <namespace-1> <Entry-1>: <Element-1> MS <Element-2> MS ... <Entry-2>: ... Namespace: <namespace-2> <Entry-1>: <Element-1> MS <Element-2> MS ... <Entry-2>: ... Here is an excerpt from a Content Profile file: Grammar: ContentProfile 1.0 Namespace: obf ComorbidCondition: Code MS ClinicalStatus MS MedicationStatement: MedicationCodeOrReference MS OccurrenceTimeOrPeriod MS TerminationReason MS TreatmentIntent MS ECOGPerformanceStatus: DataValue MS Namespace: vital BloodPressure: Components.ObservationComponent MS RelevantTime MS BodyHeight: DataValue MS RelevantTime MS BodyWeight: DataValue MS RelevantTime MS Namespace: onco.core PrimaryCancerCondition: Code MS ClinicalStatus MS BodyLocation.Code MS HistologyMorphologyBehavior MS DateOfDiagnosis MS Note: The grammar of the Content Profile file is still evolving and may include additional information in the future. Executing SHR-CLI Command Line The general form of the SHR-CLI execution command is as follows (where $ stands for the command prompt, which could be different on your system): $ node <tooling-directory> <specification-directory> [options] where options include: -c, --config <config> the name of the config file (default: config.json) -l, --log-level <level> the console log level <fatal, error, warn, info, debug, trace> (default: info) -s, --skip <feature> skip an export feature <fhir, json-schema, model-doc, data-dict, all> (default: <none>) -o, --out <out> the path to the output folder (default: out) -m, --log-mode <mode> the console log mode <short,long,json,off> (default: short) -d, --duplicate show duplicate error messages (default: false) -j, --export-es6 export ES6 JavaScript classes (experimental, default: false) -n, --clean Save archive of old output directory and perform clean build (default: false) -h, --help output usage information The options are not order-sensitive. Here is an example of a SHR-CLI command and an explanation of its parts: $ node . ../shr-spec/spec -c ig-mcode/ig-mcode-r4-config.json -l error node is the command that starts the SHR-CLI application. The dot . represents the current directory in Windows and macOS. In this example, the tooling directory is the current working directory. ../shr-spec/spec represents the location of the specification directory. The double dot .. represents the directory above the current working directory, in Windows and macOS. In this case, /shr-spec is parallel to the tooling directory, and /spec is one level below that. -c ig-mcode/ig-mcode-r4-config.json directs the execution engine to the configuration file. Note that the configuration file location is relative to the specification directory, implying the full path to the configuration is ../shr-spec/spec/ig-mcode/ig-mcode-r4-config.json -l error is an option that sets tells the system to surpress any messages that don't rise to the level of an error . This reduces the amount of output to the console window. Addressing Error Messages In the process of building a model, it is inevitable that you will encounter error messages from SHR-CLI. Debugging the model is an iterative process, and it could take some perseverance to arrive at a \"clean\" run of SHR-CLI with no errors. This is an expected part of the process. A detailed list of CIMPL compilation errors and troubleshooting suggestions are available in Appendix A . Here are some general tips on approaching debugging your model: Always eliminate parsing errors first. Parsing errors can be identified because they include a file, line number, and column number. It is essential to elminate parsing errors first, because parsing errors usually trigger large cascades of other errors, so you can't truly start debugging your model until parsing errors have been eliminated. Once all parsing errors have been eliminated, start working top down on the first (or first few) errors. Often, subsequent errors are a consequence of the first error. Don't be discouraged by the number of errors, since a single correction can silence multiple logged errors. Read the error messages carefully. Although the messages might be cryptic, especially at first, the names of classes and paths are often excellent clues. Outputs from SHR-CLI The output of running SHR-CLI appear in a directory named \"out\". By default, the /out directory is created in the tooling directory. A different location can be designated using the -o command line option . The content of the /out directory depends on which exporters were selected to run, which is controlled using the -s command line option. By default, the /out will contain five exports, as shown below, each corresponding to a separate export process: cimcore - this directory is used in the process of building the \"modeldoc\" export, and is not discussed further data-dictionary - this directory contains an MS-Excel spreadsheet containing a list of model elements and value sets fhir - this directory contains all the definitions and assets necessary to produce the IG json-schema - this directory contains schemas for the ( TO DO -- need to define the JSON schema export ) modeldoc - this directory contains files that present the model with a look and feel similar to Javadoc FHIR Export The FHIR export consists of profiles, extensions, value sets, code systems, examples, and other artifacts needed to create a FHIR IG. These are not the pages of the IG, but rather various definitions that underlie the IG presentation. You must run the IG publisher to create the IG itself. The FHIR export appears in the /fhir subdirectory under the designated \"out\" directory. The directory contains further subdirectories for code systems, extensions, the IG (guide), the logical model (logical), profiles, and value sets. Logical Model Export The logical model is an alternative representation of the CIMPL model, expressed in a familiar FHIR-like format. The logical model closely follows the CIMPL definitions because it reflects the model prior to mapping to FHIR resources. Each entry is presented as if it were a new FHIR resource, rather than a profile. The logical model is formally expressed as a set of FHIR StructureDefinitions . These definitions are distinguished from profiles because the names generated by the tooling end in -model . Because the logical model does not entail the additional complication of mapping, it is useful for review purposes. The logical model can be checked for clinical relevance and sufficiency before making mapping decisions. An optional part of the FHIR export, the logical model can be turned on or off using the includeLogicalModels flag in the configuration file. Model Documentation Export The model documentation provides another way to view the logical model. This view emphasizes the class hierarchy defined in CIMPL, the datatypes, associated constraints, and relationships between the classes (references). The panel in the upper left allows the user to filter on the namespace and (in SHR-CLI 6.6 and higher) the class type (Entry, Group, or Element). The right-hand panel shows details for the selected class, include the full set of properties and constraints. For many users, especially those with experience in object-oriented modeling, the model documentation is the quickest way to navigate around the model. Data Dictionary Export The Data Dictionary is an Microsoft Excel file containing a simplified, flattened list of model elements and value sets, extracted from the FHIR profiles. The spreadsheet has five tabs: The \"Key\" tab contains a key to the columns in the other tabs; The \"Profiles\" tab contains a list of the primary profiles and their descriptions; The \"Data Elements\" tab contains a list of Must-support and required elements associated with those profiles; The \"Value Sets\" tab contains a list of value sets used in the IG, and their descriptions; The \"Value Set Details\" tab contains a list of the codes and/or implicit definitions in those value sets. The Data Dictionary can be useful both to clinicians and implementers who don't need the structural details of the FHIR profiles, but want the contents in list form. For many reviewers and contributors, this can be an easy-to-use format to facilitate discussion and feedback. JSON Schema Export ( TO DO: determine what to say here ) Creating the Implementation Guide The final step in the IG creation process is to run the FHIR IG Publisher . This tool is maintained and owned by HL7 FHIR. Open a command prompt, change directories to the tooling directory, and use one of these two options: If you used the default \"out\" directory when running SHR-CLI: $ yarn run ig:publish If you used a different \"out\" directory (e.g., mypath/out): $ java -Xms4g -Xmx8g -jar mypath/out/fhir/guide/org.hl7.fhir.publisher.jar -ig mypath/out/fhir/guide/ig.json Note: The IG publisher can take 15-30 minutes or even longer to run, depending on the size of the IG, and it takes lots of memory. The yarn script above will allocate up to 8GB of RAM. A minimum of 4GB of RAM is recommended to run the IG Publisher tool. When the publisher finishes, the IG can be opened by running the following commands. If you used default \"out\" directory: $ yarn run ig:open If you used a different \"out\" directory, by manually opening the file mypath/out/fhir/guide/output/index.html You now have your completed IG. The FHIR IG Publisher performs numerous validation checks on the content of the IG. The output of these checks can be accessed through the \"QA Report\" link in the footer of the home page, or by opening the file /out/fhir/guide/output/qa.html . An example QA output is shown below: Appendix A: Error Messages In the following, $ prefix indicates a variable that will be filled in with specific information. Table of Contents Error Code Structure Parsing Errors Warning Codes Compilation Error Codes Mapping Error Codes Error Code Structure CIMPL Compilation Errors are structured in the following format: 1 2 3 4 5 \u21b3 First digit tells whether it is an warning or error. 0 = warning, 1 = error 1 2 3 4 5 \u21b3 Second digit indicates the phase of processing where the error appeared: 1 = grammar and importing of the text files, 2 = logical verification of the model, 3 = exporting of FHIR profiles, 4 = exporting of the JSON profiles 1 2 3 4 5 \u21b3 The last three digits are for unique identification and have no particular meaning. Parsing Errors Parsing errors are generated when the importer cannot make sense of the contents of a CIMPL statement. Parsing error messages include the file, line, and column number, and can be linked directly to a location in a CIMPL file where parsing failed. Most other types of errors (with the exception of mapping errors) cannot be linked to a specific file location because they represent some type of a logical inconsistency. A typical parsing error looks like this: extraneous input 'Entry' expecting {<EOF>, 'CodeSystem:', 'Abstract:', 'Element:', 'Entry:', 'Group:'}. ERROR_CODE:11023 (module=shr-text-input, file=..\\shr-spec\\spec\\ns-onco-core\\oncocore.txt, line=9, column=0) When a parsing error occurs, the associated error code number and subsequent errors are not meaningful, since the entire model could not be read. Warning Codes Warning Code Warning Message Potential Solution 01001 No project configuration file found, currently using default EXAMPLE identifiers. Auto-generating a proper 'config.json' in your specifications folder Open the 'config.json' file and customize it for your project. 01002 Config file missing key: $KEY , using default key: $DEFAULT VALUE instead. Open the 'config.json' file and add your project specific details for that key. 02001 Potentially mismatched targets: $CLASS maps to $ITEM , but based on class ( $CLASS ) maps to $ITEM , and $ITEM is not based on $ELEMENT in $CLASS .' You are overriding an inherited mapping. 03001 Trying to map $PROFILE to $CODE , but $PROFILE was previously mapped to it 03002 Choice has equivalent types, so choice options may overwrite or override each other when mapped to FHIR. 03003 Overriding extensible value set constraint from $VS1 to $VS2 . Only allowed when new codes do not overlap meaning of old codes. The \"extensible\" binding means that a code from outside the given value set should be used only if the value set does not contain a suitable code. 03004 Element profiled on Basic. Consider a more specific mapping. The Basic profile should not be used in most cases. Consider a more specific profile mapping that categorizes the Element being mapped. 03005 No mapping to ' $ELEMENT PATH '. This property is core to the target resource and usually should be mapped. 03006 The $PROPERTY property is not bound to a value set, fixed to a code, or fixed to a quantity unit. This property is core to the target resource and usually should be constrained Usually a result of not setting the Code attribute of an Observation. 04001 Unsupported code system: ' $CODESYSTEM ' Compilation Error Codes Error Code Error Message Solution 11001 Element name ' $NAME ' should begin with a capital letter Rename the specified Element 11002 Entry name ' $NAME ' should begin with a capital letter Rename the specified Entry 11003 Unable to resolve value set reference: $VALUESET Invalid value set reference, double check the name and the path 11004 Unsupported binding strength: $BINDING_STRENGTH . Defaulting to REQUIRED Binding strength has to be one of the following: example, preferred, extensible, or required (default). 11005 Error parsing source path: $PATH Invalid path to definitions. Double check path. 11006 Invalid config file. Should be valid JSON dictionary Make sure your 'config.json' file is using a valid format for JSON. 11007 Unsupported grammar version: $VERSION Grammar Version for file must be 5.0 (or above) 11008 Defining value sets by URL has been deprecated in ValueSet files. ValueSet $VALUESET ignored. Define the value set with a name using proper syntax. 11009 Defining value sets by URN has been deprecated in ValueSet files. ValueSet $VALUESET ignored. Define the value set with a name using proper syntax. 11010 Couldn\u2019t resolve code system for alias: $ALIAS Invalid Codesystem, double check spelling 11011 Uses statements have been deprecated in ValueSet files. Uses statement ignored. Uses statement is unnecessary. Refer to documentation for proper syntax 11012 Only default path definitions are allowed in ValueSet files. Path definition ignored. Use one of the preset path definitions defined in the documentation. 11013 Failed to resolve definition for $ELEMENT_NAME The referenced Element doesn't exist in the current namespace, or in any of its inherited parents. Check spelling errors as well as imports. 11013 Failed to resolve definition for primitive Only certain primitives are supported. Please refer to the documentation to see the full list. 11015 token recognition error at: $CHARACTER This is usually a typo issue. Investigate keywords and missing colons around the specificed text input. 11016 mismatched input $INPUT expecting $LIST_OF_KEYWORDS This is usually a typo issue. Investigate spelling and keywords used around the specificied text input. 11017 Cannot resolve path without namespaces There was a failure to parse the namespace. Ensure the namespace is correctly defined. 11018 Failed to resolve path for $NAME . 11019 Found conflicting path for $NAME in multiple namespaces: $NAMESPACES 11020 Failed to resolve vocabulary for $NAME . 11021 Found conflicting vocabularies for $NAME in multiple namespaces: $NAMESPACES 11022 Found conflicting definitions for $NAME in multiple namespaces: $NAMESPACES 11023 Elements cannot be based on \"Value\" keyword 11024 Elements cannot use \"Value:\" modifier and specify \"Value\" field at same time. 11025 Fields cannot be constrained to type \"Value\" 11026 ref(Value) is an unsupported construct; treating as Value without the reference. 11027 Unable to import property $FQN , unknown value type: $VALUE_TYPE The type either does not exist, or the import tool needs to be updated. 11028 Unable to import unknown constraint type: $CONSTRAINT_TYPE The type either does not exist, or the import tool needs to be updated. 11029 Unable to import mapping, unknown rule type: $RULE_TYPE The type either does not exist, or the import tool needs to be updated. 11030 Unable to import VS rule, unknown rule type: $RULE_TYPE The type either does not exist, or the import tool needs to be updated. 11031 Unable to import FixedValueConstraint, unknown fixed value type: $RULE_TYPE The value type either does not exist, or the import tool needs to be updated. 11032 Project configuration not found! Exiting the program. There was an error finding or loading the configuration file. Please double check that it exists and is valid. 11033 Name $ELEMENT_ENTRY_NAME already exists. The entity or element name already exists within the namespace and the most recently defined element or entry name will be used. 11034 ValueSet name $VS_NAME already exists. The value set name already exists within the namespace. 11035 Definition not found for data element in content profile path: $ELEMENT_FQN . Could indicate a missing definition, misspelling, or missing Uses declaration. 11036 Path not found for $ELEMENT_FQN : $PATH . Usually when sub-elements in a dotted path (foo.bar.baz) can't be traced. See CIMPL path for more information. 11037 Could not find content profile file: $FILE_NAME . Check the name or path to the content profile file specified in your configuration file. 11038 Namespace declaration not found. File needs a namespace declaration at the top of the file under the Grammar declaration. 11039 Grammar declaration not found. File needs a Grammar declaration at the top of the file. 11040 Property $PROPERTY already exists. Extra declaration of Property needs to be removed. 11041 Choice value constrained without specifying the specific choice. 11042 Constraint refers to previous identifier. 11043 Value should not be declaring cardinality. Remove cardinality declared for the value. 11044 Missing a value element. 12001 Cannot resolve element definition. Element doesn't exist. Double check spelling and inheritance 12002 Reference to non-existing base: $ELEMENT_NAME Base doesn't exist. Double check spelling and inheritance. 12003 No cardinality found for value: $VALUE Explicitly define cardinality for that value. 12004 No cardinality found for field: $FIELD Explicity define cardinality for that field. 12005 Cannot override $OLD_VALUE with $NEW_VALUE Double check types match. 12006 Cannot override $OLD_VALUE with $NEW_VALUE since it is not one of the options Verify Identifiers match. 12007 Cannot override $OLD_VALUE with $NEW_VALUE Verify Identifiers match. 12008 Cannot override $OLD_VALUE with $NEW_VALUE since overriding ChoiceValue is not supported Verify Identifiers match. 12009 Unsupported constraint type: $CONSTRAINT Invalid constraint syntax. Consult documentation to see what constraints are supported 12010 Cannot constrain cardinality of $NAME from $SMALL_CARDINALITY to $BIGGER_CARDINALITY You can only narrow the cardinality. You cannot constrain it to have a larger range than its parent 12011 Cannot further constrain cardinality of $NAME from $CARDINALITY to $CARDINALITY You can only narrow the cardinality. You cannot constrain it to have a larger range than its parent 12012 Cannot constrain type of $NAME to $TYPE Make sure base types match 12013 Cannot constrain type of $NAME since it has no identifier Invalid Element 12014 Cannot constrain type of $NAME to $TYPE Make sure base types match 12015 Cannot further constrain type of $NAME from $TYPE to $TYPE The two elements aren't based on the same parent. You cannot constrain an element to one that is completely distinct. 12017 Cannot constrain type of $NAME since it has no identifier 12018 Cannot constrain element $NAME to $TARGET since it is an invalid sub-type Element has to be based on $s or otherwise is a child of $s . 12020 Cardinality of $NAME not found Please explicitly define the cardinality. 12021 Cannot include cardinality on $NAME , cardinality of $CARD doesnt fit within $CARD The cardinality of included parameters must be as narrow or narrower than the property it contains. 12022 Cannot constrain valueset of $NAME since it has no identifier 12023 Cannot constrain valueset of $NAME since neither it nor its value is a concept Only elements whose datatype is concept can be bound to a value set. 12024 Cannot constrain valueset of $NAME since it is already constrained to a single code 12025 Cannot constrain code of $NAME since neither it nor its value is a concept 12026 Cannot constrain included code of $NAME since neither it nor its value is a concept 12027 Cannot constrain boolean value of $NAME since neither it nor its value is a boolean You may be trying to set an element that is not a boolean to true or false. 12028 Cannot constrain boolean value of $NAME to $VALUE since a previous constraint constrains it to $VALUE Once a fixed constraint is applied, it cannot be changed in a child class. In this case, you might be switching a true to a false or vice versa. 12029 Cannot resolve element definition for $NAME This is due to a incomplete definition for an element. Please refer to the document for proper definition syntax. 12030 Cannot determine target item System error. 12031 Cannot resolve data element definition from path: $PATH Check spelling for field or value. 12032 Cannot resolve data element definition from path: $PATH Check spelling for field or value. 12033 Cannot map Value since element does not define a value Define a value for your element 12034 Cannot map Value since it is unsupported type: $VALUE_TYPE 12035 Found multiple matches for field $FIELD Please use fully qualified identifier. 12036 Could not find expanded definition of $ELEMENT . Inheritance calculations will be incomplete. Double check shr.base.Entry is defined within the specifications. 12037 Could not find based on element $ELEMENT for child element $ELEMENT . Double check the basedOn element is defined within the specifications and correctly referenced. 14001 Unsupported value set rule type: $s 14002 Unknown type for value $VALUE 14003 Unknown type for constraint $CONSTRAINT Mapping Error Codes Error Code Error Message Solution 13001 Invalid FHIR target: $TARGET Could not find the FHIR resource or profile you're trying to map to. Check spelling and FHIR version. 13002 Cannot flag path as mapped 13003 Slicing on include type constraints with paths is not supported 13004 Slicing required to disambiguate multiple mappings to $TARGET 13005 Invalid source path 13006 Invalid or unsupported target path 13007 Cannot unroll contentReference $CONTENT_REFERENCE on $ELEMENT because it is not a local reference 13008 Invalid content reference on $ELEMENT : $CONTENT_REFERENCE 13009 Cannot unroll $ELEMENT . Create an explicit choice element first. 13010 Cannot unroll $ELEMENT at $ELEMENT : invalid SHR element. 13011 Cannot make choice element explicit since it is not a choice ([x]): $ELEMENT 13012 Cannot make choice element explicit at $ELEMENT . Invalid SHR identifier: $IDENTIFIER . 13013 Invalid target path. Cannot apply cardinality constraint. 13014 Cannot constrain cardinality from $CARD to $CARD 13015 Invalid target path. Cannot apply fixed value. 13016 Currently, only fixing codes is supported (value must contain \"#\"). Unable to fix to $VALUE . This error message applies to SHR-CLI 6.4 and earlier. In SHR-CLI 6.5 and higher, fixed value constraints can be applied to integer and decimal values. 13017 Incompatible cardinality (using aggregation). Source cardinality $CARD does not fit in target cardinality 13018 Cannot constrain cardinality to $CARD because cardinality placement is ambiguous. Explicitly constrain parent elements in target path. See Error 13020 13019 Cannot constrain cardinality to $CARD because there is no tail cardinality min that can get us there See Error 13020 13020 Cannot constrain cardinality to $CARD because there is no tail cardinality max that can get us there When the target path is deeper than one level, cardinalities combine to get to the final (target) cardinality. The correct way to constrain the cardinality is ambiguous. For example, if B maps to a.b, and B is constrained to [0,4], there are multiple ways to get there: a[0..1].b[0..4] or a[0..1].b[1..4] or a[1..1].b[0..4] or a[0..4].b[0..1] etc. To resolve this error, ambiguous cardinalities in intermediate paths must be explicitly declared in the mapping file using the constrain keyword. 13021 Cannot constrain cardinality to $CARD because there is no tail cardinality that can get us there See Error 13020 13022 Mismatched types. Cannot map $SOURCE_VALUE to $MAPPING . Find the Entry referenced in the error details and change it to match the data type of the target field. 13023 Cannot resolve element definition for $ELEMENT 13024 Failed to resolve element path from $ELEMENT to $PATH 13025 Applying constraints to profiled children not yet supported. 13026 Failed to resolve path from $ELEMENT to $PATH 13027 Unsupported binding strength: $BINDING_STRENGTH 13028 Cannot change binding strength from $FHIR_BINDING_STRENGTH to $CIMPL_BINDING_STRENGTH The value set binding strength specified in CIMPL is weaker than the binding already specified in FHIR. You must increase the binding strength in the CIMPL model to at least the same level as in FHIR. Note that this error message gives the FHIR binding strength first. 13029 Cannot override value set constraint from $URI to $URI This message is given when you try to replace a FHIR value set, which is either extensible or required, with a different value set. 13030 Found more than one value set to apply to $ELEMENT . This should never happen and is probably a bug in the tool. 13031 Found more than one code to fix on $ELEMENT . This should never happen and is probably a bug in the tool. 13032 Can\u2019t fix code on $ELEMENT because source value isn\u2019t code-like. This should never happen and is probably a bug in the tool. 13033 Can\u2019t fix code on $ELEMENT because source value isn\u2019t code-like. This should never happen and is probably a bug in the tool. 13034 Cannot override code constraint from $VALUE to $VALUE 13035 Cannot override boolean constraint from $VALUE to $VALUE 13036 Found more than one boolean to fix on $ELEMENT . This should never happen and is probably a bug in the tool. 13037 Conversion from $VALUE to one of $TYPE drops boolean constraints 13038 Conversion from $VALUE to one of $TYPE drops value set constraints 13039 Conversion from $VALUE to one of $TYPE drops code constraints 13040 Conversion from $VALUE to one of $TYPE drops includesCode constraints 13041 Unable to establish namespace for $ELEMENT 13042 No slice name supplied for target. This should never happen and is probably a bug in the tool. 13043 Couldn\u2019t find target in slice $SLICE (Exporting) 13044 Target resolves to multiple elements but is not sliced 13045 Unable to establish namespace for $FIELD (Extensions) 13046 Mapping to MAP_TARGET 's RULE_TARGET : slice could not be found. 13047 Couldn't find sd to unroll 13048 Cannot override code constraint from $SYSTEM | $CODE to $SYSTEM | $CODE ' 13049 Unexpected error processing mapping to FHIR. 13050 Unexpected error processing mapping rule. 13051 Unexpected error adding extension. 13054 Using profile that is currently in the middle of processing: $PROFILE_ID . 13055 Using extension that is currently in the middle of processing: $EXTENSION_ID . 13056 Can't fix $TARGET to $VALUE since $TARGET is not one of: $ALLOWABLE_TYPES . 13057 Could not fix $TARGET to $VALUE ; failed to detect compatible type for value $VALUE . 13058 Cannot fix $TARGET to $VALUE since it is not a $TYPE type. 13059 Cannot fix $TARGET to $VALUE since it is already fixed to $OTHER_VALUE . 13060 Could not determine how to map nested value ( $ELEMENT_PATH ) to FHIR profile. Occurs on the FHIR profile export when there are multiple levels of reference specified. e.g.: LaboratoryObservationTopic.Specimen.CollectionSite within LaboratoryObservationTopic. Resolved by creating a reference in the cimi entity to FHIR map in cimi_entity_map.txt. 13061 Mapping $ELEMENT sub-fields is currently not supported. 13062 Cannot make choice element explicit at $ELEMENT . Could not find compatible type match for: $TYPE . 13063 Could not find FHIR element with path $ELEMENT_PATH for content profile rule with path $RULE_PATH . 13064 Could not find FHIR element for content profile rule with path $RULE_PATH . 13065 Could not find FHIR element subextension for content profile rule with path $RULE_PATH .","title":"CIMPL 6.0 Tooling Reference"},{"location":"cimpl6ToolingReference/#cimpl-60-tooling-reference","text":"","title":"CIMPL 6.0 Tooling Reference"},{"location":"cimpl6ToolingReference/#preface","text":"","title":"Preface"},{"location":"cimpl6ToolingReference/#purpose-of-this-document","text":"This reference manual is a comprehensive guide to the command line interface, auxiliary files, and configurations needed to create a FHIR Implementation Guide (IG) from CIMPL ( C linical I nformation M odeling P rofiling L anguage).","title":"Purpose of this Document"},{"location":"cimpl6ToolingReference/#intended-audience","text":"The CIMPL Tooling Reference is targeted to people doing model development using CIMPL and producing FHIR Implementation Guides. Familiarity with FHIR is helpful as the tutorial references FHIR artifacts (such as Resources, Elements, etc.)","title":"Intended Audience"},{"location":"cimpl6ToolingReference/#prerequisite","text":"This guide assumes you have: Installed the latest version of the SHR-CLI software as documented in CIMPL SetUp and Installation . Created set of CIMPL Language files (classes, value sets, and maps) representing your clinical model (see CIMPL Language Reference Manual for details). Reviewed the In-Depth Tutorial .","title":"Prerequisite"},{"location":"cimpl6ToolingReference/#table-of-contents","text":"CIMPL 6.0 Tooling Reference Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Overview Relationship of CIMPL Models and Implementation Guides Conventions Suggested Directory Structure Suggested File Naming Inputs to SHR-CLI CIMPL Files Setting up the VSCode Authoring Navigating a CIMPL Model within VSCode Configuration File Filter Strategy Configuration Parameters Implementation Guide Configuration Parameters Provenance Information Configuration Parameters Front Matter Files FHIR Examples Package List File Content Profile File Executing SHR-CLI Command Line Addressing Error Messages Outputs from SHR-CLI FHIR Export Logical Model Export Model Documentation Export Data Dictionary Export JSON Schema Export Creating the Implementation Guide Appendix A: Error Messages Table of Contents Error Code Structure Parsing Errors Warning Codes Compilation Error Codes Mapping Error Codes","title":"Table of Contents"},{"location":"cimpl6ToolingReference/#overview","text":"The CIMPL Tooling, also called SHR-CLI (Standard Health Record Command Line Interface), is the engine that imports a set of inputs, including CIMPL language files, and exports FHIR and other outputs, as shown below: The inputs to SHR-CLI include: CIMPL Language files , including class files, value set files, and mapping files that define your clinical information model, A Configuration file that contains directives to the tooling, and points to other resources, An optional Content Profile file, which specifies Must-Support elements and profiling options specific to an IG, One or more Front Matter files, which are the narratives and graphics that introduce the IG, FHIR Examples that are to be included in the IG, and A Package List that has information required for building the IG. The inputs are processed in the following sequence: The user issues a build command through the command-line interface (CLI) to launch SHR-CLI. The CIMPL tooling imports definitions from CIMPL files (class, value set, and map files). SHR-CLI reports any errors in the CIMPL definitions. Continuing the build process, SHR-CLI selects a subset of the data models to include in the IG, according to the filter strategy . To complete the build process, SHR-CLI exports the selected CIMPL definitions into desired formats, such as FHIR profiles, data dictionaries, etc. The exports can be selected through command line options . The user issues a separate command to produce the IG. SHR-CLI produces one or all of the following outputs, depending on configuration parameters: FHIR Profiles, Extensions, Value Sets that form the core content of the IG, A Logical Model corresponding to the CIMPL class definitions, expressed as FHIR StructureDefinitions, JSON Schema for the profiles defined by the IG, A Data Dictionary that lists the Must-Support data elements in the IG, as well as value sets and value set members, Model Documentation in the form of a Javadoc-like browser that allows one to see the hierarchical class relationships in the logical model.","title":"Overview"},{"location":"cimpl6ToolingReference/#relationship-of-cimpl-models-and-implementation-guides","text":"It is important to understand the relationship between models defined in CIMPL and implementation guide(s) created from those models. The state-of-practice for FHIR IGs is still evolving, but currently, most IGs are developed by separate groups and define their own data models, as follows: The drawback of this approach is that different IGs can require very similar data models. If different data models are developed by different teams, interoperability will suffer. In CIMPL, data models are independent of IGs. IGs are consumers of models, rather than owners of models (although new models can certainly be created in the context of IG development). Each IG uses a different subset of models, reflecting the different use cases they address, but the commonality of data models assures interoperability between the use cases. This idea is illustrated below: Much of what is discussed subsequently reflects this conceptual picture of the relationship between CIMPL models and IGs.","title":"Relationship of CIMPL Models and Implementation Guides"},{"location":"cimpl6ToolingReference/#conventions","text":"","title":"Conventions"},{"location":"cimpl6ToolingReference/#suggested-directory-structure","text":"The SHR-CLI tooling does not require a particular directory structure. However, following conventions makes the process of managing the requisite files much easier. Here is an example of the suggested arrangement that assumes the same IG can be produced under FHIR STU3 and R4: \u251c\u2500\u2500 shr-cli-6.5.0 // Tooling location | ... | \u251c\u2500\u2500 spec // Main specification directory | \u251c\u2500\u2500 ns-namespace1 // Namespace directories | | \u251c\u2500\u2500 namespace1-foo.txt // class file(s) | | \u251c\u2500\u2500 namespace1-bar.txt | | \u251c\u2500\u2500 namespace1-foo-vs.txt // value set file(s) | | \u251c\u2500\u2500 namespace1-bar-vs.txt | | \u251c\u2500\u2500 namespace1-foo-map-stu3.txt // map(s) for FHIR STU3 | | \u251c\u2500\u2500 namespace1-bar-map-stu3.txt | | \u251c\u2500\u2500 namespace1-foo-map-r4.txt // map(s) for FHIR r4 | | \u2514\u2500\u2500 namespace1-bar-map-r4.txt | \u251c\u2500\u2500 ns-namespace2 | | ... | \u251c\u2500\u2500 ns-namespace3 | | ... | | ... | \u251c\u2500\u2500 ig-myguide1 // IG directories | | \u251c\u2500\u2500 myguide1-examples // directory of examples | | | \u251c\u2500\u2500 example1 | | | \u2514\u2500\u2500 example2 | | \u251c\u2500\u2500 myguide1-frontmatter // directory containing narratives | | | \u251c\u2500\u2500 index.html | | | \u251c\u2500\u2500 picture.png | | | \u2514\u2500\u2500 another-page.html | | \u251c\u2500\u2500 myguide1-stu3-cp.txt // content profile file for FHIR STU3 IG | | \u251c\u2500\u2500 myguide1-r4-cp.txt // content profile file for FHIR R4 IG | | \u251c\u2500\u2500 myguide1-stu3-plist.json // package list for FHIR STU3 IG | | \u251c\u2500\u2500 myguide1-r4-plist.json // package list for FHIR R4 IG | | \u251c\u2500\u2500 myguide1-stu3-config.json // config file for FHIR STU3 IG | | \u2514\u2500\u2500 myguide1-r4-config.json // config file for FHIR R4 IG | \u251c\u2500\u2500 ig-myguide2 | | ... In this reference guide, we will refer to several directories: Tooling Directory - this the directory where the SHR-CLI tooling has been installed. Any convenient directory can be used. For easy identification, we recommend the tooling version number be included in the directory name. Specification Directory - this is the top level directory where the input files and are located, usually arranged in sub-folders. Any convenient directory can be used. If you are using a source code control system such as Github to manage your development, this could be where the repository is checked out to your local machine. Namespace Directories - these directories, located under the Specification Directory, contains CIMPL language files for a single namespace. The name of the directory should be prefixed with ns- followed by the shortname or acronym of the namespace followed . IG Directories - these directories, under the specification directory contain files specific to a given implementation guide. There are subdirectories containing the front matter and examples, and individual configuration, content profile, and package list files. These files can be specific to a FHIR release, since the same IG could be created using different versions of FHIR. Note: There is currently no way to combine profiles for multiple FHIR versions in single IG.","title":"Suggested Directory Structure"},{"location":"cimpl6ToolingReference/#suggested-file-naming","text":"The naming of configuration, content profiles, and package list files is arbitrary, but it is useful for different teams to follow similar conventions. The suggested approach to naming uses variations on the same shortened IG name, as follows: Configuration file: ig-<guide-name>-config.json Content Profile file: ig-<guide-name>-cp.txt Package List file: ig-<guide-name>-plist.json If your project will support more than one FHIR version, the FHIR version should be included: Configuration file: ig-<guide-name>-<FHIR Version>-config.json Content Profile file: ig-<guide-name>-<FHIR Version>-cp.txt Package List file: ig-<guide-name>-<FHIR Version>-plist.json where FHIR version is dstu2, stu3, or r4.","title":"Suggested File Naming"},{"location":"cimpl6ToolingReference/#inputs-to-shr-cli","text":"","title":"Inputs to SHR-CLI"},{"location":"cimpl6ToolingReference/#cimpl-files","text":"Any text editor can be used to write CIMPL grammar. However, VSCode editor is recommended to take advantage of a CIMPL plug-in.","title":"CIMPL Files"},{"location":"cimpl6ToolingReference/#setting-up-the-vscode-authoring","text":"Note: VSCode UI screenshots in this section were taken from a MacOS environment. While the overall functionality is the same across supported OS platforms, installation and configuration specifics might differ. Reference the VSCode documentation pertinent to your OS platform. Download the VSCode editor . Open VSCode, open the extensions panel, and search for the extension vscode-lang-cimpl . The figure below shows where to find VSCode extensions on MacOS (on Windows, navigate View -> Extensions ). Alternatively, select the extension icon (the squarish icon on the far left).","title":"Setting up the VSCode Authoring"},{"location":"cimpl6ToolingReference/#navigating-a-cimpl-model-within-vscode","text":"The inherited properties of Groups and Entries can be previewed in the following ways: Hovering over the element : This provides a drop-down list of all properties and cardinality of a Group or Entry (including inherited properties). Placing the cursor on the class declaration, right-click and select Peek Definition : This will display a drop-down window with a preview of the definition. The name and location of the file will be displayed although the entire file will not be opened. Placing the cursor on a property declaration and right-clicking option Go to Definition : This will redirect the editor to location of the definition, opening the file if necessary. Hovering over the element: Using Peek Definition : Using Go to Definition :","title":"Navigating a CIMPL Model within VSCode"},{"location":"cimpl6ToolingReference/#configuration-file","text":"SHR-CLI requires a configuration file to run. The name of this file is typically specified on the command line using the -c command line option . If the name is not specified, the tooling looks for a file named config.json in the working directory. If that cannot be found, or the contents of the configuration file are invalid, an error message is returned. The configuration file is a JSON file with the following parameters: Parameter Type Description projectName string The full, official name of the project, for example \"HL7 FHIR Implementation Guide: minimal Common Oncology Data Elements (mCODE) Release 1 - US Realm, STU Ballot 1\" projectShorthand string A shorthand name for the project, such as \"mcode\". projectURL string The primary URL for the project, such as \"http://hl7.org/fhir/us/mcode/\" fhirURL string The FHIR IG URL for the project, often the same as the projectURL. (TO DO: clarify the difference between projectURL, fhirURL, and entryTypeURL) fhirTarget string The FHIR version this IG will be based on, currently a choice of \"FHIR_R4\" , \"FHIR_STU_3\" , or \"FHIR_DSTU_2\" entryTypeURL string The root URL for the JSON schema EntryType field. (TO DO: clarify where and how this is used) filterStrategy {} A JSON object containing configuration for filtering ( see below ). contentProfile string The file name of the content profile for the project. implementationGuide {} A JSON object containing configuration for IG publishing ( see below ). copyrightYear string The copyright year to include in the documentation. publisher string The name of the publisher for the project, which for HL7 projects, should be the sponsoring workgroup, for example, \"HL7 International Clinical Interoperability Council\". contact [] A JSON array containing HL7 FHIR R4 ContactPoint objects . provenanceInfo {} A JSON object specifying author and other information ( see below )","title":"Configuration File"},{"location":"cimpl6ToolingReference/#filter-strategy-configuration-parameters","text":"Between the import stage and the export stage, there is a filtering stage (see CIMPL Tooling Overview ). Filtering is useful when specification directory contains namespaces that or entries that are outside the scope of the current IG, and should not be included in the IG. Filtering removes unwanted namespaces and entries to limit the scope of the exports, and subsequently, the IG. The contents of the filterStrategy object are as follows: Parameter Type Description filter boolean A value indicating whether to enable filtering. If filter is true , then the filtering operation will occur. Otherwise, no filtering will occur. (Also, if the filterStrategy parameter is entirely omitted, no filtering will occur.) strategy string The strategy for specification filtering, either \"namespace\", \"element\", or \"hybrid\". target [] An array of strings containing the names of Entries, Namespaces, or both. The \"element\" strategy filters the imported classes to include each Entry listed in the target array, and their recursive dependencies. The \"namespace\" strategy filters the imported classes to include only Entries in the namespaces listed in the target array, and their recursive dependencies. The \"hybrid\" strategy filters the imported classes to include each Entry listed in the target array and all Entries in every namespace listed in the target array, and their recursive dependencies. When specifying an Entry in the target array, use the fully qualified name (FQN) format.","title":"Filter Strategy Configuration Parameters"},{"location":"cimpl6ToolingReference/#implementation-guide-configuration-parameters","text":"These configurations are used to control the production of the IG. The contents of the implementationGuide object are as follows: Parameter Type Description npmName string The assigned node package manager name for this IG, for example \"hl7.fhir.us.mcode\". The npm name is usually assigned by HL7. version string The version of this IG (not necessarily the version of FHIR), usually in the form major.minor.revision , for example, \"3.0.1\" ballotStatus string The HL7 ballot status of the IG (e.g., STU1 Ballot, Continuous Integration Build, etc.) packageList string The name of the file to use as the IG's package list , relative to the Specification Directory. includeLogicalModels boolean A \"true\" or \"false\" value indicating whether to include logical models in the IG. includeModelDoc boolean A \"true\" or \"false\" value indicating whether to include the model documentation in the IG. indexContent string The name of the file or folder containing the front matter , relative to the Specification Directory, for example, \"ig-mcode/IndexFolder-Oncocore\". If the indexContent is a folder, then it must contain an index.html file whose contents will be used as the body of the IG home page. extraResources string The name of the folder containing extra JSON resources to include in the IG, one file per resource. Currently, the following resource types are supported: SearchParameter , OperationDefinition , CapabilityStatement (STU3+), Conformance (DSTU2). If files are detected, links are added to the navigation menu as necessary. examples string The name of the folder containing examples (one example per file) to include in the IG, for example, \"ig-mcode/Examples-mCODE-r4\". We recommend the individual example file name match the id in the example file (with .json extension added). The example's meta.profile must match the canonical URL for the profile it exemplifies (e.g. \"meta\": { \"profile\": [ \"http://hl7.org/fhir/us/breastcancer/StructureDefinition/oncology-BreastCancerPresenceStatement\" ] } ). If no examples folder is specified, and a folder named \"fhir-examples\" exists in the specification directory, it will be used as the examples folder. historyLink string The URL for the page containing the IG's history information. (TO DO: clarify where and how this is used) changesLink string The URL to a site where users can request changes (shown in page footer) (TO DO: clarify where and how this is used) primarySelectionStrategy {} The strategy for selection of what is primary in the IG (see below). The primary selection strategy causes certain profiles to be displayed in a \"Primary\" section at the top list of profiles. All other exported profiles are listed in a \"Supporting\" section below the \"Primary\" section. The contents of the primarySelectionStrategy object are as follows: Parameter Type Description strategy string The strategy to follow for primary selection, either \"namespace\", \"hybrid\", or \"entry\" (default). primary [] An array of strings containing the namespaces and entries (only used for \"namespace\" and \"hybrid\" strategy). The strategy options are as follows: \"entry\" selects every exported profile as primary. \"namespace\" selects every profile found in the namespaces of the primary array as primary. \"hybrid\" selects every entry listed in the primary array or found in the namespaces in the primary array as primary. When specifying an Entry in the target array, use the fully qualified name (FQN) format.","title":"Implementation Guide Configuration Parameters"},{"location":"cimpl6ToolingReference/#provenance-information-configuration-parameters","text":"(TO DO: document what this structure can contain) Here is an example of provenanceInformation: \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" }","title":"Provenance Information Configuration Parameters"},{"location":"cimpl6ToolingReference/#front-matter-files","text":"Every IG contains some amount of narrative content, which we refer to as the \" front matter \". The front matter is typically a set of hyperlinked HTML files, graphics, and sometimes, downloads. These files are manually authored using any convenient tool; there are no special facilities in CIMPL to author the front matter. If multiple files are involved, they must be placed into a single folder, named in the indexContent parameter of the configuration file . This folder must contain a file named index.html whose contents will be used as the body of the IG home page (the header and footer of the pages are automatically generated). If a single file is used, the file should be named in the indexContent parameter of the configuration file, and a folder is not required.","title":"Front Matter Files"},{"location":"cimpl6ToolingReference/#fhir-examples","text":"Configuring FHIR examples to appear in the generated IG involves the following steps: Create a folder which will contain your FHIR examples Modify the CIMPL configuration file to specify the folder containing your examples The name of the folder is arbitrary, however, following directory structure and naming conventions is recommended. The folder location is specified using the \"examples:\" parameter in the CIMPL configuration file. This is illustrated below:","title":"FHIR Examples"},{"location":"cimpl6ToolingReference/#package-list-file","text":"The format and content of this file follows the FHIR specification for package lists . The package list is required for IGs published by HL7. The file containing the package list is named by the packageList parameter of the configuration file . If the packageList parameter is not supplied and no file is found at the default location (packageList.json), and fhirURL is an hl7.org or fhir.org URL (indicating it is an HL7 publication), then a basic package list file will be created. In this case, the IG author should review and modify the file as needed. Here is an example of a package list file: { \"package-id\": \"hl7.fhir.us.mcode\", \"title\": \"HL7 FHIR Implementation Guide: minimal Common Oncology Data Elements (mCODE) Release 1 - US Realm | STU Ballot 1\", \"canonical\": \"http://hl7.org/fhir/us/mcode\", \"list\": [ { \"version\": \"current\", \"desc\": \"Continuous Integration Build (latest in version control)\", \"path\": \"https://build.fhir.org/ig/HL7/fhir-mCODE-ig\", \"status\": \"ci-build\", \"current\": true }, { \"version\": \"0.9.1\", \"date\": \"2019-06-10\", \"desc\": \"Initial version\", \"path\": \"http://hl7.org/fhir/us/mcode/2019Sep\", \"status\": \"draft\", \"sequence\": \"STU 1\", \"fhir-version\": \"4.0.0\" } ] }","title":"Package List File"},{"location":"cimpl6ToolingReference/#content-profile-file","text":"In FHIR, Must-Support is a boolean flag which allows a profile to indicate that an implementation must be able to process that element in a FHIR instance if it exists. The Content Profile is where Must-Support elements are declared. Note that the Must-Supports are designated at the level of the IG, not the data model. This is because different elements are important for different use cases. For example, one use case may not require date of death to be supported, but another might. Note: Filtering is the mechanism by which entries (profiles) and namespaces are selected for an IG, and content profiles are the mechanism for declaring Must-Support. The syntax of a Content Profile file is: Grammar: ContentProfile 1.0 Namespace: <namespace-1> <Entry-1>: <Element-1> MS <Element-2> MS ... <Entry-2>: ... Namespace: <namespace-2> <Entry-1>: <Element-1> MS <Element-2> MS ... <Entry-2>: ... Here is an excerpt from a Content Profile file: Grammar: ContentProfile 1.0 Namespace: obf ComorbidCondition: Code MS ClinicalStatus MS MedicationStatement: MedicationCodeOrReference MS OccurrenceTimeOrPeriod MS TerminationReason MS TreatmentIntent MS ECOGPerformanceStatus: DataValue MS Namespace: vital BloodPressure: Components.ObservationComponent MS RelevantTime MS BodyHeight: DataValue MS RelevantTime MS BodyWeight: DataValue MS RelevantTime MS Namespace: onco.core PrimaryCancerCondition: Code MS ClinicalStatus MS BodyLocation.Code MS HistologyMorphologyBehavior MS DateOfDiagnosis MS Note: The grammar of the Content Profile file is still evolving and may include additional information in the future.","title":"Content Profile File"},{"location":"cimpl6ToolingReference/#executing-shr-cli","text":"","title":"Executing SHR-CLI"},{"location":"cimpl6ToolingReference/#command-line","text":"The general form of the SHR-CLI execution command is as follows (where $ stands for the command prompt, which could be different on your system): $ node <tooling-directory> <specification-directory> [options] where options include: -c, --config <config> the name of the config file (default: config.json) -l, --log-level <level> the console log level <fatal, error, warn, info, debug, trace> (default: info) -s, --skip <feature> skip an export feature <fhir, json-schema, model-doc, data-dict, all> (default: <none>) -o, --out <out> the path to the output folder (default: out) -m, --log-mode <mode> the console log mode <short,long,json,off> (default: short) -d, --duplicate show duplicate error messages (default: false) -j, --export-es6 export ES6 JavaScript classes (experimental, default: false) -n, --clean Save archive of old output directory and perform clean build (default: false) -h, --help output usage information The options are not order-sensitive. Here is an example of a SHR-CLI command and an explanation of its parts: $ node . ../shr-spec/spec -c ig-mcode/ig-mcode-r4-config.json -l error node is the command that starts the SHR-CLI application. The dot . represents the current directory in Windows and macOS. In this example, the tooling directory is the current working directory. ../shr-spec/spec represents the location of the specification directory. The double dot .. represents the directory above the current working directory, in Windows and macOS. In this case, /shr-spec is parallel to the tooling directory, and /spec is one level below that. -c ig-mcode/ig-mcode-r4-config.json directs the execution engine to the configuration file. Note that the configuration file location is relative to the specification directory, implying the full path to the configuration is ../shr-spec/spec/ig-mcode/ig-mcode-r4-config.json -l error is an option that sets tells the system to surpress any messages that don't rise to the level of an error . This reduces the amount of output to the console window.","title":"Command Line"},{"location":"cimpl6ToolingReference/#addressing-error-messages","text":"In the process of building a model, it is inevitable that you will encounter error messages from SHR-CLI. Debugging the model is an iterative process, and it could take some perseverance to arrive at a \"clean\" run of SHR-CLI with no errors. This is an expected part of the process. A detailed list of CIMPL compilation errors and troubleshooting suggestions are available in Appendix A . Here are some general tips on approaching debugging your model: Always eliminate parsing errors first. Parsing errors can be identified because they include a file, line number, and column number. It is essential to elminate parsing errors first, because parsing errors usually trigger large cascades of other errors, so you can't truly start debugging your model until parsing errors have been eliminated. Once all parsing errors have been eliminated, start working top down on the first (or first few) errors. Often, subsequent errors are a consequence of the first error. Don't be discouraged by the number of errors, since a single correction can silence multiple logged errors. Read the error messages carefully. Although the messages might be cryptic, especially at first, the names of classes and paths are often excellent clues.","title":"Addressing Error Messages"},{"location":"cimpl6ToolingReference/#outputs-from-shr-cli","text":"The output of running SHR-CLI appear in a directory named \"out\". By default, the /out directory is created in the tooling directory. A different location can be designated using the -o command line option . The content of the /out directory depends on which exporters were selected to run, which is controlled using the -s command line option. By default, the /out will contain five exports, as shown below, each corresponding to a separate export process: cimcore - this directory is used in the process of building the \"modeldoc\" export, and is not discussed further data-dictionary - this directory contains an MS-Excel spreadsheet containing a list of model elements and value sets fhir - this directory contains all the definitions and assets necessary to produce the IG json-schema - this directory contains schemas for the ( TO DO -- need to define the JSON schema export ) modeldoc - this directory contains files that present the model with a look and feel similar to Javadoc","title":"Outputs from SHR-CLI"},{"location":"cimpl6ToolingReference/#fhir-export","text":"The FHIR export consists of profiles, extensions, value sets, code systems, examples, and other artifacts needed to create a FHIR IG. These are not the pages of the IG, but rather various definitions that underlie the IG presentation. You must run the IG publisher to create the IG itself. The FHIR export appears in the /fhir subdirectory under the designated \"out\" directory. The directory contains further subdirectories for code systems, extensions, the IG (guide), the logical model (logical), profiles, and value sets.","title":"FHIR Export"},{"location":"cimpl6ToolingReference/#logical-model-export","text":"The logical model is an alternative representation of the CIMPL model, expressed in a familiar FHIR-like format. The logical model closely follows the CIMPL definitions because it reflects the model prior to mapping to FHIR resources. Each entry is presented as if it were a new FHIR resource, rather than a profile. The logical model is formally expressed as a set of FHIR StructureDefinitions . These definitions are distinguished from profiles because the names generated by the tooling end in -model . Because the logical model does not entail the additional complication of mapping, it is useful for review purposes. The logical model can be checked for clinical relevance and sufficiency before making mapping decisions. An optional part of the FHIR export, the logical model can be turned on or off using the includeLogicalModels flag in the configuration file.","title":"Logical Model Export"},{"location":"cimpl6ToolingReference/#model-documentation-export","text":"The model documentation provides another way to view the logical model. This view emphasizes the class hierarchy defined in CIMPL, the datatypes, associated constraints, and relationships between the classes (references). The panel in the upper left allows the user to filter on the namespace and (in SHR-CLI 6.6 and higher) the class type (Entry, Group, or Element). The right-hand panel shows details for the selected class, include the full set of properties and constraints. For many users, especially those with experience in object-oriented modeling, the model documentation is the quickest way to navigate around the model.","title":"Model Documentation Export"},{"location":"cimpl6ToolingReference/#data-dictionary-export","text":"The Data Dictionary is an Microsoft Excel file containing a simplified, flattened list of model elements and value sets, extracted from the FHIR profiles. The spreadsheet has five tabs: The \"Key\" tab contains a key to the columns in the other tabs; The \"Profiles\" tab contains a list of the primary profiles and their descriptions; The \"Data Elements\" tab contains a list of Must-support and required elements associated with those profiles; The \"Value Sets\" tab contains a list of value sets used in the IG, and their descriptions; The \"Value Set Details\" tab contains a list of the codes and/or implicit definitions in those value sets. The Data Dictionary can be useful both to clinicians and implementers who don't need the structural details of the FHIR profiles, but want the contents in list form. For many reviewers and contributors, this can be an easy-to-use format to facilitate discussion and feedback.","title":"Data Dictionary Export"},{"location":"cimpl6ToolingReference/#json-schema-export","text":"( TO DO: determine what to say here )","title":"JSON Schema Export"},{"location":"cimpl6ToolingReference/#creating-the-implementation-guide","text":"The final step in the IG creation process is to run the FHIR IG Publisher . This tool is maintained and owned by HL7 FHIR. Open a command prompt, change directories to the tooling directory, and use one of these two options: If you used the default \"out\" directory when running SHR-CLI: $ yarn run ig:publish If you used a different \"out\" directory (e.g., mypath/out): $ java -Xms4g -Xmx8g -jar mypath/out/fhir/guide/org.hl7.fhir.publisher.jar -ig mypath/out/fhir/guide/ig.json Note: The IG publisher can take 15-30 minutes or even longer to run, depending on the size of the IG, and it takes lots of memory. The yarn script above will allocate up to 8GB of RAM. A minimum of 4GB of RAM is recommended to run the IG Publisher tool. When the publisher finishes, the IG can be opened by running the following commands. If you used default \"out\" directory: $ yarn run ig:open If you used a different \"out\" directory, by manually opening the file mypath/out/fhir/guide/output/index.html You now have your completed IG. The FHIR IG Publisher performs numerous validation checks on the content of the IG. The output of these checks can be accessed through the \"QA Report\" link in the footer of the home page, or by opening the file /out/fhir/guide/output/qa.html . An example QA output is shown below:","title":"Creating the Implementation Guide"},{"location":"cimpl6ToolingReference/#appendix-a-error-messages","text":"In the following, $ prefix indicates a variable that will be filled in with specific information.","title":"Appendix A: Error Messages"},{"location":"cimpl6ToolingReference/#table-of-contents_1","text":"Error Code Structure Parsing Errors Warning Codes Compilation Error Codes Mapping Error Codes","title":"Table of Contents"},{"location":"cimpl6ToolingReference/#error-code-structure","text":"CIMPL Compilation Errors are structured in the following format: 1 2 3 4 5 \u21b3 First digit tells whether it is an warning or error. 0 = warning, 1 = error 1 2 3 4 5 \u21b3 Second digit indicates the phase of processing where the error appeared: 1 = grammar and importing of the text files, 2 = logical verification of the model, 3 = exporting of FHIR profiles, 4 = exporting of the JSON profiles 1 2 3 4 5 \u21b3 The last three digits are for unique identification and have no particular meaning.","title":"Error Code Structure"},{"location":"cimpl6ToolingReference/#parsing-errors","text":"Parsing errors are generated when the importer cannot make sense of the contents of a CIMPL statement. Parsing error messages include the file, line, and column number, and can be linked directly to a location in a CIMPL file where parsing failed. Most other types of errors (with the exception of mapping errors) cannot be linked to a specific file location because they represent some type of a logical inconsistency. A typical parsing error looks like this: extraneous input 'Entry' expecting {<EOF>, 'CodeSystem:', 'Abstract:', 'Element:', 'Entry:', 'Group:'}. ERROR_CODE:11023 (module=shr-text-input, file=..\\shr-spec\\spec\\ns-onco-core\\oncocore.txt, line=9, column=0) When a parsing error occurs, the associated error code number and subsequent errors are not meaningful, since the entire model could not be read.","title":"Parsing Errors"},{"location":"cimpl6ToolingReference/#warning-codes","text":"Warning Code Warning Message Potential Solution 01001 No project configuration file found, currently using default EXAMPLE identifiers. Auto-generating a proper 'config.json' in your specifications folder Open the 'config.json' file and customize it for your project. 01002 Config file missing key: $KEY , using default key: $DEFAULT VALUE instead. Open the 'config.json' file and add your project specific details for that key. 02001 Potentially mismatched targets: $CLASS maps to $ITEM , but based on class ( $CLASS ) maps to $ITEM , and $ITEM is not based on $ELEMENT in $CLASS .' You are overriding an inherited mapping. 03001 Trying to map $PROFILE to $CODE , but $PROFILE was previously mapped to it 03002 Choice has equivalent types, so choice options may overwrite or override each other when mapped to FHIR. 03003 Overriding extensible value set constraint from $VS1 to $VS2 . Only allowed when new codes do not overlap meaning of old codes. The \"extensible\" binding means that a code from outside the given value set should be used only if the value set does not contain a suitable code. 03004 Element profiled on Basic. Consider a more specific mapping. The Basic profile should not be used in most cases. Consider a more specific profile mapping that categorizes the Element being mapped. 03005 No mapping to ' $ELEMENT PATH '. This property is core to the target resource and usually should be mapped. 03006 The $PROPERTY property is not bound to a value set, fixed to a code, or fixed to a quantity unit. This property is core to the target resource and usually should be constrained Usually a result of not setting the Code attribute of an Observation. 04001 Unsupported code system: ' $CODESYSTEM '","title":"Warning Codes"},{"location":"cimpl6ToolingReference/#compilation-error-codes","text":"Error Code Error Message Solution 11001 Element name ' $NAME ' should begin with a capital letter Rename the specified Element 11002 Entry name ' $NAME ' should begin with a capital letter Rename the specified Entry 11003 Unable to resolve value set reference: $VALUESET Invalid value set reference, double check the name and the path 11004 Unsupported binding strength: $BINDING_STRENGTH . Defaulting to REQUIRED Binding strength has to be one of the following: example, preferred, extensible, or required (default). 11005 Error parsing source path: $PATH Invalid path to definitions. Double check path. 11006 Invalid config file. Should be valid JSON dictionary Make sure your 'config.json' file is using a valid format for JSON. 11007 Unsupported grammar version: $VERSION Grammar Version for file must be 5.0 (or above) 11008 Defining value sets by URL has been deprecated in ValueSet files. ValueSet $VALUESET ignored. Define the value set with a name using proper syntax. 11009 Defining value sets by URN has been deprecated in ValueSet files. ValueSet $VALUESET ignored. Define the value set with a name using proper syntax. 11010 Couldn\u2019t resolve code system for alias: $ALIAS Invalid Codesystem, double check spelling 11011 Uses statements have been deprecated in ValueSet files. Uses statement ignored. Uses statement is unnecessary. Refer to documentation for proper syntax 11012 Only default path definitions are allowed in ValueSet files. Path definition ignored. Use one of the preset path definitions defined in the documentation. 11013 Failed to resolve definition for $ELEMENT_NAME The referenced Element doesn't exist in the current namespace, or in any of its inherited parents. Check spelling errors as well as imports. 11013 Failed to resolve definition for primitive Only certain primitives are supported. Please refer to the documentation to see the full list. 11015 token recognition error at: $CHARACTER This is usually a typo issue. Investigate keywords and missing colons around the specificed text input. 11016 mismatched input $INPUT expecting $LIST_OF_KEYWORDS This is usually a typo issue. Investigate spelling and keywords used around the specificied text input. 11017 Cannot resolve path without namespaces There was a failure to parse the namespace. Ensure the namespace is correctly defined. 11018 Failed to resolve path for $NAME . 11019 Found conflicting path for $NAME in multiple namespaces: $NAMESPACES 11020 Failed to resolve vocabulary for $NAME . 11021 Found conflicting vocabularies for $NAME in multiple namespaces: $NAMESPACES 11022 Found conflicting definitions for $NAME in multiple namespaces: $NAMESPACES 11023 Elements cannot be based on \"Value\" keyword 11024 Elements cannot use \"Value:\" modifier and specify \"Value\" field at same time. 11025 Fields cannot be constrained to type \"Value\" 11026 ref(Value) is an unsupported construct; treating as Value without the reference. 11027 Unable to import property $FQN , unknown value type: $VALUE_TYPE The type either does not exist, or the import tool needs to be updated. 11028 Unable to import unknown constraint type: $CONSTRAINT_TYPE The type either does not exist, or the import tool needs to be updated. 11029 Unable to import mapping, unknown rule type: $RULE_TYPE The type either does not exist, or the import tool needs to be updated. 11030 Unable to import VS rule, unknown rule type: $RULE_TYPE The type either does not exist, or the import tool needs to be updated. 11031 Unable to import FixedValueConstraint, unknown fixed value type: $RULE_TYPE The value type either does not exist, or the import tool needs to be updated. 11032 Project configuration not found! Exiting the program. There was an error finding or loading the configuration file. Please double check that it exists and is valid. 11033 Name $ELEMENT_ENTRY_NAME already exists. The entity or element name already exists within the namespace and the most recently defined element or entry name will be used. 11034 ValueSet name $VS_NAME already exists. The value set name already exists within the namespace. 11035 Definition not found for data element in content profile path: $ELEMENT_FQN . Could indicate a missing definition, misspelling, or missing Uses declaration. 11036 Path not found for $ELEMENT_FQN : $PATH . Usually when sub-elements in a dotted path (foo.bar.baz) can't be traced. See CIMPL path for more information. 11037 Could not find content profile file: $FILE_NAME . Check the name or path to the content profile file specified in your configuration file. 11038 Namespace declaration not found. File needs a namespace declaration at the top of the file under the Grammar declaration. 11039 Grammar declaration not found. File needs a Grammar declaration at the top of the file. 11040 Property $PROPERTY already exists. Extra declaration of Property needs to be removed. 11041 Choice value constrained without specifying the specific choice. 11042 Constraint refers to previous identifier. 11043 Value should not be declaring cardinality. Remove cardinality declared for the value. 11044 Missing a value element. 12001 Cannot resolve element definition. Element doesn't exist. Double check spelling and inheritance 12002 Reference to non-existing base: $ELEMENT_NAME Base doesn't exist. Double check spelling and inheritance. 12003 No cardinality found for value: $VALUE Explicitly define cardinality for that value. 12004 No cardinality found for field: $FIELD Explicity define cardinality for that field. 12005 Cannot override $OLD_VALUE with $NEW_VALUE Double check types match. 12006 Cannot override $OLD_VALUE with $NEW_VALUE since it is not one of the options Verify Identifiers match. 12007 Cannot override $OLD_VALUE with $NEW_VALUE Verify Identifiers match. 12008 Cannot override $OLD_VALUE with $NEW_VALUE since overriding ChoiceValue is not supported Verify Identifiers match. 12009 Unsupported constraint type: $CONSTRAINT Invalid constraint syntax. Consult documentation to see what constraints are supported 12010 Cannot constrain cardinality of $NAME from $SMALL_CARDINALITY to $BIGGER_CARDINALITY You can only narrow the cardinality. You cannot constrain it to have a larger range than its parent 12011 Cannot further constrain cardinality of $NAME from $CARDINALITY to $CARDINALITY You can only narrow the cardinality. You cannot constrain it to have a larger range than its parent 12012 Cannot constrain type of $NAME to $TYPE Make sure base types match 12013 Cannot constrain type of $NAME since it has no identifier Invalid Element 12014 Cannot constrain type of $NAME to $TYPE Make sure base types match 12015 Cannot further constrain type of $NAME from $TYPE to $TYPE The two elements aren't based on the same parent. You cannot constrain an element to one that is completely distinct. 12017 Cannot constrain type of $NAME since it has no identifier 12018 Cannot constrain element $NAME to $TARGET since it is an invalid sub-type Element has to be based on $s or otherwise is a child of $s . 12020 Cardinality of $NAME not found Please explicitly define the cardinality. 12021 Cannot include cardinality on $NAME , cardinality of $CARD doesnt fit within $CARD The cardinality of included parameters must be as narrow or narrower than the property it contains. 12022 Cannot constrain valueset of $NAME since it has no identifier 12023 Cannot constrain valueset of $NAME since neither it nor its value is a concept Only elements whose datatype is concept can be bound to a value set. 12024 Cannot constrain valueset of $NAME since it is already constrained to a single code 12025 Cannot constrain code of $NAME since neither it nor its value is a concept 12026 Cannot constrain included code of $NAME since neither it nor its value is a concept 12027 Cannot constrain boolean value of $NAME since neither it nor its value is a boolean You may be trying to set an element that is not a boolean to true or false. 12028 Cannot constrain boolean value of $NAME to $VALUE since a previous constraint constrains it to $VALUE Once a fixed constraint is applied, it cannot be changed in a child class. In this case, you might be switching a true to a false or vice versa. 12029 Cannot resolve element definition for $NAME This is due to a incomplete definition for an element. Please refer to the document for proper definition syntax. 12030 Cannot determine target item System error. 12031 Cannot resolve data element definition from path: $PATH Check spelling for field or value. 12032 Cannot resolve data element definition from path: $PATH Check spelling for field or value. 12033 Cannot map Value since element does not define a value Define a value for your element 12034 Cannot map Value since it is unsupported type: $VALUE_TYPE 12035 Found multiple matches for field $FIELD Please use fully qualified identifier. 12036 Could not find expanded definition of $ELEMENT . Inheritance calculations will be incomplete. Double check shr.base.Entry is defined within the specifications. 12037 Could not find based on element $ELEMENT for child element $ELEMENT . Double check the basedOn element is defined within the specifications and correctly referenced. 14001 Unsupported value set rule type: $s 14002 Unknown type for value $VALUE 14003 Unknown type for constraint $CONSTRAINT","title":"Compilation Error Codes"},{"location":"cimpl6ToolingReference/#mapping-error-codes","text":"Error Code Error Message Solution 13001 Invalid FHIR target: $TARGET Could not find the FHIR resource or profile you're trying to map to. Check spelling and FHIR version. 13002 Cannot flag path as mapped 13003 Slicing on include type constraints with paths is not supported 13004 Slicing required to disambiguate multiple mappings to $TARGET 13005 Invalid source path 13006 Invalid or unsupported target path 13007 Cannot unroll contentReference $CONTENT_REFERENCE on $ELEMENT because it is not a local reference 13008 Invalid content reference on $ELEMENT : $CONTENT_REFERENCE 13009 Cannot unroll $ELEMENT . Create an explicit choice element first. 13010 Cannot unroll $ELEMENT at $ELEMENT : invalid SHR element. 13011 Cannot make choice element explicit since it is not a choice ([x]): $ELEMENT 13012 Cannot make choice element explicit at $ELEMENT . Invalid SHR identifier: $IDENTIFIER . 13013 Invalid target path. Cannot apply cardinality constraint. 13014 Cannot constrain cardinality from $CARD to $CARD 13015 Invalid target path. Cannot apply fixed value. 13016 Currently, only fixing codes is supported (value must contain \"#\"). Unable to fix to $VALUE . This error message applies to SHR-CLI 6.4 and earlier. In SHR-CLI 6.5 and higher, fixed value constraints can be applied to integer and decimal values. 13017 Incompatible cardinality (using aggregation). Source cardinality $CARD does not fit in target cardinality 13018 Cannot constrain cardinality to $CARD because cardinality placement is ambiguous. Explicitly constrain parent elements in target path. See Error 13020 13019 Cannot constrain cardinality to $CARD because there is no tail cardinality min that can get us there See Error 13020 13020 Cannot constrain cardinality to $CARD because there is no tail cardinality max that can get us there When the target path is deeper than one level, cardinalities combine to get to the final (target) cardinality. The correct way to constrain the cardinality is ambiguous. For example, if B maps to a.b, and B is constrained to [0,4], there are multiple ways to get there: a[0..1].b[0..4] or a[0..1].b[1..4] or a[1..1].b[0..4] or a[0..4].b[0..1] etc. To resolve this error, ambiguous cardinalities in intermediate paths must be explicitly declared in the mapping file using the constrain keyword. 13021 Cannot constrain cardinality to $CARD because there is no tail cardinality that can get us there See Error 13020 13022 Mismatched types. Cannot map $SOURCE_VALUE to $MAPPING . Find the Entry referenced in the error details and change it to match the data type of the target field. 13023 Cannot resolve element definition for $ELEMENT 13024 Failed to resolve element path from $ELEMENT to $PATH 13025 Applying constraints to profiled children not yet supported. 13026 Failed to resolve path from $ELEMENT to $PATH 13027 Unsupported binding strength: $BINDING_STRENGTH 13028 Cannot change binding strength from $FHIR_BINDING_STRENGTH to $CIMPL_BINDING_STRENGTH The value set binding strength specified in CIMPL is weaker than the binding already specified in FHIR. You must increase the binding strength in the CIMPL model to at least the same level as in FHIR. Note that this error message gives the FHIR binding strength first. 13029 Cannot override value set constraint from $URI to $URI This message is given when you try to replace a FHIR value set, which is either extensible or required, with a different value set. 13030 Found more than one value set to apply to $ELEMENT . This should never happen and is probably a bug in the tool. 13031 Found more than one code to fix on $ELEMENT . This should never happen and is probably a bug in the tool. 13032 Can\u2019t fix code on $ELEMENT because source value isn\u2019t code-like. This should never happen and is probably a bug in the tool. 13033 Can\u2019t fix code on $ELEMENT because source value isn\u2019t code-like. This should never happen and is probably a bug in the tool. 13034 Cannot override code constraint from $VALUE to $VALUE 13035 Cannot override boolean constraint from $VALUE to $VALUE 13036 Found more than one boolean to fix on $ELEMENT . This should never happen and is probably a bug in the tool. 13037 Conversion from $VALUE to one of $TYPE drops boolean constraints 13038 Conversion from $VALUE to one of $TYPE drops value set constraints 13039 Conversion from $VALUE to one of $TYPE drops code constraints 13040 Conversion from $VALUE to one of $TYPE drops includesCode constraints 13041 Unable to establish namespace for $ELEMENT 13042 No slice name supplied for target. This should never happen and is probably a bug in the tool. 13043 Couldn\u2019t find target in slice $SLICE (Exporting) 13044 Target resolves to multiple elements but is not sliced 13045 Unable to establish namespace for $FIELD (Extensions) 13046 Mapping to MAP_TARGET 's RULE_TARGET : slice could not be found. 13047 Couldn't find sd to unroll 13048 Cannot override code constraint from $SYSTEM | $CODE to $SYSTEM | $CODE ' 13049 Unexpected error processing mapping to FHIR. 13050 Unexpected error processing mapping rule. 13051 Unexpected error adding extension. 13054 Using profile that is currently in the middle of processing: $PROFILE_ID . 13055 Using extension that is currently in the middle of processing: $EXTENSION_ID . 13056 Can't fix $TARGET to $VALUE since $TARGET is not one of: $ALLOWABLE_TYPES . 13057 Could not fix $TARGET to $VALUE ; failed to detect compatible type for value $VALUE . 13058 Cannot fix $TARGET to $VALUE since it is not a $TYPE type. 13059 Cannot fix $TARGET to $VALUE since it is already fixed to $OTHER_VALUE . 13060 Could not determine how to map nested value ( $ELEMENT_PATH ) to FHIR profile. Occurs on the FHIR profile export when there are multiple levels of reference specified. e.g.: LaboratoryObservationTopic.Specimen.CollectionSite within LaboratoryObservationTopic. Resolved by creating a reference in the cimi entity to FHIR map in cimi_entity_map.txt. 13061 Mapping $ELEMENT sub-fields is currently not supported. 13062 Cannot make choice element explicit at $ELEMENT . Could not find compatible type match for: $TYPE . 13063 Could not find FHIR element with path $ELEMENT_PATH for content profile rule with path $RULE_PATH . 13064 Could not find FHIR element for content profile rule with path $RULE_PATH . 13065 Could not find FHIR element subextension for content profile rule with path $RULE_PATH .","title":"Mapping Error Codes"},{"location":"cimpl6Tutorial_detail/","text":"CIMPL 6.0 In-depth Tutorial Preface Purpose of this Document This is an extensive tutorial, meant to expose the reader to many aspects of CIMPL without going into full depth on any particular topic. Intended Audience The CIMPL Authoring Guide is targeted to any person comfortable with using software developers or people comfortable with programming languages. Familiarity with FHIR is helpful as the tutorial references FHIR artifacts (such as Resources, Elements, etc.) Prerequisite This guide assumes you have: Installed the latest version of the SHR-CLI software as documented in CIMPL SetUp and Installation (preferably installed in the ~/cimpl/shr-cli directory) A text editor to edit you CIMPL files (preferably VSCode with the vs-code-language-cimpl extension, but not required) Reviewed the Hello World Tutorial . Table of Contents CIMPL 6.0 In-depth Tutorial Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Initial Setup Modeling Process Define Use Cases Create a High-level Conceptual Model Create a List of Data Elements Create the Logical Model in CIMPL Creating Custom Value Sets Create Logical Model to FHIR mappings Generate the FHIR IG Specify the FHIR \"Must-Support\" elements Create a Homepage for the IG Configure the Output Compile CIMPL Run the FHIR IG Publisher Add FHIR Examples to your IG Initial Setup Note: This tutorial was run using a MacOS environment. While CIMPL is platform independent, the command lines run in a command line terminal will differ in file path specifications. For a Windows command line terminal, replace all the path references of forward-slash / to back-slash \\ . To keep this tutorial more focused on how to model, we're first going to setup the environment with some supporting configuration and core data type files. The following directory structure is assumed: Directory: cimpl |_ shr-cli Note: Your top level directory where SHR-CLI was installed might differ. If so, then you'll be instead referencing the relative directory where you have installed shr-cli. Create a sub-directory under cimpl called myExampleC6 Now your directory structure should look like this: Directory: cimpl |_ shr-cli |_ myExampleC6 Copy the following files to the myExampleC6 sub-directory. The files contain global definitions for Code Systems, Value Sets, maps to FHIR R4 elements and examples. These file names are hyperlinked for retrieval: File Purpose obf-datatype.txt Contains CIMPL datatype definitions obf-datatype-vs.txt Contains value sets supporting the datatypes obf-datatype-map-r4.txt Provides mapping between CIMPL datatypes and FHIR 4.0 datatypes ig-myExampleR4-config.json Has configuration settings to support implementation guide creation Modeling Process This tutorial guides you in a step by step process to build a basic clinical data model that directly references FHIR resources. It also illustrates the modeling practice briefly described in Appendix A of the CIMPL Authoring Guide . The steps are briefly summarized here for conciseness: Define use case(s) Create a high-level conceptual model Create a data element requirement list Create the logical model Create logical element-to-FHIR mappings Generate the FHIR Implementation Guide Create FHIR examples for each profile (optional) Define Use Cases For our example, we'll focus on obstructive sleep apnea (OSA) . The goal is to measure the prevalence of patients diagnosed with OSA, stratified by age groups. A secondary goal is to further identify the population by gender. Electronic Health Records (EHRs) are the primary source for this information. Create a High-level Conceptual Model A conceptual diagram is shown in the figure below: Diagrams of this sort may be valuable to the community reviewing and using the implementation guide, especially when the model is complex, and can serve as a basis from which to drive further design of the model. Create a List of Data Elements Creating a list of data elements helps to refine the contents, data types, cardinality, and clinical terminologies needed in the model. It helps at this stage to research existing standards and related models, but for this example, we won't look beyond FHIR resources for inspiration. The table below is a high level summary of the elements we need in this use case: Entity Data Element Name Cardinality Data type Value Set (if applicable) Patient BirthDate 1..1 date Patient Gender 0..1 concept HL7 Administrative Gender OSADisorder OSADisorderCode 1..1 concept SNOMED codes for OSA OSADisorder OSADisorderStatus 0..1 concept HL7 status codes Create the Logical Model in CIMPL Now we can start authoring models in the CIMPL development environment. In this example, the only part of the CIMPL Class Library we are using are the datatypes. CIMPL has three main files involved in the creation of a logical model - one of each for every CIMPL project. We list them here for brevity, but reference the CIMPL 6 Language Reference Guide for further details on each: Class file Value Set file Map file The class file is the place to start. Create a new file under the myExampleC6 subdirectory called myExample.txt . Type in the CIMPL header information designating the namespace and version of the DataElement parser: Grammar: DataElement 6.0 Namespace: myExample Description: \"CIMPL Tutorial: myExample for an OSA patient.\" Uses: obf.datatype Where: Grammar is a required keyword indicating the parser to be used, in this case DataElement 6.0 Namespace , also required, is a short name for your project, implementation guide, or module you are defining. This should be a meaningful and easily recognizable name. Uses is the list of all namespaces which your model elements will reference. For our example, we fix this to obf.datatype . Next, we will create our first class, called MyPatient , which we determined will also have the following properties: MyBirthDate (a required field which only accepts one value) MyGender (an optional field that we want to have the receiver accept, if the value is known.) Let's build our Patient logical model. Add the following lines below your CIMPL header: Entry: MyPatient Description: \"An individual awaiting or under medical care and treatment. (source: Webster's Dictionary)\" Property: MyBirthDate 1..1 Property: MyGender 0..1 Element: MyBirthDate Description: \"The date when the patient was born.\" Value: date Element: MyGender Description: \"Either of the two sexes (male and female), especially when considered with reference to social and cultural differences rather than biological ones. (source: Oxford Dictionary)\" Value: concept from http://hl7.org/fhir/ValueSet/administrative-gender What we just represented here is that there is a Patient entity called MyPatient which has 2 properties: MyBirthdate and MyGender . The FHIR Patient resource has these attributes; for purposes of this tutorial we will not consider that information -- your logical model won't always have the same attributes as a FHIR resource. We determined from our clinical requirements that MyBirthDate has a data type of date , which is one of the primitive data types supported in CIMPL. The Value keyword expresses the desired datatype. We also determined that MyGender is a value set that can be male , female , or unknown . For the sake of simplicity, we find that HL7 has a matching value set identical to our requirements so we'll use that one for its value. In this case, the Value keyword not only says that the datatype is a concept (the CIMPL primitive for coded types), but also says that the concept must come from the value set http://hl7.org/fhir/ValueSet/administrative-gender . Now let's work on the OSA Disorder entity. Add the following text into the file: Entry: ObstructiveSleepApneaDisorder Description: \"Obstructive sleep apnea (OSA) is a sleep-related breathing disorder that involves a decrease or complete halt in airflow despite an ongoing effort to breathe. It occurs when the muscles relax during sleep, causing soft tissue in the back of the throat to collapse and block the upper airway. (source: American Academy of Sleep Medicine)\" Property: OSADisorderCode 1..1 Property: OSACurrentStatus 0..1 Element: OSADisorderCode Description: \"The diagnosis or problem list code assigned to the OSA disorder.\" Value: concept from OSADisorderVS Element: OSACurrentStatus Description: \"State of the diagnosis or problem list item.\" Value: concept from OSACurrentStatusVS Here we specify the entity called ObstructiveSleepApneaDisorder containing two properties, the disorder code and current status. Both properties are defined as concepts that reference value sets (yet to be defined). If you are familiar with the FHIR Condition resource you will notice that the elements in your model replicate two Condition elements. At a later point in this tutorial, the elements will be mapped to FHIR resource elements. Creating Custom Value Sets We now need to define the value sets, OSADisorderVS and OSACurrentStatusVS. Create a new file called myExample-vs.txt underneath the myExampleC6 directory, and add the CIMPL value set header information below: Grammar: ValueSet 5.1 Namespace: myExample Where: Grammar is the keyword which specifies that the file created is a value set file conforming to CIMPL value set parser version 5.1. Namespace is the keyword whose value contains the namespace defined for your model. In this case, it's myExample . Next we specify the terms in the value sets, which we've already defined in our clinical data requirements. Add the following text below the CIMPL value set header information: CodeSystem: SCT = http://snomed.info/sct CodeSystem: STAT = http://terminology.hl7.org/CodeSystem/condition-clinical ValueSet: OSADisorderVS Description: \"The list of disorders related to Obstructive Sleep Apnea.\" SCT#1101000119103 \"Obstructive sleep apnea of adult (disorder)\" SCT#1091000119108 \"Obstructive sleep apnea of child (disorder)\" ValueSet: OSACurrentStatusVS Description: \"The current disease status of an OSA patient\" STAT#active \"Active\" STAT#inactive \"Inactive\" STAT#resolved \"Resolved\" Here the CodeSystem keyword defines which terminologies (such as SNOMED-CT, ICD-10, etc.) the codes in value sets are drawn from. The code systems are referred to by URLs. To learn more about code systems and the relationship to value sets, see https://www.hl7.org/fhir/codesystem.html. The format for specifying each term in the value set is as follows: <CodeSystem Alias>#<Code> \"<Display>\" , for example: STAT#active \"Active\" where: STAT is an alias that represents the http://terminology.hl7.org/CodeSystem/condition-clinical code system, assigned in the CodeSystem: statement # is a delimiter separating the coding system and the code active is the term code for the concept \"Active\" is the display name associated with the term code. Note: Code system aliases are required. Direct use of a URL or urn (e.g., http://terminology.hl7.org/CodeSystem/condition-clinical#active ) is NOT currently supported in CIMPL. Create Logical Model to FHIR mappings Create a file called myExample-map-r4.txt under the myExampleC6 sub-directory, and copy the following header information to the top of the file: Grammar: Map 5.1 Namespace: myExample Target: FHIR_R4 Where: Grammar: is the version supported for the mapping grammar Namespace: is the name of the namespace for your logical model (same as used before) Target: is the FHIR release version targeted for mapping elements in your logical model, one of the following values: FHIR_DSTU2, FHIR_STU_3, or FHIR_R4. Our mapping will be to FHIR_R4. Specifying the target also configures the CIMPL tool chain to generate R4 structure definitions. During mapping, we ask the following questions: Is there a FHIR resource that could be a good fit for our logical model entities? If yes, is there an equivalent FHIR attribute or extension for each of the properties in our logical model? If there is an equivalent FHIR attribute then do the data types, cardinality constraints, and terminology bindings align? For simplicity, we made the example such that the answer is yes to all questions. MyPatient entity can map to the Patient resource, and ObstructiveSleepApneaDisorder can map to the Condition resource. Because we have specified our target map to be FHIR_R4 , our mappings target the R4 version. Add the following statements to your map file: MyPatient maps to Patient: MyBirthDate maps to birthDate MyGender maps to gender ObstructiveSleepApneaDisorder maps to Condition: OSADisorderCode maps to code OSACurrentStatus maps to clinicalStatus The logical model properties also match to equivalent FHIR attributes for each resource we've chosen to build our profiles. And because FHIR profiling does allow to further constrain and not loosen cardinality constraints and binding strengths, we can confirm that our elements also satisfy those requirements. Generate the FHIR IG In this section, we cover some of the extra CIMPL configuration steps that might be needed to customize the output of your FHIR IG. Specify the FHIR \"Must-Support\" elements The CIMPL toolchain provides a separate configuration file called a Content Profile which serves two purposes: Specifies which elements in your logical model that you want to designate in FHIR as \"must-support\" (MS) in FHIR. Instructs the CIMPL toolchain which elements you want auto-generated in a data dictionary output. Together with specified cardinality, the MS declaration can be interpreted as follows : Cardinality Must Support Interpretation 1..1 any required 0..1 yes required if known 0..1 no optional Create a file called ig-myExample-cp.txt under the myExampleC6 sub-directory. Paste the following code snippet into your file: Grammar: ContentProfile 1.0 Namespace: myExample MyPatient: MyGender MS ObstructiveSleepApneaDisorder: OSADisorderCode MS For our example, we have designated the MyGender and OSADisorderCode elements as must-support . Content Profile documentation can be found in the CIMPL Tooling Reference Guide . Create a Homepage for the IG Create a new file called index.html under the myExampleC6 directory. Copy the following contents in this page: <h1>myExample Implementation Guide</h1> <p>CIMPL Tutorial demonstrating how to create FHIR profiles and an IG.</p> Configure the Output For purpose of the tutorial's focus on modeling, we have already created a configuration file called ig-myExampleR4-config.json and you copied this file to the myExampleC6 directory at the start of this tutorial. Let's review some highlights of the configuration file (click link to open). The table below shows a partial listing of fields in the config file. More advanced configuration options are available in the CIMPL Tooling Reference Guide . Parameter Value Meaning ProjectName \"My Example Project\" This will appear on the home page title of your generated IG. fhirURL \"http://example.com/fhir\" The URL pre-pended to your StructureDefinition canonical URLs. contentProfile \"ig-myExample-cp.txt\" The name of the file which sets FHIR must-support flags. filterStrategy \"true\" Indicates that not all Entries in the logical model should be included in the IG. target [\"myExample\"] JSON array containing the namespace(s) targeted by the filtering strategy. indexContent \"index.html\" The file containing the IG homepage. Compile CIMPL To create profiles, extensions, and other FHIR assets used in the IG, you run the SHR-CLI tool, as follows: Open a command line terminal and navigate to the ~/cimpl/shr-cli directory (where you installed SHR-CLI) Run the following command: node . ../myExampleC6 -l error -o myExampleC6r4 -c ig-myExampleR4-config.json Where: node is the command that starts the SHR-CLI application. The first dot . represents the path to the SHR-CLI tool, in this case, the current working directory. The dot represents the current directory. ../myExampleC6 is the path where your CIMPL modeling and configuration files are located. The double dot .. represents the directory above the current working directory. the -l parameter and error value specifies logging to only show errors. the -o parameter and myExampleC6r4 value specify the name of the directory in which you want to generate the IG output. the -c parameter and ig-myExampleR4-config.json value specify the name of the CIMPL configuration file to reference for the output. After you run this first command, as an interim check, navigate to the ~/cimpl/shr-cli folder. You should see a new subdirectory created called myExampleC6r4 which will eventually contain the StructureDefinition and html output of the generated IG. This is the value that was specified in the -o parameter in the above command. Run the FHIR IG Publisher From the same command line terminal, run the following command: yarn run ig:publish Alternately, run the full command to specify the destination directory (following the -ig flag): java $JAVA_OPTS -jar myExampleC6r4/fhir/guide/org.hl7.fhir.publisher.jar -ig myExampleC6r4/fhir/guide/ig.json Navigate to the ~/cimpl/shr-cli/myExampleC6r4/fhir/guide/output directory and open the index.html file in a browser. This will display the home page of the generated FHIR IG for your example project. Add FHIR Examples to your IG We're now going to add a FHIR example that conforms to our profile. This step adds an example file to the directory you created in the first step. Since the details creating FHIR examples are out of scope for this tutorial, we're going to supply one for you. First, create a subdirectory called examples-myFhirExamplesFolder under the myExampleC6 folder. Directory: cimpl |_ shr-cli |_ myExampleC6 |_ examples-myFhirExamplesFolder Copy the file myPatientExample1.json and its contents into the -myFhirExamplesFolder . Note: The FHIR example can contain additional content, and still pass validation. What matters is that the requirements of the profile are met. Add the following line to your cimpl configuration file within the \"implementationGuide\": JSON object: \"examples\": \"examples-myFhirExamplesFolder\" The following screenshot shows where to put this parameter within the CIMPL configuration file ig-myExampleR4-config.json : Now run SHR-CLI and the IG publisher commands again: node . ../myExampleC6 -l error -o myExampleC6r4 -c ig-myExampleR4-config.json yarn run ig:publish Open the index.html file from the generated IG output in your browser and navigate to the Profiles tab and select the MyPatient profile. You'll now find a tab called Examples which contains a URL to the example within the examples-myFhirExamplesFolder . So you might be thinking, \"How does the IG know which profile to add your example to?\" The answer is that the name of the related FHIR StructureDefinition for the profile is specified within the FHIR example itself: The IG Publisher will match the canonical URL specified in the example with that specified in the IG. Note that the value of the profile parameter must match the canonical URL of the profile where the StructureDefinition is located in order for the example to appear.","title":"CIMPL 6.0 In-depth Tutorial"},{"location":"cimpl6Tutorial_detail/#cimpl-60-in-depth-tutorial","text":"","title":"CIMPL 6.0 In-depth Tutorial"},{"location":"cimpl6Tutorial_detail/#preface","text":"","title":"Preface"},{"location":"cimpl6Tutorial_detail/#purpose-of-this-document","text":"This is an extensive tutorial, meant to expose the reader to many aspects of CIMPL without going into full depth on any particular topic.","title":"Purpose of this Document"},{"location":"cimpl6Tutorial_detail/#intended-audience","text":"The CIMPL Authoring Guide is targeted to any person comfortable with using software developers or people comfortable with programming languages. Familiarity with FHIR is helpful as the tutorial references FHIR artifacts (such as Resources, Elements, etc.)","title":"Intended Audience"},{"location":"cimpl6Tutorial_detail/#prerequisite","text":"This guide assumes you have: Installed the latest version of the SHR-CLI software as documented in CIMPL SetUp and Installation (preferably installed in the ~/cimpl/shr-cli directory) A text editor to edit you CIMPL files (preferably VSCode with the vs-code-language-cimpl extension, but not required) Reviewed the Hello World Tutorial .","title":"Prerequisite"},{"location":"cimpl6Tutorial_detail/#table-of-contents","text":"CIMPL 6.0 In-depth Tutorial Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Initial Setup Modeling Process Define Use Cases Create a High-level Conceptual Model Create a List of Data Elements Create the Logical Model in CIMPL Creating Custom Value Sets Create Logical Model to FHIR mappings Generate the FHIR IG Specify the FHIR \"Must-Support\" elements Create a Homepage for the IG Configure the Output Compile CIMPL Run the FHIR IG Publisher Add FHIR Examples to your IG","title":"Table of Contents"},{"location":"cimpl6Tutorial_detail/#initial-setup","text":"Note: This tutorial was run using a MacOS environment. While CIMPL is platform independent, the command lines run in a command line terminal will differ in file path specifications. For a Windows command line terminal, replace all the path references of forward-slash / to back-slash \\ . To keep this tutorial more focused on how to model, we're first going to setup the environment with some supporting configuration and core data type files. The following directory structure is assumed: Directory: cimpl |_ shr-cli Note: Your top level directory where SHR-CLI was installed might differ. If so, then you'll be instead referencing the relative directory where you have installed shr-cli. Create a sub-directory under cimpl called myExampleC6 Now your directory structure should look like this: Directory: cimpl |_ shr-cli |_ myExampleC6 Copy the following files to the myExampleC6 sub-directory. The files contain global definitions for Code Systems, Value Sets, maps to FHIR R4 elements and examples. These file names are hyperlinked for retrieval: File Purpose obf-datatype.txt Contains CIMPL datatype definitions obf-datatype-vs.txt Contains value sets supporting the datatypes obf-datatype-map-r4.txt Provides mapping between CIMPL datatypes and FHIR 4.0 datatypes ig-myExampleR4-config.json Has configuration settings to support implementation guide creation","title":"Initial Setup"},{"location":"cimpl6Tutorial_detail/#modeling-process","text":"This tutorial guides you in a step by step process to build a basic clinical data model that directly references FHIR resources. It also illustrates the modeling practice briefly described in Appendix A of the CIMPL Authoring Guide . The steps are briefly summarized here for conciseness: Define use case(s) Create a high-level conceptual model Create a data element requirement list Create the logical model Create logical element-to-FHIR mappings Generate the FHIR Implementation Guide Create FHIR examples for each profile (optional)","title":"Modeling Process"},{"location":"cimpl6Tutorial_detail/#define-use-cases","text":"For our example, we'll focus on obstructive sleep apnea (OSA) . The goal is to measure the prevalence of patients diagnosed with OSA, stratified by age groups. A secondary goal is to further identify the population by gender. Electronic Health Records (EHRs) are the primary source for this information.","title":"Define Use Cases"},{"location":"cimpl6Tutorial_detail/#create-a-high-level-conceptual-model","text":"A conceptual diagram is shown in the figure below: Diagrams of this sort may be valuable to the community reviewing and using the implementation guide, especially when the model is complex, and can serve as a basis from which to drive further design of the model.","title":"Create a High-level Conceptual Model"},{"location":"cimpl6Tutorial_detail/#create-a-list-of-data-elements","text":"Creating a list of data elements helps to refine the contents, data types, cardinality, and clinical terminologies needed in the model. It helps at this stage to research existing standards and related models, but for this example, we won't look beyond FHIR resources for inspiration. The table below is a high level summary of the elements we need in this use case: Entity Data Element Name Cardinality Data type Value Set (if applicable) Patient BirthDate 1..1 date Patient Gender 0..1 concept HL7 Administrative Gender OSADisorder OSADisorderCode 1..1 concept SNOMED codes for OSA OSADisorder OSADisorderStatus 0..1 concept HL7 status codes","title":"Create a List of Data Elements"},{"location":"cimpl6Tutorial_detail/#create-the-logical-model-in-cimpl","text":"Now we can start authoring models in the CIMPL development environment. In this example, the only part of the CIMPL Class Library we are using are the datatypes. CIMPL has three main files involved in the creation of a logical model - one of each for every CIMPL project. We list them here for brevity, but reference the CIMPL 6 Language Reference Guide for further details on each: Class file Value Set file Map file The class file is the place to start. Create a new file under the myExampleC6 subdirectory called myExample.txt . Type in the CIMPL header information designating the namespace and version of the DataElement parser: Grammar: DataElement 6.0 Namespace: myExample Description: \"CIMPL Tutorial: myExample for an OSA patient.\" Uses: obf.datatype Where: Grammar is a required keyword indicating the parser to be used, in this case DataElement 6.0 Namespace , also required, is a short name for your project, implementation guide, or module you are defining. This should be a meaningful and easily recognizable name. Uses is the list of all namespaces which your model elements will reference. For our example, we fix this to obf.datatype . Next, we will create our first class, called MyPatient , which we determined will also have the following properties: MyBirthDate (a required field which only accepts one value) MyGender (an optional field that we want to have the receiver accept, if the value is known.) Let's build our Patient logical model. Add the following lines below your CIMPL header: Entry: MyPatient Description: \"An individual awaiting or under medical care and treatment. (source: Webster's Dictionary)\" Property: MyBirthDate 1..1 Property: MyGender 0..1 Element: MyBirthDate Description: \"The date when the patient was born.\" Value: date Element: MyGender Description: \"Either of the two sexes (male and female), especially when considered with reference to social and cultural differences rather than biological ones. (source: Oxford Dictionary)\" Value: concept from http://hl7.org/fhir/ValueSet/administrative-gender What we just represented here is that there is a Patient entity called MyPatient which has 2 properties: MyBirthdate and MyGender . The FHIR Patient resource has these attributes; for purposes of this tutorial we will not consider that information -- your logical model won't always have the same attributes as a FHIR resource. We determined from our clinical requirements that MyBirthDate has a data type of date , which is one of the primitive data types supported in CIMPL. The Value keyword expresses the desired datatype. We also determined that MyGender is a value set that can be male , female , or unknown . For the sake of simplicity, we find that HL7 has a matching value set identical to our requirements so we'll use that one for its value. In this case, the Value keyword not only says that the datatype is a concept (the CIMPL primitive for coded types), but also says that the concept must come from the value set http://hl7.org/fhir/ValueSet/administrative-gender . Now let's work on the OSA Disorder entity. Add the following text into the file: Entry: ObstructiveSleepApneaDisorder Description: \"Obstructive sleep apnea (OSA) is a sleep-related breathing disorder that involves a decrease or complete halt in airflow despite an ongoing effort to breathe. It occurs when the muscles relax during sleep, causing soft tissue in the back of the throat to collapse and block the upper airway. (source: American Academy of Sleep Medicine)\" Property: OSADisorderCode 1..1 Property: OSACurrentStatus 0..1 Element: OSADisorderCode Description: \"The diagnosis or problem list code assigned to the OSA disorder.\" Value: concept from OSADisorderVS Element: OSACurrentStatus Description: \"State of the diagnosis or problem list item.\" Value: concept from OSACurrentStatusVS Here we specify the entity called ObstructiveSleepApneaDisorder containing two properties, the disorder code and current status. Both properties are defined as concepts that reference value sets (yet to be defined). If you are familiar with the FHIR Condition resource you will notice that the elements in your model replicate two Condition elements. At a later point in this tutorial, the elements will be mapped to FHIR resource elements.","title":"Create the Logical Model in CIMPL"},{"location":"cimpl6Tutorial_detail/#creating-custom-value-sets","text":"We now need to define the value sets, OSADisorderVS and OSACurrentStatusVS. Create a new file called myExample-vs.txt underneath the myExampleC6 directory, and add the CIMPL value set header information below: Grammar: ValueSet 5.1 Namespace: myExample Where: Grammar is the keyword which specifies that the file created is a value set file conforming to CIMPL value set parser version 5.1. Namespace is the keyword whose value contains the namespace defined for your model. In this case, it's myExample . Next we specify the terms in the value sets, which we've already defined in our clinical data requirements. Add the following text below the CIMPL value set header information: CodeSystem: SCT = http://snomed.info/sct CodeSystem: STAT = http://terminology.hl7.org/CodeSystem/condition-clinical ValueSet: OSADisorderVS Description: \"The list of disorders related to Obstructive Sleep Apnea.\" SCT#1101000119103 \"Obstructive sleep apnea of adult (disorder)\" SCT#1091000119108 \"Obstructive sleep apnea of child (disorder)\" ValueSet: OSACurrentStatusVS Description: \"The current disease status of an OSA patient\" STAT#active \"Active\" STAT#inactive \"Inactive\" STAT#resolved \"Resolved\" Here the CodeSystem keyword defines which terminologies (such as SNOMED-CT, ICD-10, etc.) the codes in value sets are drawn from. The code systems are referred to by URLs. To learn more about code systems and the relationship to value sets, see https://www.hl7.org/fhir/codesystem.html. The format for specifying each term in the value set is as follows: <CodeSystem Alias>#<Code> \"<Display>\" , for example: STAT#active \"Active\" where: STAT is an alias that represents the http://terminology.hl7.org/CodeSystem/condition-clinical code system, assigned in the CodeSystem: statement # is a delimiter separating the coding system and the code active is the term code for the concept \"Active\" is the display name associated with the term code. Note: Code system aliases are required. Direct use of a URL or urn (e.g., http://terminology.hl7.org/CodeSystem/condition-clinical#active ) is NOT currently supported in CIMPL.","title":"Creating Custom Value Sets"},{"location":"cimpl6Tutorial_detail/#create-logical-model-to-fhir-mappings","text":"Create a file called myExample-map-r4.txt under the myExampleC6 sub-directory, and copy the following header information to the top of the file: Grammar: Map 5.1 Namespace: myExample Target: FHIR_R4 Where: Grammar: is the version supported for the mapping grammar Namespace: is the name of the namespace for your logical model (same as used before) Target: is the FHIR release version targeted for mapping elements in your logical model, one of the following values: FHIR_DSTU2, FHIR_STU_3, or FHIR_R4. Our mapping will be to FHIR_R4. Specifying the target also configures the CIMPL tool chain to generate R4 structure definitions. During mapping, we ask the following questions: Is there a FHIR resource that could be a good fit for our logical model entities? If yes, is there an equivalent FHIR attribute or extension for each of the properties in our logical model? If there is an equivalent FHIR attribute then do the data types, cardinality constraints, and terminology bindings align? For simplicity, we made the example such that the answer is yes to all questions. MyPatient entity can map to the Patient resource, and ObstructiveSleepApneaDisorder can map to the Condition resource. Because we have specified our target map to be FHIR_R4 , our mappings target the R4 version. Add the following statements to your map file: MyPatient maps to Patient: MyBirthDate maps to birthDate MyGender maps to gender ObstructiveSleepApneaDisorder maps to Condition: OSADisorderCode maps to code OSACurrentStatus maps to clinicalStatus The logical model properties also match to equivalent FHIR attributes for each resource we've chosen to build our profiles. And because FHIR profiling does allow to further constrain and not loosen cardinality constraints and binding strengths, we can confirm that our elements also satisfy those requirements.","title":"Create Logical Model to FHIR mappings"},{"location":"cimpl6Tutorial_detail/#generate-the-fhir-ig","text":"In this section, we cover some of the extra CIMPL configuration steps that might be needed to customize the output of your FHIR IG.","title":"Generate the FHIR IG"},{"location":"cimpl6Tutorial_detail/#specify-the-fhir-must-support-elements","text":"The CIMPL toolchain provides a separate configuration file called a Content Profile which serves two purposes: Specifies which elements in your logical model that you want to designate in FHIR as \"must-support\" (MS) in FHIR. Instructs the CIMPL toolchain which elements you want auto-generated in a data dictionary output. Together with specified cardinality, the MS declaration can be interpreted as follows : Cardinality Must Support Interpretation 1..1 any required 0..1 yes required if known 0..1 no optional Create a file called ig-myExample-cp.txt under the myExampleC6 sub-directory. Paste the following code snippet into your file: Grammar: ContentProfile 1.0 Namespace: myExample MyPatient: MyGender MS ObstructiveSleepApneaDisorder: OSADisorderCode MS For our example, we have designated the MyGender and OSADisorderCode elements as must-support . Content Profile documentation can be found in the CIMPL Tooling Reference Guide .","title":"Specify the FHIR \"Must-Support\" elements"},{"location":"cimpl6Tutorial_detail/#create-a-homepage-for-the-ig","text":"Create a new file called index.html under the myExampleC6 directory. Copy the following contents in this page: <h1>myExample Implementation Guide</h1> <p>CIMPL Tutorial demonstrating how to create FHIR profiles and an IG.</p>","title":"Create a Homepage for the IG"},{"location":"cimpl6Tutorial_detail/#configure-the-output","text":"For purpose of the tutorial's focus on modeling, we have already created a configuration file called ig-myExampleR4-config.json and you copied this file to the myExampleC6 directory at the start of this tutorial. Let's review some highlights of the configuration file (click link to open). The table below shows a partial listing of fields in the config file. More advanced configuration options are available in the CIMPL Tooling Reference Guide . Parameter Value Meaning ProjectName \"My Example Project\" This will appear on the home page title of your generated IG. fhirURL \"http://example.com/fhir\" The URL pre-pended to your StructureDefinition canonical URLs. contentProfile \"ig-myExample-cp.txt\" The name of the file which sets FHIR must-support flags. filterStrategy \"true\" Indicates that not all Entries in the logical model should be included in the IG. target [\"myExample\"] JSON array containing the namespace(s) targeted by the filtering strategy. indexContent \"index.html\" The file containing the IG homepage.","title":"Configure the Output"},{"location":"cimpl6Tutorial_detail/#compile-cimpl","text":"To create profiles, extensions, and other FHIR assets used in the IG, you run the SHR-CLI tool, as follows: Open a command line terminal and navigate to the ~/cimpl/shr-cli directory (where you installed SHR-CLI) Run the following command: node . ../myExampleC6 -l error -o myExampleC6r4 -c ig-myExampleR4-config.json Where: node is the command that starts the SHR-CLI application. The first dot . represents the path to the SHR-CLI tool, in this case, the current working directory. The dot represents the current directory. ../myExampleC6 is the path where your CIMPL modeling and configuration files are located. The double dot .. represents the directory above the current working directory. the -l parameter and error value specifies logging to only show errors. the -o parameter and myExampleC6r4 value specify the name of the directory in which you want to generate the IG output. the -c parameter and ig-myExampleR4-config.json value specify the name of the CIMPL configuration file to reference for the output. After you run this first command, as an interim check, navigate to the ~/cimpl/shr-cli folder. You should see a new subdirectory created called myExampleC6r4 which will eventually contain the StructureDefinition and html output of the generated IG. This is the value that was specified in the -o parameter in the above command.","title":"Compile CIMPL"},{"location":"cimpl6Tutorial_detail/#run-the-fhir-ig-publisher","text":"From the same command line terminal, run the following command: yarn run ig:publish Alternately, run the full command to specify the destination directory (following the -ig flag): java $JAVA_OPTS -jar myExampleC6r4/fhir/guide/org.hl7.fhir.publisher.jar -ig myExampleC6r4/fhir/guide/ig.json Navigate to the ~/cimpl/shr-cli/myExampleC6r4/fhir/guide/output directory and open the index.html file in a browser. This will display the home page of the generated FHIR IG for your example project.","title":"Run the FHIR IG Publisher"},{"location":"cimpl6Tutorial_detail/#add-fhir-examples-to-your-ig","text":"We're now going to add a FHIR example that conforms to our profile. This step adds an example file to the directory you created in the first step. Since the details creating FHIR examples are out of scope for this tutorial, we're going to supply one for you. First, create a subdirectory called examples-myFhirExamplesFolder under the myExampleC6 folder. Directory: cimpl |_ shr-cli |_ myExampleC6 |_ examples-myFhirExamplesFolder Copy the file myPatientExample1.json and its contents into the -myFhirExamplesFolder . Note: The FHIR example can contain additional content, and still pass validation. What matters is that the requirements of the profile are met. Add the following line to your cimpl configuration file within the \"implementationGuide\": JSON object: \"examples\": \"examples-myFhirExamplesFolder\" The following screenshot shows where to put this parameter within the CIMPL configuration file ig-myExampleR4-config.json : Now run SHR-CLI and the IG publisher commands again: node . ../myExampleC6 -l error -o myExampleC6r4 -c ig-myExampleR4-config.json yarn run ig:publish Open the index.html file from the generated IG output in your browser and navigate to the Profiles tab and select the MyPatient profile. You'll now find a tab called Examples which contains a URL to the example within the examples-myFhirExamplesFolder . So you might be thinking, \"How does the IG know which profile to add your example to?\" The answer is that the name of the related FHIR StructureDefinition for the profile is specified within the FHIR example itself: The IG Publisher will match the canonical URL specified in the example with that specified in the IG. Note that the value of the profile parameter must match the canonical URL of the profile where the StructureDefinition is located in order for the example to appear.","title":"Add FHIR Examples to your IG"},{"location":"cimpl6Tutorial_helloWorld/","text":"CIMPL 'Hello World' Tutorial Preface CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a specially-designed language for defining clinical information models. It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles, extensions and implementation guides (IG). Because it is a language , written in text statements, CIMPL encourages distributed, team-based development using conventional source-code control tools such as Github. CIMPL provides tooling that enables you to define a model once, and publish that model to multiple versions of FHIR. Purpose of this Document In the tradition of \"Hello, World\" examples, this tutorial the the bare minimum to get you started using CIMPL. Upon completion of this tutorial, you will be able to try the CIMPL In-Depth Tutorial and get started creating a FHIR Implementation Guide (IG). Intended Audience The CIMPL Hello World Tutorial is targeted to software developers or people comfortable with programming languages. Familiarity with FHIR is helpful as the tutorial references FHIR artifacts (such as Resources, Elements, etc.) Prerequisite This guide assumes you have: Installed the latest version of the SHR-CLI software as documented in CIMPL SetUp and Installation (preferably installed in the ~/cimpl/shr-cli directory) A text editor (preferably VSCode with the vs-code-language-cimpl extension, but not required) Note: This tutorial is written assuming a MacOS environment. While the contents of CIMPL authoring are identical regardless of platform, the command lines run in a command line terminal will differ in file path specifications. Namely, for a Windows command line terminal, replace all the path references of forward-slash / to back-slash \\ . Table of Contents CIMPL 'Hello World' Tutorial Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Tutorial Pre-configuration Tutorial Steps - Hello World! 1) Define the CIMPL Model 2) Define a Mapping to FHIR 3) Create the Home Page of your IG 4) Create a Configuration File 5) Run SHR-CLI 6) Generate the \"Hello, World\" Implementation Guide Tutorial Pre-configuration This tutorial is focused on how to create a model that will be used as input to create an FHIR Implementation Guide. Supporting configuration and core data type files have been defined for you. The following directory structure is assumed for your configuration: Directory: cimpl |_ shr-cli |_ hello-world The shr-cli directory should already exist as a result of installing the SHR-CLI tool. To create hello-world directory, use File Explorer on Windows, or open your favorite command-line tool and enter the following: cd ~/cimpl mkdir hello-world Tutorial Steps - Hello World! 1) Define the CIMPL Model Now, create a file called HelloWorld.txt in the ~/cimpl/hello-world folder and add the following data definitions: Grammar: DataElement 6.0 Namespace: hello Description: \"A simple example of CIMPL.\" Entry: HelloWorld Description: \"A silly profile.\" Property: SayHello 0..1 Element: SayHello Description: \"An extension indicating whether to say hello\" Value: boolean This is a CIMPL class file. 2) Define a Mapping to FHIR Next, create a file in the same directory called HelloWorld_map.txt . This file is even simpler: Grammar: Map 5.1 Namespace: hello Target: FHIR_STU_3 HelloWorld maps to Basic: Basic is a \"blank slate\" FHIR resource. We didn\u2019t map the SayHello data element to an existing element inside this resource, so it will automatically appear as an extension in the profile on Basic. 3) Create the Home Page of your IG Next, we need some simple HTML for the Implementation Guide pages, so create an exampleIndexContent.html file with the following content: HELLO HELLO HELLO 4) Create a Configuration File To point the SHR-CLI tool at the right files, and assign the right names to things, we need a configuration file. Create an ig-hello-world-config.json file and copy and paste this content: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"npmName\": \"hello-world\", \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } } 5) Run SHR-CLI Now, go back to your SHR-CLI installation and run the hello world: cd ~/cimpl/shr-cli node . -c ig-hello-world-config.json ../hello-world When the program runs, it will output a warning message alerting you that mapping to Basic usually isn\u2019t the best choice, but in this case, it is intentional. After the program runs, the generated profile (a FHIR StructureDefinition ) will be found in ~/cimpl/shr-cli/out/fhir/profiles/ . A StructureDefinition can be verbose, and this one clocks in at several hundred lines. 6) Generate the \"Hello, World\" Implementation Guide Note: If your organization uses a proxy server, you may have to run the IG publishing process from outside your organization's firewall. A friendlier view of the profile is created when we create an implementation guide (IG). To do this, we use the existing FHIR implementation guide (IG) publisher . To generate the IG, run: cd ~/cimpl/shr-cli yarn run ig:publish The generated profile page will be located at ~/cimpl/shr-cli/out/fhir/guide/output/StructureDefinition-hello-HelloWorld.html . Open this page in your favorite web browser. You should see a FHIR profile that looks like a traditional FHIR Implementation Guide . For a more comprehensive understanding of the CIMPL grammar and how to use it for your project, continue to the Tutorial .","title":"CIMPL 'Hello World' Tutorial"},{"location":"cimpl6Tutorial_helloWorld/#cimpl-hello-world-tutorial","text":"","title":"CIMPL 'Hello World' Tutorial"},{"location":"cimpl6Tutorial_helloWorld/#preface","text":"CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a specially-designed language for defining clinical information models. It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles, extensions and implementation guides (IG). Because it is a language , written in text statements, CIMPL encourages distributed, team-based development using conventional source-code control tools such as Github. CIMPL provides tooling that enables you to define a model once, and publish that model to multiple versions of FHIR.","title":"Preface"},{"location":"cimpl6Tutorial_helloWorld/#purpose-of-this-document","text":"In the tradition of \"Hello, World\" examples, this tutorial the the bare minimum to get you started using CIMPL. Upon completion of this tutorial, you will be able to try the CIMPL In-Depth Tutorial and get started creating a FHIR Implementation Guide (IG).","title":"Purpose of this Document"},{"location":"cimpl6Tutorial_helloWorld/#intended-audience","text":"The CIMPL Hello World Tutorial is targeted to software developers or people comfortable with programming languages. Familiarity with FHIR is helpful as the tutorial references FHIR artifacts (such as Resources, Elements, etc.)","title":"Intended Audience"},{"location":"cimpl6Tutorial_helloWorld/#prerequisite","text":"This guide assumes you have: Installed the latest version of the SHR-CLI software as documented in CIMPL SetUp and Installation (preferably installed in the ~/cimpl/shr-cli directory) A text editor (preferably VSCode with the vs-code-language-cimpl extension, but not required) Note: This tutorial is written assuming a MacOS environment. While the contents of CIMPL authoring are identical regardless of platform, the command lines run in a command line terminal will differ in file path specifications. Namely, for a Windows command line terminal, replace all the path references of forward-slash / to back-slash \\ .","title":"Prerequisite"},{"location":"cimpl6Tutorial_helloWorld/#table-of-contents","text":"CIMPL 'Hello World' Tutorial Preface Purpose of this Document Intended Audience Prerequisite Table of Contents Tutorial Pre-configuration Tutorial Steps - Hello World! 1) Define the CIMPL Model 2) Define a Mapping to FHIR 3) Create the Home Page of your IG 4) Create a Configuration File 5) Run SHR-CLI 6) Generate the \"Hello, World\" Implementation Guide","title":"Table of Contents"},{"location":"cimpl6Tutorial_helloWorld/#tutorial-pre-configuration","text":"This tutorial is focused on how to create a model that will be used as input to create an FHIR Implementation Guide. Supporting configuration and core data type files have been defined for you. The following directory structure is assumed for your configuration: Directory: cimpl |_ shr-cli |_ hello-world The shr-cli directory should already exist as a result of installing the SHR-CLI tool. To create hello-world directory, use File Explorer on Windows, or open your favorite command-line tool and enter the following: cd ~/cimpl mkdir hello-world","title":"Tutorial Pre-configuration"},{"location":"cimpl6Tutorial_helloWorld/#tutorial-steps-hello-world","text":"","title":"Tutorial Steps - Hello World!"},{"location":"cimpl6Tutorial_helloWorld/#1-define-the-cimpl-model","text":"Now, create a file called HelloWorld.txt in the ~/cimpl/hello-world folder and add the following data definitions: Grammar: DataElement 6.0 Namespace: hello Description: \"A simple example of CIMPL.\" Entry: HelloWorld Description: \"A silly profile.\" Property: SayHello 0..1 Element: SayHello Description: \"An extension indicating whether to say hello\" Value: boolean This is a CIMPL class file.","title":"1) Define the CIMPL Model"},{"location":"cimpl6Tutorial_helloWorld/#2-define-a-mapping-to-fhir","text":"Next, create a file in the same directory called HelloWorld_map.txt . This file is even simpler: Grammar: Map 5.1 Namespace: hello Target: FHIR_STU_3 HelloWorld maps to Basic: Basic is a \"blank slate\" FHIR resource. We didn\u2019t map the SayHello data element to an existing element inside this resource, so it will automatically appear as an extension in the profile on Basic.","title":"2) Define a Mapping to FHIR"},{"location":"cimpl6Tutorial_helloWorld/#3-create-the-home-page-of-your-ig","text":"Next, we need some simple HTML for the Implementation Guide pages, so create an exampleIndexContent.html file with the following content: HELLO HELLO HELLO","title":"3) Create the Home Page of your IG"},{"location":"cimpl6Tutorial_helloWorld/#4-create-a-configuration-file","text":"To point the SHR-CLI tool at the right files, and assign the right names to things, we need a configuration file. Create an ig-hello-world-config.json file and copy and paste this content: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"npmName\": \"hello-world\", \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } }","title":"4) Create a Configuration File"},{"location":"cimpl6Tutorial_helloWorld/#5-run-shr-cli","text":"Now, go back to your SHR-CLI installation and run the hello world: cd ~/cimpl/shr-cli node . -c ig-hello-world-config.json ../hello-world When the program runs, it will output a warning message alerting you that mapping to Basic usually isn\u2019t the best choice, but in this case, it is intentional. After the program runs, the generated profile (a FHIR StructureDefinition ) will be found in ~/cimpl/shr-cli/out/fhir/profiles/ . A StructureDefinition can be verbose, and this one clocks in at several hundred lines.","title":"5) Run SHR-CLI"},{"location":"cimpl6Tutorial_helloWorld/#6-generate-the-hello-world-implementation-guide","text":"Note: If your organization uses a proxy server, you may have to run the IG publishing process from outside your organization's firewall. A friendlier view of the profile is created when we create an implementation guide (IG). To do this, we use the existing FHIR implementation guide (IG) publisher . To generate the IG, run: cd ~/cimpl/shr-cli yarn run ig:publish The generated profile page will be located at ~/cimpl/shr-cli/out/fhir/guide/output/StructureDefinition-hello-HelloWorld.html . Open this page in your favorite web browser. You should see a FHIR profile that looks like a traditional FHIR Implementation Guide . For a more comprehensive understanding of the CIMPL grammar and how to use it for your project, continue to the Tutorial .","title":"6) Generate the \"Hello, World\" Implementation Guide"},{"location":"cimplInstall/","text":"CIMPL Setup and Installation CIMPL (and, by extension, the SHR-CLI tool) is a text-based tool that requires its users to understand and use your operating system's command line . If you are uncomfortable with using the command line, try this short introduction . Table of Contents CIMPL Setup and Installation Table of Contents Windows Installation Instructions Windows Proxy Setup Install Node.js for Windows Install Yarn for Windows Yarn Proxy Setup Install Visual Studio Code for Windows VSCode Proxy Setup Install the CIMPL Extension for VSCode Install SHR-CLI for Windows Install Java Runtime for Windows Install Jekyll for Windows macOS Installation Instructions Terminal Proxy Setup for macOS Install Node.js for macOS Install Homebrew for macOS Install Yarn for macOS Install Visual Studio Code for macOS VSCode Proxy Configuration Install CIMPL Extension for VSCode Install SHR-CLI for macOS Install Java Runtime Environment \u2666for macOS Install Jekyll for macOS Appendix: Installing Git for Team Projects Install Git for Windows Git Proxy Setup for Windows Install Git for macOS Git Proxy Setup for macOS Windows Installation Instructions Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js and Yarn , and optionally, Git and Visual Studio Code For a successful installation, it is critical that you: Read the instructions thoroughly . Follow instructions in order , without skipping around. Understand your organization's proxy server configuration, if running from inside a firewall Pay attention to placeholders in the instructions (such as your proxy server address) that you may need to replace. Allow enough time (30-60 minutes) Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations may fail or refuse to install. Windows Proxy Setup Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip to the next step . If your organization uses a proxy server, you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: setx HTTP_PROXY http://your.proxy.org:80 setx HTTPS_PROXY https://your.proxy.org:80 setx http_proxy http://your.proxy.org:80 setx https_proxy https://your.proxy.org:80 setx proxy http://your.proxy.org:80 setx JAVA_OPTS \"-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80\" Open a windows command prompt Copy and paste the modified code block (with your organization's proxy server) into the command prompt; hit enter to execute. Close and re-open your command prompt to make sure those settings take effect Some of the following installation steps will also include specific setups for running the CIMPL tooling and HL7 FHIR IG Publisher from behind a proxy server. Install Node.js for Windows The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Install Yarn for Windows Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. It is recommended that CIMPL developers download and install the stable version of Yarn . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Yarn Proxy Setup If your organization uses a proxy server, replace http://your.proxy.org with your organization's proxy server in the following code block: yarn config set proxy http://your.proxy.org yarn config set strict-ssl false ...then run the modified code block (with your organization's proxy server) in the command prompt. Close and re-open your command prompt to make sure those settings take effect. Install Visual Studio Code for Windows Visual Studio Code (also referred to as 'VSCode' or 'Code') is a smart text editor. VSCode is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . You can use the default options in the installer file, but some developers find it helpful to check these checkboxes during the installation wizard: Add \"Open with Code\" action to Windows Explorer file context menu Add \"Open with Code\" action to Windows Explorer directory context menu Register Code as an editor for supported file types VSCode Proxy Setup If your organization uses a proxy server, you'll need to configure VSCode settings. If your organization does not use a proxy server, you can skip ahead to the next step . To ensure that Visual Studio Code can download extensions from the internet, follow this steps: Open Visual Studio Code Open the User Settings menu (File -> Preferences -> Settings) Search the settings for \"proxy\", or open Application -> Proxy. Insert your proxy in the Proxy text box (in the form http://your.proxy.org). Make sure \"Proxy Strict SSL\" is checked. Save, exit, and re-open Visual Studio Code to make sure the settings take effect Install the CIMPL Extension for VSCode CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: Open the extensions menu (Using View -> Extensions) or the icon on the bottom of the left toolbar that looks like boxes) In the search box, type \"cimpl\" Look for the vscode-language-cimpl extension and click the Install button When the installation has completed, click the Reload button Install SHR-CLI for Windows With the supporting software installed, you can move on to installing the Standard Health Record Command Line Interface (SHR-CLI) tool. Create the directory where you want to install CLI, for example, /Documents/cimpl (we'll refer to this directory as ~/cimpl) Download the SHR-CLI zip file Unzip the file into the directory you created. This will create a new folder with a name like shr-cli-X.X.X where X.X.X is the version number of SHR-CLI. Open a command window, navigate into the directory where the new files have been unzipped, using the change directory (cd) command. Run the command: yarn Note : Each time you download a new version of SHR-CLI, you must re-run yarn command. For git users, there is an alternate approach. After installing git , open 'Git Bash' (not the windows command prompt) and enter the following commands, which grab the latest version of the SHR-CLI tool and places it in the ~/cimpl/shr-cli directory, and installs it using Yarn: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git cd shr-cli yarn Install Java Runtime for Windows The FHIR implementation guide (IG) publisher is owned and operated by the HL7 FHIR team. The IG publisher is primarily written in java and requires JRE version 8. To install JRE: Go to the Java SE Runtime Environment 8 Downloads page Click the 'Accept License Agreement' radio button Download the most recent JRE 8 installer for your operating system Note: You may need to create an Oracle account to download JRE 8 Install Jekyll for Windows The FHIR IG Publisher also requires Jekyll be installed in order to run properly. Jekyll is a Ruby library (\"gem\") that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. Use the Windows Installation Instructions for Jekyll : Download RubyInstaller and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) After clicking 'Finish', a command prompt should open asking about an MSYS2 base installation . Press Enter to continue. When that installation is complete, open a new command prompt from the Windows start menu and type: gem install jekyll bundler Check to see that Jekyll is installed using: jekyll -v You should see the following: jekyll X.X.X ...where X.X.X is the latest Jekyll version number. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example. For detailed information on using SHR-CLI and the IG Publisher, see the CIMPL Tooling Reference . macOS Installation Instructions Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js and Yarn , and optionally, Git and Visual Studio Code . For a successful installation, it is critical that you: Read the instructions thoroughly . Follow instructions in order , without skipping around. Understand your organization's proxy server configuration, if running from inside a firewall Pay attention to placeholders in the instructions (such as your proxy server address) that you may need to replace. Allow enough time (30-60 minutes) Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. Terminal Proxy Setup for macOS Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to the next step . If your organization uses a proxy server and you use the standard Terminal app for macOS , you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: echo \"export http_proxy=http://your.proxy.org:80 export https_proxy=http://your.proxy.org:80 export HTTP_PROXY=http://your.proxy.org:80 export HTTPS_PROXY=http://your.proxy.org:80 export JAVA_OPTS='-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 \\ -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 \\ -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80'\" >> ~/.bash_profile;\\ source ~/.bash_profile Open Terminal Copy and paste the modified code block (with your organization's proxy server) into the terminal Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server. Install Node.js for macOS The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Install Homebrew for macOS Homebrew is a package manager for macOS which will allow us to install several other applications. To install homebrew, enter the following in a terminal window: /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Note: During the installation, you may be asked if you want to install 'OSX Developer Tools'. If this occurs, answer 'yes'. Install Yarn for macOS Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. With homebrew installed, yarn can be installed by entering the following in a terminal window: brew install yarn Install Visual Studio Code for macOS Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . VSCode Proxy Configuration If your organization uses a proxy server, you'll need to configure VSCode settings. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions from the internet, follow this steps: Open Visual Studio Code Open the User Settings menu (File -> Preferences -> Settings) Search the settings for \"proxy\", or open Application -> Proxy. Insert your proxy in the Proxy text box (in the form http://your.proxy.org). Make sure \"Proxy Strict SSL\" is checked. Save, exit, and re-open Visual Studio Code to make sure the settings take effect Install CIMPL Extension for VSCode CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: Open the extensions menu (Using View -> Extensions in the menu bar, Command + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) By default, the extensions are filtered by @sort:installs . Replace this with cimpl Look for the vscode-language-cimpl extension and click the Install button When the installation has completed, click the Reload button Install SHR-CLI for macOS With the supporting software installed, you can move on to installing the Standard Health Record Command Line Interface (SHR-CLI) tool. Open a terminal window and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the SHR-CLI tool and places it in the ~/cimpl/shr-cli directory. To set up the SHR-CLI tool, run: cd ~/cimpl/shr-cli yarn Note: If you encounter error unable to get local issuer certificate , run the following command in terminal: yarn config set strict-ssl false ...and then re-run yarn using: yarn Note : Each time you download a new version of SHR-CLI, you must re-run yarn command. Install Java Runtime Environment \u2666for macOS The FHIR implementation guide (IG) publisher is owned and operated by the HL7 FHIR team. The IG publisher is primarily written in java and requires JRE version 8. To install JRE: Go to the Java SE Runtime Environment 8 Downloads page Click the 'Accept License Agreement' radio button Download the most recent JRE 8 installer for your operating system Install Jekyll for macOS The FHIR IG Publisher also requires Jekyll be installed in order to run properly. Jekyll is a Ruby library (\"gem\") that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. If you don't know if the xcode developer tools are installed, run the following command: xcode-select --install Install the latest version of Ruby: brew install ruby When ruby is finished installing, run the following: gem install bundler jekyll NOTE: If your system requires sudo to gem install bundler and jekyll, use the following command to preserve environment variables when using sudo : sudo -E gem install bundler jekyll That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example. For detailed information on using SHR-CLI and the IG Publisher, see the CIMPL Tooling Reference . Appendix: Installing Git for Team Projects Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. If you're new to Git, github has a great introduction where you can learn by reading or playing with some helpful visualizations: http://try.github.io/ Git is not a strict dependency (i.e., you can run the SHR-CLI tool without git), but for team projects, it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . Github Desktop is a client interface that simplifies working with Github. It is available for both Windows and macOS. Install Git for Windows Download the installation package for Git for Windows and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete). This will install a few applications, but the most useful for CIMPL development will be the 'Git Bash' application. This opens a command-line prompt which emulates the use of git on a Unix-based system (e.g., Linux or macOS). Most CIMPL developers use Unix-based systems, so you may want to use 'Git Bash' for working with CIMPL instead of the standard Windows command line. There are many tutorials online about the use of git. Users that are new to Unix or bash may find this video introduction to Git Bash helpful. You should also set up git so that any changes you make to the codebase are properly identified (replacing the name and email placeholders with your name and email): git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\" Git Proxy Setup for Windows If your organization uses a proxy server, you will need to add some proxy settings to git: Replace your.proxy.org:80 with your actual proxy server and port in the following code block: git config --global http.proxy http://your.proxy.org:80 git config --global url.\"https://\".insteadOf git:// Open a windows command prompt Copy and paste that code block (with your organization's proxy server) into the command prompt Close and re-open your command prompt to make sure those settings take effect. Install Git for macOS With homebrew installed, git can be installed by entering the following in a terminal window: brew install git You should also set up git so that any changes you make to the codebase are properly identified. Replace the name and email placeholders with your name and email : git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\" Git Proxy Setup for macOS If your organization uses a proxy server, you will need to add some proxy settings to git: Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open Terminal Copy and paste that code block (with your organization's proxy server) into the terminal Close and re-open your command prompt to make sure those settings take effect.","title":"CIMPL Setup and Installation"},{"location":"cimplInstall/#cimpl-setup-and-installation","text":"CIMPL (and, by extension, the SHR-CLI tool) is a text-based tool that requires its users to understand and use your operating system's command line . If you are uncomfortable with using the command line, try this short introduction .","title":"CIMPL Setup and Installation"},{"location":"cimplInstall/#table-of-contents","text":"CIMPL Setup and Installation Table of Contents Windows Installation Instructions Windows Proxy Setup Install Node.js for Windows Install Yarn for Windows Yarn Proxy Setup Install Visual Studio Code for Windows VSCode Proxy Setup Install the CIMPL Extension for VSCode Install SHR-CLI for Windows Install Java Runtime for Windows Install Jekyll for Windows macOS Installation Instructions Terminal Proxy Setup for macOS Install Node.js for macOS Install Homebrew for macOS Install Yarn for macOS Install Visual Studio Code for macOS VSCode Proxy Configuration Install CIMPL Extension for VSCode Install SHR-CLI for macOS Install Java Runtime Environment \u2666for macOS Install Jekyll for macOS Appendix: Installing Git for Team Projects Install Git for Windows Git Proxy Setup for Windows Install Git for macOS Git Proxy Setup for macOS","title":"Table of Contents"},{"location":"cimplInstall/#windows-installation-instructions","text":"Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js and Yarn , and optionally, Git and Visual Studio Code For a successful installation, it is critical that you: Read the instructions thoroughly . Follow instructions in order , without skipping around. Understand your organization's proxy server configuration, if running from inside a firewall Pay attention to placeholders in the instructions (such as your proxy server address) that you may need to replace. Allow enough time (30-60 minutes) Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations may fail or refuse to install.","title":"Windows Installation Instructions"},{"location":"cimplInstall/#windows-proxy-setup","text":"Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip to the next step . If your organization uses a proxy server, you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: setx HTTP_PROXY http://your.proxy.org:80 setx HTTPS_PROXY https://your.proxy.org:80 setx http_proxy http://your.proxy.org:80 setx https_proxy https://your.proxy.org:80 setx proxy http://your.proxy.org:80 setx JAVA_OPTS \"-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80\" Open a windows command prompt Copy and paste the modified code block (with your organization's proxy server) into the command prompt; hit enter to execute. Close and re-open your command prompt to make sure those settings take effect Some of the following installation steps will also include specific setups for running the CIMPL tooling and HL7 FHIR IG Publisher from behind a proxy server.","title":"Windows Proxy Setup"},{"location":"cimplInstall/#install-nodejs-for-windows","text":"The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Install Node.js for Windows"},{"location":"cimplInstall/#install-yarn-for-windows","text":"Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. It is recommended that CIMPL developers download and install the stable version of Yarn . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Install Yarn for Windows"},{"location":"cimplInstall/#yarn-proxy-setup","text":"If your organization uses a proxy server, replace http://your.proxy.org with your organization's proxy server in the following code block: yarn config set proxy http://your.proxy.org yarn config set strict-ssl false ...then run the modified code block (with your organization's proxy server) in the command prompt. Close and re-open your command prompt to make sure those settings take effect.","title":"Yarn Proxy Setup"},{"location":"cimplInstall/#install-visual-studio-code-for-windows","text":"Visual Studio Code (also referred to as 'VSCode' or 'Code') is a smart text editor. VSCode is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . You can use the default options in the installer file, but some developers find it helpful to check these checkboxes during the installation wizard: Add \"Open with Code\" action to Windows Explorer file context menu Add \"Open with Code\" action to Windows Explorer directory context menu Register Code as an editor for supported file types","title":"Install Visual Studio Code for Windows"},{"location":"cimplInstall/#vscode-proxy-setup","text":"If your organization uses a proxy server, you'll need to configure VSCode settings. If your organization does not use a proxy server, you can skip ahead to the next step . To ensure that Visual Studio Code can download extensions from the internet, follow this steps: Open Visual Studio Code Open the User Settings menu (File -> Preferences -> Settings) Search the settings for \"proxy\", or open Application -> Proxy. Insert your proxy in the Proxy text box (in the form http://your.proxy.org). Make sure \"Proxy Strict SSL\" is checked. Save, exit, and re-open Visual Studio Code to make sure the settings take effect","title":"VSCode Proxy Setup"},{"location":"cimplInstall/#install-the-cimpl-extension-for-vscode","text":"CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: Open the extensions menu (Using View -> Extensions) or the icon on the bottom of the left toolbar that looks like boxes) In the search box, type \"cimpl\" Look for the vscode-language-cimpl extension and click the Install button When the installation has completed, click the Reload button","title":"Install the CIMPL Extension for VSCode"},{"location":"cimplInstall/#install-shr-cli-for-windows","text":"With the supporting software installed, you can move on to installing the Standard Health Record Command Line Interface (SHR-CLI) tool. Create the directory where you want to install CLI, for example, /Documents/cimpl (we'll refer to this directory as ~/cimpl) Download the SHR-CLI zip file Unzip the file into the directory you created. This will create a new folder with a name like shr-cli-X.X.X where X.X.X is the version number of SHR-CLI. Open a command window, navigate into the directory where the new files have been unzipped, using the change directory (cd) command. Run the command: yarn Note : Each time you download a new version of SHR-CLI, you must re-run yarn command. For git users, there is an alternate approach. After installing git , open 'Git Bash' (not the windows command prompt) and enter the following commands, which grab the latest version of the SHR-CLI tool and places it in the ~/cimpl/shr-cli directory, and installs it using Yarn: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git cd shr-cli yarn","title":"Install SHR-CLI for Windows"},{"location":"cimplInstall/#install-java-runtime-for-windows","text":"The FHIR implementation guide (IG) publisher is owned and operated by the HL7 FHIR team. The IG publisher is primarily written in java and requires JRE version 8. To install JRE: Go to the Java SE Runtime Environment 8 Downloads page Click the 'Accept License Agreement' radio button Download the most recent JRE 8 installer for your operating system Note: You may need to create an Oracle account to download JRE 8","title":"Install Java Runtime for Windows"},{"location":"cimplInstall/#install-jekyll-for-windows","text":"The FHIR IG Publisher also requires Jekyll be installed in order to run properly. Jekyll is a Ruby library (\"gem\") that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. Use the Windows Installation Instructions for Jekyll : Download RubyInstaller and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) After clicking 'Finish', a command prompt should open asking about an MSYS2 base installation . Press Enter to continue. When that installation is complete, open a new command prompt from the Windows start menu and type: gem install jekyll bundler Check to see that Jekyll is installed using: jekyll -v You should see the following: jekyll X.X.X ...where X.X.X is the latest Jekyll version number. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example. For detailed information on using SHR-CLI and the IG Publisher, see the CIMPL Tooling Reference .","title":"Install Jekyll for Windows"},{"location":"cimplInstall/#macos-installation-instructions","text":"Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js and Yarn , and optionally, Git and Visual Studio Code . For a successful installation, it is critical that you: Read the instructions thoroughly . Follow instructions in order , without skipping around. Understand your organization's proxy server configuration, if running from inside a firewall Pay attention to placeholders in the instructions (such as your proxy server address) that you may need to replace. Allow enough time (30-60 minutes) Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install.","title":"macOS Installation Instructions"},{"location":"cimplInstall/#terminal-proxy-setup-for-macos","text":"Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to the next step . If your organization uses a proxy server and you use the standard Terminal app for macOS , you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: echo \"export http_proxy=http://your.proxy.org:80 export https_proxy=http://your.proxy.org:80 export HTTP_PROXY=http://your.proxy.org:80 export HTTPS_PROXY=http://your.proxy.org:80 export JAVA_OPTS='-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 \\ -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 \\ -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80'\" >> ~/.bash_profile;\\ source ~/.bash_profile Open Terminal Copy and paste the modified code block (with your organization's proxy server) into the terminal Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server.","title":"Terminal Proxy Setup for macOS"},{"location":"cimplInstall/#install-nodejs-for-macos","text":"The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Install Node.js for macOS"},{"location":"cimplInstall/#install-homebrew-for-macos","text":"Homebrew is a package manager for macOS which will allow us to install several other applications. To install homebrew, enter the following in a terminal window: /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Note: During the installation, you may be asked if you want to install 'OSX Developer Tools'. If this occurs, answer 'yes'.","title":"Install Homebrew for macOS"},{"location":"cimplInstall/#install-yarn-for-macos","text":"Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. With homebrew installed, yarn can be installed by entering the following in a terminal window: brew install yarn","title":"Install Yarn for macOS"},{"location":"cimplInstall/#install-visual-studio-code-for-macos","text":"Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage .","title":"Install Visual Studio Code for macOS"},{"location":"cimplInstall/#vscode-proxy-configuration","text":"If your organization uses a proxy server, you'll need to configure VSCode settings. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions from the internet, follow this steps: Open Visual Studio Code Open the User Settings menu (File -> Preferences -> Settings) Search the settings for \"proxy\", or open Application -> Proxy. Insert your proxy in the Proxy text box (in the form http://your.proxy.org). Make sure \"Proxy Strict SSL\" is checked. Save, exit, and re-open Visual Studio Code to make sure the settings take effect","title":"VSCode Proxy Configuration"},{"location":"cimplInstall/#install-cimpl-extension-for-vscode","text":"CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: Open the extensions menu (Using View -> Extensions in the menu bar, Command + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) By default, the extensions are filtered by @sort:installs . Replace this with cimpl Look for the vscode-language-cimpl extension and click the Install button When the installation has completed, click the Reload button","title":"Install CIMPL Extension for VSCode"},{"location":"cimplInstall/#install-shr-cli-for-macos","text":"With the supporting software installed, you can move on to installing the Standard Health Record Command Line Interface (SHR-CLI) tool. Open a terminal window and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the SHR-CLI tool and places it in the ~/cimpl/shr-cli directory. To set up the SHR-CLI tool, run: cd ~/cimpl/shr-cli yarn Note: If you encounter error unable to get local issuer certificate , run the following command in terminal: yarn config set strict-ssl false ...and then re-run yarn using: yarn Note : Each time you download a new version of SHR-CLI, you must re-run yarn command.","title":"Install SHR-CLI for macOS"},{"location":"cimplInstall/#install-java-runtime-environment-for-macos","text":"The FHIR implementation guide (IG) publisher is owned and operated by the HL7 FHIR team. The IG publisher is primarily written in java and requires JRE version 8. To install JRE: Go to the Java SE Runtime Environment 8 Downloads page Click the 'Accept License Agreement' radio button Download the most recent JRE 8 installer for your operating system","title":"Install Java Runtime Environment \u2666for macOS"},{"location":"cimplInstall/#install-jekyll-for-macos","text":"The FHIR IG Publisher also requires Jekyll be installed in order to run properly. Jekyll is a Ruby library (\"gem\") that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. If you don't know if the xcode developer tools are installed, run the following command: xcode-select --install Install the latest version of Ruby: brew install ruby When ruby is finished installing, run the following: gem install bundler jekyll NOTE: If your system requires sudo to gem install bundler and jekyll, use the following command to preserve environment variables when using sudo : sudo -E gem install bundler jekyll That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example. For detailed information on using SHR-CLI and the IG Publisher, see the CIMPL Tooling Reference .","title":"Install Jekyll for macOS"},{"location":"cimplInstall/#appendix-installing-git-for-team-projects","text":"Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. If you're new to Git, github has a great introduction where you can learn by reading or playing with some helpful visualizations: http://try.github.io/ Git is not a strict dependency (i.e., you can run the SHR-CLI tool without git), but for team projects, it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . Github Desktop is a client interface that simplifies working with Github. It is available for both Windows and macOS.","title":"Appendix: Installing Git for Team Projects"},{"location":"cimplInstall/#install-git-for-windows","text":"Download the installation package for Git for Windows and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete). This will install a few applications, but the most useful for CIMPL development will be the 'Git Bash' application. This opens a command-line prompt which emulates the use of git on a Unix-based system (e.g., Linux or macOS). Most CIMPL developers use Unix-based systems, so you may want to use 'Git Bash' for working with CIMPL instead of the standard Windows command line. There are many tutorials online about the use of git. Users that are new to Unix or bash may find this video introduction to Git Bash helpful. You should also set up git so that any changes you make to the codebase are properly identified (replacing the name and email placeholders with your name and email): git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\"","title":"Install Git for Windows"},{"location":"cimplInstall/#git-proxy-setup-for-windows","text":"If your organization uses a proxy server, you will need to add some proxy settings to git: Replace your.proxy.org:80 with your actual proxy server and port in the following code block: git config --global http.proxy http://your.proxy.org:80 git config --global url.\"https://\".insteadOf git:// Open a windows command prompt Copy and paste that code block (with your organization's proxy server) into the command prompt Close and re-open your command prompt to make sure those settings take effect.","title":"Git Proxy Setup for Windows"},{"location":"cimplInstall/#install-git-for-macos","text":"With homebrew installed, git can be installed by entering the following in a terminal window: brew install git You should also set up git so that any changes you make to the codebase are properly identified. Replace the name and email placeholders with your name and email : git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\"","title":"Install Git for macOS"},{"location":"cimplInstall/#git-proxy-setup-for-macos","text":"If your organization uses a proxy server, you will need to add some proxy settings to git: Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open Terminal Copy and paste that code block (with your organization's proxy server) into the terminal Close and re-open your command prompt to make sure those settings take effect.","title":"Git Proxy Setup for macOS"},{"location":"cimplReleaseNotes/","text":"CIMPL Release Notes Note: \"This documentation is in the process of being further expanded and is an actively updating document.\" CIMPL Release Notes CIMPL 6.0 CIMPL 5.0 CIMPL 6.0 Release Date : June 2019 CIMPL 6.0 contains a number of significant changes to both syntax and its base classes which support translation to FHIR. CIMPL 5.0 Release Date: 2017","title":"CIMPL Release Notes"},{"location":"cimplReleaseNotes/#cimpl-release-notes","text":"Note: \"This documentation is in the process of being further expanded and is an actively updating document.\" CIMPL Release Notes CIMPL 6.0 CIMPL 5.0","title":"CIMPL Release Notes"},{"location":"cimplReleaseNotes/#cimpl-60","text":"Release Date : June 2019 CIMPL 6.0 contains a number of significant changes to both syntax and its base classes which support translation to FHIR.","title":"CIMPL 6.0"},{"location":"cimplReleaseNotes/#cimpl-50","text":"Release Date: 2017","title":"CIMPL 5.0"}]}