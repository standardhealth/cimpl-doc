{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CIMPL Project CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and compact, while coming with tools to produce CIMCORE, the Standard Health Record (SHR) computable representation, and FHIR profiles. Layout Installation and Setup - Installing and configuring the CIMPL development environment. CIMPL User Guide - A guide on installing, configuring, and authoring within the CIMPL development environment. CIMPL Tutorials CIMPL HelloWorld Tutorial - a very simple tutorial which creates a FHIR implemenation guide (IG). CIMPL Detailed Tutorial - Walkthrough example of how to author a detailed clinical model using CIMPL 6.0 syntax. CIMPL Reference - The current version of CIMPL. All new modeling applications should be using this version.","title":"Home"},{"location":"#cimpl-project","text":"CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and compact, while coming with tools to produce CIMCORE, the Standard Health Record (SHR) computable representation, and FHIR profiles.","title":"CIMPL Project"},{"location":"#layout","text":"Installation and Setup - Installing and configuring the CIMPL development environment. CIMPL User Guide - A guide on installing, configuring, and authoring within the CIMPL development environment. CIMPL Tutorials CIMPL HelloWorld Tutorial - a very simple tutorial which creates a FHIR implemenation guide (IG). CIMPL Detailed Tutorial - Walkthrough example of how to author a detailed clinical model using CIMPL 6.0 syntax. CIMPL Reference - The current version of CIMPL. All new modeling applications should be using this version.","title":"Layout"},{"location":"about/","text":"About CIMPL CIMPL was created by the MITRE Corporation . CIMPL is open source and for public use.","title":"About CIMPL"},{"location":"about/#about-cimpl","text":"CIMPL was created by the MITRE Corporation . CIMPL is open source and for public use.","title":"About CIMPL"},{"location":"cimpl5Reference/","text":"CIMPL 5.0 Reference Documentation Note: this documentation is in the process of being further expanded and is an actively updating document. This is a comprehensive guide to CIMPL syntax. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial . Table of Reference 1. General Overview * 1.1 Whitespace * 1.2 Naming Conventions * 1.3 Ordinality * 1.4 Naming Collisions * 1.5 Versioning * 1.6 Comments 2. File Headers * 2.1 Sample File Header * 2.2 Grammar * 2.3 Namespace Declaration * 2.4 File Description * 2.5 Uses * 2.6 Url Shorthands * 2.7 Codesystems 3. Data Element File * 3.1 Sample Data Element File * 3.2 Element Name Declaration * 3.3 Concept Code * 3.4 Inheritance * 3.5 Description * 3.6 Fields * 3.6.1 Value * 3.6.2 Primitives * 3.6.3 Field * 3.6.4 Inherited Field * 3.6.5 References * 3.7 Field Constraints * 3.7.1 No Constraint * 3.7.2 Cardinality * 3.7.3 Fixed Value * 3.7.4 Type * 3.7.5 Value Set * 3.7.6 Includes Code * 3.7.7 Includes Type 4. Map File * 4.1 Sample Map File * 4.2 Element Mapping * 4.3 Field Mapping * 4.4 Fix * 4.5 Constrain * 4.6 Slicing * 4.6.1 Declaring a Discriminator * 4.6.2 Moving the Slice Location * 4.6.3 Slice Strategies 5. Value Set File * 5.1 Sample Value Set File * 5.2 Value Set Declaration * 5.3 Value Set Description * 5.4 Code-Value Declaration 6. FHIR Examples File 7. Future Architectural Considerations General Overview CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and compact, while coming with tools to produce CIMCORE (the SHR computable representation) and FHIR profiles. Whitespace Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 5.0 Namespace: shr.core ...is equivalent to this: Grammar: DataElement 5.0 Namespace: shr.core Naming Conventions File names Data Element files: namespace.txt Value Set files: namespace_vs.txt Mapping files: namespace_map.txt Note: any periods in the namespace should be replaced by underscores Namespaces A namespace conventionally is denominated by the authoring organization and the broad category of elements the namespace defines, delineated by a period. For example: Namespace: shr.oncology Note: The organization name is recommended but not required (e.g., Namespace: oncology is also allowed). Elements Elements are conventionally defined in PascalCase . For example: Element: GeologicalLocation Note: Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter. Value Sets Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: It is required that an Value Set name begins with an uppercase letter. Code Sets Within a custom value set, the individual codes are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or other radiation source\" #swimming_pool \"Swimming Pool\" Ordinality CIMPL does not enforce or require ordinality in any of its definitions, i.e. an element defined at the bottom of the file can be used as field on an element defined at the top. There is, however, a requirement for a file's header information to be at the top of the file, before any definitions. See: File Headers for more information Naming Collisions CIMPL does not support duplicate element names within a namespace. However, you are allowed to reuse an element name across different namespaces. In the case that you come across a collision due to an included namespace in Uses , you have to refer to the element by its Fully Qualified Name . Versioning CIMPL follows the Semantic Versioning convention (MAJOR.MINOR.PATCH). MAJOR: A breaking change. This is reserved for drastic grammar overhauls. Does not support backwards compatibility to other major version releases. MINOR: Feature updates. Allows for backwards compatability within the major version. PATCH: Minor updates and bug fixes. Allows for backwards compatability within the major version. CIMPL is currently on major version 5. For a full changelog, see the Release Notes . Comments CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */ File Headers Each CIMPL file contains header information that describes the file type, its scope and inheritance, and its purpose. It also allows developers to create aliases for urls and code systems. Sample File Header Grammar: DataElement 5.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication Codesystem: LNC = http://loinc.org Grammar The Grammar keyword is used to define the file type and the version of CIMPL used in development/parsing. This is required for all CIMPL files. Keywords Example Grammar Grammar: DataElement 5.0 Grammar Grammar: ValueSet 5.0 Grammar Grammar: Map 5.0 There are three possible options for file type: 1. DataElement 2. ValueSet 3. Mapping The version details the MAJOR and MINOR version the file was written for. The language is backwards compatibile within the MAJOR version number, i.e. DataElement 5.0 files will compile without problems on the 5.9.0 tooling. For more information, see Versioning . Namespace Declaration The Namespace keyword defines the scope of the file and serves as a broad grouping of DataElement , ValueSet and Map files within a domain. Keywords Example Namespace Namespace: shr.environment The namespace can be any number of lowercase period delimited words. Best practice is to follow the naming convention pattern of organization . domain (followed by subdomains if necessary). The tooling will not allow for duplicate namespaces. (Note: While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens) File Description The Description keyword provides the user the ability to define the purpose of the file, within the confines of a project. Keywords Example Description Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" The namespace description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. (NOTE: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.) Uses The Uses keyword provides a list of the namespaces used within the current namespace. Namespace inclusion allows you to use DataElement s and ValueSet s defined in other namespaces. Keywords Example Uses Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication In CIMPL version 5 and below, it is required that you import shr.core and shr.base for the tooling to run. (In the case of name collisions, you will have to indicidate DataElement s by their Fully Qualified Name ). The order of inclusion has no effect. Url Shorthands The Path keyword allows for abbreviations of long urls. Keywords Example Path Path: FHIR = http://hl7.org/fhir/ValueSet This functionality is completely optional, but it is provided to make authoring easier. The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter). Codesystems The Codesystem keyword allows for abbrevations of codesystems. In order to use code systems in a DataElement definition or constraint, it is necessary to first define them in the file header (this is largely due to the complexity of codesystems' direct code references). Keywords Example Codesystem Codesystem: LNC = http://loinc.org You must define each codesystem you use in separate definitions across multiple lines, e.g. Codesystem: LNC = http://loinc.org Codesystem: SCT = http://sct.org The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter) . Data Element File Sample Data Element File Grammar: DataElement 5.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication Codesystem: LNC = http://loinc.org EntryElement: FinancialSituation Concept: MTH#C0516918 Based on: Panel Description: \"Measures of the ability of the subject to obtain and pay for the necessities of life.\" Value: CodeableConcept is MTH#C0516918 0..1 AnnualIncome 0..* IncomeSource PanelCode is LNC#83335-0 Element Name Declaration The Element keyword allows users to define the name of the element and the lines following the Element keyword comprise the definition of that element. Keywords Example Element Element: Observation EntryElement EntryElement: FinancialSituation Abstract Element Abstract Element: Any Note the spacing discrepancy between EntryElement and Abstract Element . This has no semantic meaning but is inherent to the syntax. These keywords are used to define data elements with three different levels of expression in the target output: * EntryElement is used to define elements that will be used directly by the target output, i.e., data will be entered directly into this item by and end user once it has been mapped. For FHIR exports, these items will be created as 'Primary Profiles' * Element is used to define supporting data elements for EntryElement s. These data elements will be present in the target output as, but they are not the top-level items that are exported. For FHIR exports, these items will be created as 'Supporting Profiles'. * Abstract Element is used to define elements that are used only within the CIMPL mapping to create basic objects that will be leveraged by other data elements. They will not be present in the target mapping. Fully Qualified Names In addition to its declared name, all elements also have a unique identifying Fully Qualified Name ( FQN ). The FQN is a combination of the element's namespace and its declared name (through concatention delimited by a period). For example, the element Observation in the namespace shr.finding has the following FQN: shr.finding.Observation Note: While rare and considered bad practice, naming collisions between elements across multiple namespaces is possible. In the case of a naming collision (such as when a namespace Uses multiple namespaces that define an element with the same declared name), you would have to refer to the specific unique FQN instead of the declared name in element, field, and value definitions. Concept Code The Concept keyword is used to define the concept code for the element. These are numerical codes that identify clinical terms, primitive or defined, organized in hierarchies. Keywords Example Concept Concept: MTH#C0516918 Concept codes for the meaning of the defined structure (SNOMED CT and LOINC codes, as an example). While optional, it is recommended you define the concept of an element. To see how it relates to FHIR output, see StructureDefinition.keyword . Inheritance Provides the parent element from which the properties are inherited. This works similar to class inheritance in object orientated programming. Additionally, mappings are inherited alongside properties. Keywords Example Based on Based on: Panel Multiple inheritance is currently removed from CIMPL support. Selective inheritance is achievable through 'zeroing out' inherited properties. See Cardinality Description The textual description of the element. Keywords Example Description Description: \"Measures of the ability of the...\" The element description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. To see how it relates to FHIR output, see StructureDefinition.description . (NOTE: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.) Fields Value Defines what the element is. You are allowed to declare a value to be either a primitive or a DataElement. Keywords Example Value Value: CodeableConcept Value: string Value is an optional special field on an element that correspond more heavily to what the element is . You are also allowed to constrain the value similar to other fields. On the mapping side, you are able to map the value like any other field. Value defaults to a cardinality of 1..1 , but this can be changed, e.g.: Value: 0..1 Quantity Primitives CIMPL allows users to define fields as the following primitive data types: * boolean * integer * string * decimal * uri * base64Binary * instant * date * dateTime * time * code * oid * id * markdown * unsignedInt * positiveInt * xhtml Field Object properties on the element. Keywords Example 0..1 AnnualIncome In most cases, you refer to an element by its name. In the rare case of a naming collision, you must refer to it by its Fully Qualified Name . Inherited Field Object properties on the element inherited from the parent or other elements. Keywords Example PanelCode is LNC#83335-0 Inherited Value Object value on the element inherited from the parent or other elements. Keywords Example Value Value is MTH#C0516918 The Value keyword can be used identically to an Inherited Field . References In order to refer to an element as a class (i.e. a pointer as opposed to an instance), you can encapsulate the element name using ref() . This is helpful for defining complex objects with child elements that are already defined as parts of existing data elements. Keywords Example ref() 1..1 ref(Role) ref() 0..1 PartOf value is type ref(Organization) ref() Value: ref(Finding) ref() Value: 0..* ref(Observation) The ref(...) syntax should only encapsulate the element name. All other fields should be applied normally to the group. ref() can be used to specify that a reference is either the child element of a data element (e.g., 1..1 ref(Role) ) or the Value of an existing child element (e.g., 0..1 PartOf value is type ref(Organization) ). Field Constraints Fields can be constrained to further specify their acceptable values using cardinalities and keywords, e.g.: * is * is type * from * includes No Constraint Fields can exist without any constraints. They can also be constrained to a data type (or set of data types) without further constraining the possible values within that data type. Keywords Example 0..1 GeopoliticalLocation Value: CodeableConcept or Value: unsignedInt or positiveInt Cardinality Cardinality defines the number of instances should exist for a value. The first digit indicates the minimum quantity, and additionally by setting it to 0 or to 1 , has the effect of making a field optional or required. The second digit expresses the upper bound. To express no upper bound, a * can be used in place of a number. When constraining an inherited field, you can only retain the previous cardinality, or constrain it to be narrower. Note: By constraining it to 0..0, you can remove an inherited field from an element. Keywords Example 0..* LanguageUsed 1..2 GovernmentIssuedID Fixed Value The is keyword limits the field to a specifc value (e.g., a code , a specific string , or a boolean value). Keywords Example is ObservationCode is LNC#82810-3 Note: The is keyword locks the code for all instances of the data element. If you only need to lock the code for one particular mapping, do so using the fix keyword in the mapping file. Type The is type keywords limits the data type of a field to a previously defined element. Keywords Example is type Quantity is type DollarAmount Use case: If we have an abstract element, and we are making a more specific version of that element, we also want to make its fields more specific. For instance, if we have a DataElement Person which has a field Pet , and we making a more specific person DogOwner and we want to further specify its pet. In this case, we could constrain Pet is type Dog . Value Set The from keyword limits the value of a field to be from a specific value set, with different levels of requirement. Keywords Example Binding Strength from Substance from SubstanceOfAbuseVS Required must be Priority must be from http://hl7.org/fhir/ValueSet/request-priority Required should be 1..1 Status should be from http://hl7.org/fhir/ValueSet/event-status Preferred could be CodeableConcept could be from http://hl7.org/fhir/ValueSet/medication-as-needed-reason Example if covered Category from http://hl7.org/fhir/ValueSet/goal-category if covered Extensible The binding strengths correspond to FHIR binding strengths and have the same meaning: * Required: To be conformant, the concept in this element SHALL be from the specified value set * Preferred: Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant. * Example: Instances are not expected or even encouraged to draw from the specified value set. The value set merely provides examples of the types of concepts intended to be included. * Extensible: To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated. If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead. Includes Code For fields that are already defined with a data type of code , the includes keyword expands the allowable entries for that field. Keywords Example includes Category includes LNC#54511-1 \"Behavior\" includes ProblemCategory includes #adverse_reaction The first example above expands Category to include 54511-1 from the LOINC codesystem. Additionally, it is given a brief textual description of \"Behavior\" . The second example above expands the allowable codes in ProblemCategory to include #adverse_reaction . Unlike the first example, the value set does not precede the code, because it has defined on ProblemCategory 's parent using a from statement. Additionally, there is no textual description, as that is optional. Includes Type Specifies the quantity of particular types of objects within the value. Keywords Example includes Foo includes 1..1 PhysicalActivityLevel This is useful in further specifying fields that are analagous to lists. In the above example, the field Foo is required to include 1 PhysicalActivityLevel . To add more inclusions, simply add more includes statements on Foo . For example, a blood pressure panel can include any number of tests, but we assume that at least one of those tests will be systolic pressure and another will be diastolic pressure: Element: VitalSign 1..* BloodPressurePanel includes 1..1 SystolicPressure includes 1..1 DiastolicPressure Note: The collective cardinality of all inclusions must fit within the field, i.e. if you are including 3 distinct elements, then the field must have a maximum cardinality greater than 3 (like * ). Map File By default, new elements will appear as FHIR extensions unless the element is mapped to an existing FHIR element. These mapping allow for simpler slicing and fixed values. Sample Map File Grammar: Map 5.0 Namespace: shr.allergy Target: FHIR_STU_3 Condition maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-condition: RelatedEncounter maps to context Informant maps to asserter Subject maps to subject Entry.CreationTime maps to assertedDate Value maps to code Category maps to category ClinicalStatus maps to clinicalStatus Onset maps to onset[x] Abatement maps to abatement[x] BodySiteOrCode[CodeableConcept] maps to bodySite BodySiteOrCode[BodySite] maps to http://hl7.org/fhir/StructureDefinition/body-structure Severity maps to severity Stage maps to stage Stage.Value maps to stage.summary Evidence maps to evidence Element Mapping Maps a CIMPL element to a target element. Keywords Example maps to FinancialSituation maps to DiagnosticResult: FinancialSituation: In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. If no FHIR mapping is defined for an element and it inherits no mappings from its parents, it defaults to a mapping to the Basic resource . In general, this is not recommended because it has no inherent semantic meaning for implementers. To promote interoperability and reuse, CIMPL modelers are encouraged to find target models that already exist and use constraints or extensions to modify them according to project needs. Field Mapping Maps a CIMPL element field to a target field. Keywords Example maps to MaritalStatus maps to maritalStatus maps to Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity maps to MultipleBirth maps to multipleBirth[x].boolean maps to Value.ActiveFlag maps to active maps to AdverseReaction.AllergenIrritant maps to reaction.substance maps to BodySiteOrCode[CodeableConcept] maps to bodySite In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. With FHIR as the target output, the right-hand side of the map statement can point to any field on a FHIR resource, including: * Fields that are at the root of the resource (e.g., maritalStatus ) * Fields that are child elements of root elements on the resource (e.g., reaction.substance ) * Fields that have a choice of data types (e.g., multipleBirth[x].boolean ) * Fields that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity ) Fix Similar to the is keyword, the fix keyword allows for FHIR fields to be locked to a certain value. It is helpful for locking field values in specific mappings (instead of in the DataElement definition, which would be locked for all potential mappings). Keywords Example fix fix status to #completed Note about syntax: The element being fixed on left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any code or primitive value to be fixed. Constrain The constrain keyword allows users to constrain the cardinality of elements in output files. Keywords Example constrain constrain explanation to 0..1 Note about syntax: The element being fixed on the left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any cardinality . Slicing When fields are allowed to repeat on a target model (e.g., have cardinality with an upper bound greater than 1), it is common practice to specify which CIMPL elements are mapped to instances of that repeated field on the target model. This process is called slicing . For example, the FHIR Task resource allows for an arbitrary number of input fields to be added. To ensure that all each of the input fields is uniquely addressable by a parsing engine, those inputs need to be differentiated by a discriminator . See the FHIR documentation for more detail about slicing and discriminators TODO: Add a slicing example to the sample map file Declaring a Discriminator To perform any slicing, a discriminator needs to be declared, using slice on followed by the discriminator. Keywords Example slice on Laterality maps to qualifier (slice on = coding.code) slice on type TODO CIMPL supports the FHIR processing types for discriminators: | Discriminator | Definition | | ------------- | ---------- | | value | The slices have different values in the nominated element| | exists | The slices are differentiated by the presence or absence of the nominated element| | pattern | The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x]| | type |The slices are differentiated by type of the nominated element to a specifed profile| | profile | The slices are differentiated by conformance of the nominated element to a specifed profile| Moving the Slice Location If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Keywords Example slice at Members.Observation maps to related.target (slice at = related; slice on type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occuring at related.target . Instead, the slice at = related ensures that the slicing is occuring at the related element. Slicing Strategies TODO: What does this do and when should it be used? Keywords Example slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) * TODO: What is the syntax? What are the allowable options? * TODO: find or create a less complex example Value Set File The value set files are used to define custom value sets and codes when existing sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient. Sample Value Set File Grammar: ValueSet 5.0 Namespace: shr.base ValueSet: ValueAbsentReasonVS Description: \"Reasons that a value associated with a test or other finding is missing.\" Includes codes from DAR #missing_refused \"Human source was asked but declined to respond to the question, or an applicable question was left unanswered.\" #missing_noexplanation \"The reason the information is not present is not known.\" #missing_nonesuch \"The answer is missing because nothing of a type of thing is known to exists, e.g., the siblings of an only child. Also use this code to represent a 'none of the above' answer\" #missing_collection \"Missing due to a problem collecting, identifying, or locating the specimen, including patient refusal or unable to provide specimen\" #missing_specimen \"Missing due to a problem with the specimen, e.g. contamination, clotting, improper tube type, improper storage, too small, etc.\" #missing_malfunction \"Missing due to instrument malfunction.\" Value Set Declaration Defines the name of the value set. Keywords Example ValueSet ValueSet: ProposedStatusVS By convention, all value sets should be Pascal case and end with VS . Value Set Description Defines the name of the value set. Keywords Example Description Description: \"The status of a proposal.\" Code-Value Declaration Define the code or value. Keywords Example #proposed \"The proposal has been proposed, but not accepted or rejected.\" CAP#29915 \"None/Negative\" Each value is prefaced by a hash symbol ( # ) and followed by a description enclosed in quotation marks. By convention, each value should use lowercase snake_case formatting . This can either be a new user defined code , or it can be individual codes from separate codesystems, such as the CAP#29915 example, in which 29915 is an existing code within the CAP codesystem. Includes Extends a custom defined ValueSet to include codes from other codesystems. Keywords Example Includes Includes codes from MDR Includes and descending from Includes codes descending from SCT#105590001 Includes and descending from and and not descending from Includes codes descending from SCT#105590001 \"Substance\" and not descending from SCT#410942007 \"Drug or medicament\" You are allowed to include from either a codesystem or a specific code from a codesystem. TODO: explain what descending from and and not descending from actually do with some kind of example. FHIR Examples File To include examples in an IG, you must do the following: Create a fhir_examples folder in the same folder as your CIMPL text files Put the JSON examples inside the fhir_examples folder. For each file: name the file as you wish, but we recommend my_example_id.json (e.g., bc-presence.json in the example, ensure there is a value for the id (e.g., \"id\": \"PatientExample01\" ) Within the example, ensure the meta.profile is set to the profile for the example (e.g., \"meta\": { \"profile\": [ \"http://hl7.org/fhir/us/shr/StructureDefinition/shr-core-Patient\" ] } )","title":"CIMPL 5.0 Reference Documentation"},{"location":"cimpl5Reference/#cimpl-50-reference-documentation","text":"Note: this documentation is in the process of being further expanded and is an actively updating document. This is a comprehensive guide to CIMPL syntax. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial .","title":"CIMPL 5.0 Reference Documentation"},{"location":"cimpl5Reference/#table-of-reference","text":"1. General Overview * 1.1 Whitespace * 1.2 Naming Conventions * 1.3 Ordinality * 1.4 Naming Collisions * 1.5 Versioning * 1.6 Comments 2. File Headers * 2.1 Sample File Header * 2.2 Grammar * 2.3 Namespace Declaration * 2.4 File Description * 2.5 Uses * 2.6 Url Shorthands * 2.7 Codesystems 3. Data Element File * 3.1 Sample Data Element File * 3.2 Element Name Declaration * 3.3 Concept Code * 3.4 Inheritance * 3.5 Description * 3.6 Fields * 3.6.1 Value * 3.6.2 Primitives * 3.6.3 Field * 3.6.4 Inherited Field * 3.6.5 References * 3.7 Field Constraints * 3.7.1 No Constraint * 3.7.2 Cardinality * 3.7.3 Fixed Value * 3.7.4 Type * 3.7.5 Value Set * 3.7.6 Includes Code * 3.7.7 Includes Type 4. Map File * 4.1 Sample Map File * 4.2 Element Mapping * 4.3 Field Mapping * 4.4 Fix * 4.5 Constrain * 4.6 Slicing * 4.6.1 Declaring a Discriminator * 4.6.2 Moving the Slice Location * 4.6.3 Slice Strategies 5. Value Set File * 5.1 Sample Value Set File * 5.2 Value Set Declaration * 5.3 Value Set Description * 5.4 Code-Value Declaration 6. FHIR Examples File 7. Future Architectural Considerations","title":"Table of Reference"},{"location":"cimpl5Reference/#general-overview","text":"CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and compact, while coming with tools to produce CIMCORE (the SHR computable representation) and FHIR profiles.","title":"General Overview"},{"location":"cimpl5Reference/#whitespace","text":"Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 5.0 Namespace: shr.core ...is equivalent to this: Grammar: DataElement 5.0 Namespace: shr.core","title":"Whitespace"},{"location":"cimpl5Reference/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"cimpl5Reference/#file-names","text":"Data Element files: namespace.txt Value Set files: namespace_vs.txt Mapping files: namespace_map.txt Note: any periods in the namespace should be replaced by underscores","title":"File names"},{"location":"cimpl5Reference/#namespaces","text":"A namespace conventionally is denominated by the authoring organization and the broad category of elements the namespace defines, delineated by a period. For example: Namespace: shr.oncology Note: The organization name is recommended but not required (e.g., Namespace: oncology is also allowed).","title":"Namespaces"},{"location":"cimpl5Reference/#elements","text":"Elements are conventionally defined in PascalCase . For example: Element: GeologicalLocation Note: Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter.","title":"Elements"},{"location":"cimpl5Reference/#value-sets","text":"Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: It is required that an Value Set name begins with an uppercase letter.","title":"Value Sets"},{"location":"cimpl5Reference/#code-sets","text":"Within a custom value set, the individual codes are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or other radiation source\" #swimming_pool \"Swimming Pool\"","title":"Code Sets"},{"location":"cimpl5Reference/#ordinality","text":"CIMPL does not enforce or require ordinality in any of its definitions, i.e. an element defined at the bottom of the file can be used as field on an element defined at the top. There is, however, a requirement for a file's header information to be at the top of the file, before any definitions. See: File Headers for more information","title":"Ordinality"},{"location":"cimpl5Reference/#naming-collisions","text":"CIMPL does not support duplicate element names within a namespace. However, you are allowed to reuse an element name across different namespaces. In the case that you come across a collision due to an included namespace in Uses , you have to refer to the element by its Fully Qualified Name .","title":"Naming Collisions"},{"location":"cimpl5Reference/#versioning","text":"CIMPL follows the Semantic Versioning convention (MAJOR.MINOR.PATCH). MAJOR: A breaking change. This is reserved for drastic grammar overhauls. Does not support backwards compatibility to other major version releases. MINOR: Feature updates. Allows for backwards compatability within the major version. PATCH: Minor updates and bug fixes. Allows for backwards compatability within the major version. CIMPL is currently on major version 5. For a full changelog, see the Release Notes .","title":"Versioning"},{"location":"cimpl5Reference/#comments","text":"CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */","title":"Comments"},{"location":"cimpl5Reference/#file-headers","text":"Each CIMPL file contains header information that describes the file type, its scope and inheritance, and its purpose. It also allows developers to create aliases for urls and code systems.","title":"File Headers"},{"location":"cimpl5Reference/#sample-file-header","text":"Grammar: DataElement 5.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication Codesystem: LNC = http://loinc.org","title":"Sample File Header"},{"location":"cimpl5Reference/#grammar","text":"The Grammar keyword is used to define the file type and the version of CIMPL used in development/parsing. This is required for all CIMPL files. Keywords Example Grammar Grammar: DataElement 5.0 Grammar Grammar: ValueSet 5.0 Grammar Grammar: Map 5.0 There are three possible options for file type: 1. DataElement 2. ValueSet 3. Mapping The version details the MAJOR and MINOR version the file was written for. The language is backwards compatibile within the MAJOR version number, i.e. DataElement 5.0 files will compile without problems on the 5.9.0 tooling. For more information, see Versioning .","title":"Grammar"},{"location":"cimpl5Reference/#namespace-declaration","text":"The Namespace keyword defines the scope of the file and serves as a broad grouping of DataElement , ValueSet and Map files within a domain. Keywords Example Namespace Namespace: shr.environment The namespace can be any number of lowercase period delimited words. Best practice is to follow the naming convention pattern of organization . domain (followed by subdomains if necessary). The tooling will not allow for duplicate namespaces. (Note: While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens)","title":"Namespace Declaration"},{"location":"cimpl5Reference/#file-description","text":"The Description keyword provides the user the ability to define the purpose of the file, within the confines of a project. Keywords Example Description Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" The namespace description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. (NOTE: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.)","title":"File Description"},{"location":"cimpl5Reference/#uses","text":"The Uses keyword provides a list of the namespaces used within the current namespace. Namespace inclusion allows you to use DataElement s and ValueSet s defined in other namespaces. Keywords Example Uses Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication In CIMPL version 5 and below, it is required that you import shr.core and shr.base for the tooling to run. (In the case of name collisions, you will have to indicidate DataElement s by their Fully Qualified Name ). The order of inclusion has no effect.","title":"Uses"},{"location":"cimpl5Reference/#url-shorthands","text":"The Path keyword allows for abbreviations of long urls. Keywords Example Path Path: FHIR = http://hl7.org/fhir/ValueSet This functionality is completely optional, but it is provided to make authoring easier. The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter).","title":"Url Shorthands"},{"location":"cimpl5Reference/#codesystems","text":"The Codesystem keyword allows for abbrevations of codesystems. In order to use code systems in a DataElement definition or constraint, it is necessary to first define them in the file header (this is largely due to the complexity of codesystems' direct code references). Keywords Example Codesystem Codesystem: LNC = http://loinc.org You must define each codesystem you use in separate definitions across multiple lines, e.g. Codesystem: LNC = http://loinc.org Codesystem: SCT = http://sct.org The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter) .","title":"Codesystems"},{"location":"cimpl5Reference/#data-element-file","text":"","title":"Data Element File"},{"location":"cimpl5Reference/#sample-data-element-file","text":"Grammar: DataElement 5.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication Codesystem: LNC = http://loinc.org EntryElement: FinancialSituation Concept: MTH#C0516918 Based on: Panel Description: \"Measures of the ability of the subject to obtain and pay for the necessities of life.\" Value: CodeableConcept is MTH#C0516918 0..1 AnnualIncome 0..* IncomeSource PanelCode is LNC#83335-0","title":"Sample Data Element File"},{"location":"cimpl5Reference/#element-name-declaration","text":"The Element keyword allows users to define the name of the element and the lines following the Element keyword comprise the definition of that element. Keywords Example Element Element: Observation EntryElement EntryElement: FinancialSituation Abstract Element Abstract Element: Any Note the spacing discrepancy between EntryElement and Abstract Element . This has no semantic meaning but is inherent to the syntax. These keywords are used to define data elements with three different levels of expression in the target output: * EntryElement is used to define elements that will be used directly by the target output, i.e., data will be entered directly into this item by and end user once it has been mapped. For FHIR exports, these items will be created as 'Primary Profiles' * Element is used to define supporting data elements for EntryElement s. These data elements will be present in the target output as, but they are not the top-level items that are exported. For FHIR exports, these items will be created as 'Supporting Profiles'. * Abstract Element is used to define elements that are used only within the CIMPL mapping to create basic objects that will be leveraged by other data elements. They will not be present in the target mapping.","title":"Element Name Declaration"},{"location":"cimpl5Reference/#fully-qualified-names","text":"In addition to its declared name, all elements also have a unique identifying Fully Qualified Name ( FQN ). The FQN is a combination of the element's namespace and its declared name (through concatention delimited by a period). For example, the element Observation in the namespace shr.finding has the following FQN: shr.finding.Observation Note: While rare and considered bad practice, naming collisions between elements across multiple namespaces is possible. In the case of a naming collision (such as when a namespace Uses multiple namespaces that define an element with the same declared name), you would have to refer to the specific unique FQN instead of the declared name in element, field, and value definitions.","title":"Fully Qualified Names"},{"location":"cimpl5Reference/#concept-code","text":"The Concept keyword is used to define the concept code for the element. These are numerical codes that identify clinical terms, primitive or defined, organized in hierarchies. Keywords Example Concept Concept: MTH#C0516918 Concept codes for the meaning of the defined structure (SNOMED CT and LOINC codes, as an example). While optional, it is recommended you define the concept of an element. To see how it relates to FHIR output, see StructureDefinition.keyword .","title":"Concept Code"},{"location":"cimpl5Reference/#inheritance","text":"Provides the parent element from which the properties are inherited. This works similar to class inheritance in object orientated programming. Additionally, mappings are inherited alongside properties. Keywords Example Based on Based on: Panel Multiple inheritance is currently removed from CIMPL support. Selective inheritance is achievable through 'zeroing out' inherited properties. See Cardinality","title":"Inheritance"},{"location":"cimpl5Reference/#description","text":"The textual description of the element. Keywords Example Description Description: \"Measures of the ability of the...\" The element description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. To see how it relates to FHIR output, see StructureDefinition.description . (NOTE: While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.)","title":"Description"},{"location":"cimpl5Reference/#fields","text":"","title":"Fields"},{"location":"cimpl5Reference/#value","text":"Defines what the element is. You are allowed to declare a value to be either a primitive or a DataElement. Keywords Example Value Value: CodeableConcept Value: string Value is an optional special field on an element that correspond more heavily to what the element is . You are also allowed to constrain the value similar to other fields. On the mapping side, you are able to map the value like any other field. Value defaults to a cardinality of 1..1 , but this can be changed, e.g.: Value: 0..1 Quantity","title":"Value"},{"location":"cimpl5Reference/#primitives","text":"CIMPL allows users to define fields as the following primitive data types: * boolean * integer * string * decimal * uri * base64Binary * instant * date * dateTime * time * code * oid * id * markdown * unsignedInt * positiveInt * xhtml","title":"Primitives"},{"location":"cimpl5Reference/#field","text":"Object properties on the element. Keywords Example 0..1 AnnualIncome In most cases, you refer to an element by its name. In the rare case of a naming collision, you must refer to it by its Fully Qualified Name .","title":"Field"},{"location":"cimpl5Reference/#inherited-field","text":"Object properties on the element inherited from the parent or other elements. Keywords Example PanelCode is LNC#83335-0","title":"Inherited Field"},{"location":"cimpl5Reference/#inherited-value","text":"Object value on the element inherited from the parent or other elements. Keywords Example Value Value is MTH#C0516918 The Value keyword can be used identically to an Inherited Field .","title":"Inherited Value"},{"location":"cimpl5Reference/#references","text":"In order to refer to an element as a class (i.e. a pointer as opposed to an instance), you can encapsulate the element name using ref() . This is helpful for defining complex objects with child elements that are already defined as parts of existing data elements. Keywords Example ref() 1..1 ref(Role) ref() 0..1 PartOf value is type ref(Organization) ref() Value: ref(Finding) ref() Value: 0..* ref(Observation) The ref(...) syntax should only encapsulate the element name. All other fields should be applied normally to the group. ref() can be used to specify that a reference is either the child element of a data element (e.g., 1..1 ref(Role) ) or the Value of an existing child element (e.g., 0..1 PartOf value is type ref(Organization) ).","title":"References"},{"location":"cimpl5Reference/#field-constraints","text":"Fields can be constrained to further specify their acceptable values using cardinalities and keywords, e.g.: * is * is type * from * includes","title":"Field Constraints"},{"location":"cimpl5Reference/#no-constraint","text":"Fields can exist without any constraints. They can also be constrained to a data type (or set of data types) without further constraining the possible values within that data type. Keywords Example 0..1 GeopoliticalLocation Value: CodeableConcept or Value: unsignedInt or positiveInt","title":"No Constraint"},{"location":"cimpl5Reference/#cardinality","text":"Cardinality defines the number of instances should exist for a value. The first digit indicates the minimum quantity, and additionally by setting it to 0 or to 1 , has the effect of making a field optional or required. The second digit expresses the upper bound. To express no upper bound, a * can be used in place of a number. When constraining an inherited field, you can only retain the previous cardinality, or constrain it to be narrower. Note: By constraining it to 0..0, you can remove an inherited field from an element. Keywords Example 0..* LanguageUsed 1..2 GovernmentIssuedID","title":"Cardinality"},{"location":"cimpl5Reference/#fixed-value","text":"The is keyword limits the field to a specifc value (e.g., a code , a specific string , or a boolean value). Keywords Example is ObservationCode is LNC#82810-3 Note: The is keyword locks the code for all instances of the data element. If you only need to lock the code for one particular mapping, do so using the fix keyword in the mapping file.","title":"Fixed Value"},{"location":"cimpl5Reference/#type","text":"The is type keywords limits the data type of a field to a previously defined element. Keywords Example is type Quantity is type DollarAmount Use case: If we have an abstract element, and we are making a more specific version of that element, we also want to make its fields more specific. For instance, if we have a DataElement Person which has a field Pet , and we making a more specific person DogOwner and we want to further specify its pet. In this case, we could constrain Pet is type Dog .","title":"Type"},{"location":"cimpl5Reference/#value-set","text":"The from keyword limits the value of a field to be from a specific value set, with different levels of requirement. Keywords Example Binding Strength from Substance from SubstanceOfAbuseVS Required must be Priority must be from http://hl7.org/fhir/ValueSet/request-priority Required should be 1..1 Status should be from http://hl7.org/fhir/ValueSet/event-status Preferred could be CodeableConcept could be from http://hl7.org/fhir/ValueSet/medication-as-needed-reason Example if covered Category from http://hl7.org/fhir/ValueSet/goal-category if covered Extensible The binding strengths correspond to FHIR binding strengths and have the same meaning: * Required: To be conformant, the concept in this element SHALL be from the specified value set * Preferred: Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant. * Example: Instances are not expected or even encouraged to draw from the specified value set. The value set merely provides examples of the types of concepts intended to be included. * Extensible: To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated. If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead.","title":"Value Set"},{"location":"cimpl5Reference/#includes-code","text":"For fields that are already defined with a data type of code , the includes keyword expands the allowable entries for that field. Keywords Example includes Category includes LNC#54511-1 \"Behavior\" includes ProblemCategory includes #adverse_reaction The first example above expands Category to include 54511-1 from the LOINC codesystem. Additionally, it is given a brief textual description of \"Behavior\" . The second example above expands the allowable codes in ProblemCategory to include #adverse_reaction . Unlike the first example, the value set does not precede the code, because it has defined on ProblemCategory 's parent using a from statement. Additionally, there is no textual description, as that is optional.","title":"Includes Code"},{"location":"cimpl5Reference/#includes-type","text":"Specifies the quantity of particular types of objects within the value. Keywords Example includes Foo includes 1..1 PhysicalActivityLevel This is useful in further specifying fields that are analagous to lists. In the above example, the field Foo is required to include 1 PhysicalActivityLevel . To add more inclusions, simply add more includes statements on Foo . For example, a blood pressure panel can include any number of tests, but we assume that at least one of those tests will be systolic pressure and another will be diastolic pressure: Element: VitalSign 1..* BloodPressurePanel includes 1..1 SystolicPressure includes 1..1 DiastolicPressure Note: The collective cardinality of all inclusions must fit within the field, i.e. if you are including 3 distinct elements, then the field must have a maximum cardinality greater than 3 (like * ).","title":"Includes Type"},{"location":"cimpl5Reference/#map-file","text":"By default, new elements will appear as FHIR extensions unless the element is mapped to an existing FHIR element. These mapping allow for simpler slicing and fixed values.","title":"Map File"},{"location":"cimpl5Reference/#sample-map-file","text":"Grammar: Map 5.0 Namespace: shr.allergy Target: FHIR_STU_3 Condition maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-condition: RelatedEncounter maps to context Informant maps to asserter Subject maps to subject Entry.CreationTime maps to assertedDate Value maps to code Category maps to category ClinicalStatus maps to clinicalStatus Onset maps to onset[x] Abatement maps to abatement[x] BodySiteOrCode[CodeableConcept] maps to bodySite BodySiteOrCode[BodySite] maps to http://hl7.org/fhir/StructureDefinition/body-structure Severity maps to severity Stage maps to stage Stage.Value maps to stage.summary Evidence maps to evidence","title":"Sample Map File"},{"location":"cimpl5Reference/#element-mapping","text":"Maps a CIMPL element to a target element. Keywords Example maps to FinancialSituation maps to DiagnosticResult: FinancialSituation: In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. If no FHIR mapping is defined for an element and it inherits no mappings from its parents, it defaults to a mapping to the Basic resource . In general, this is not recommended because it has no inherent semantic meaning for implementers. To promote interoperability and reuse, CIMPL modelers are encouraged to find target models that already exist and use constraints or extensions to modify them according to project needs.","title":"Element Mapping"},{"location":"cimpl5Reference/#field-mapping","text":"Maps a CIMPL element field to a target field. Keywords Example maps to MaritalStatus maps to maritalStatus maps to Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity maps to MultipleBirth maps to multipleBirth[x].boolean maps to Value.ActiveFlag maps to active maps to AdverseReaction.AllergenIrritant maps to reaction.substance maps to BodySiteOrCode[CodeableConcept] maps to bodySite In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. With FHIR as the target output, the right-hand side of the map statement can point to any field on a FHIR resource, including: * Fields that are at the root of the resource (e.g., maritalStatus ) * Fields that are child elements of root elements on the resource (e.g., reaction.substance ) * Fields that have a choice of data types (e.g., multipleBirth[x].boolean ) * Fields that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity )","title":"Field Mapping"},{"location":"cimpl5Reference/#fix","text":"Similar to the is keyword, the fix keyword allows for FHIR fields to be locked to a certain value. It is helpful for locking field values in specific mappings (instead of in the DataElement definition, which would be locked for all potential mappings). Keywords Example fix fix status to #completed Note about syntax: The element being fixed on left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any code or primitive value to be fixed.","title":"Fix"},{"location":"cimpl5Reference/#constrain","text":"The constrain keyword allows users to constrain the cardinality of elements in output files. Keywords Example constrain constrain explanation to 0..1 Note about syntax: The element being fixed on the left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any cardinality .","title":"Constrain"},{"location":"cimpl5Reference/#slicing","text":"When fields are allowed to repeat on a target model (e.g., have cardinality with an upper bound greater than 1), it is common practice to specify which CIMPL elements are mapped to instances of that repeated field on the target model. This process is called slicing . For example, the FHIR Task resource allows for an arbitrary number of input fields to be added. To ensure that all each of the input fields is uniquely addressable by a parsing engine, those inputs need to be differentiated by a discriminator . See the FHIR documentation for more detail about slicing and discriminators TODO: Add a slicing example to the sample map file","title":"Slicing"},{"location":"cimpl5Reference/#declaring-a-discriminator","text":"To perform any slicing, a discriminator needs to be declared, using slice on followed by the discriminator. Keywords Example slice on Laterality maps to qualifier (slice on = coding.code) slice on type TODO CIMPL supports the FHIR processing types for discriminators: | Discriminator | Definition | | ------------- | ---------- | | value | The slices have different values in the nominated element| | exists | The slices are differentiated by the presence or absence of the nominated element| | pattern | The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x]| | type |The slices are differentiated by type of the nominated element to a specifed profile| | profile | The slices are differentiated by conformance of the nominated element to a specifed profile|","title":"Declaring a Discriminator"},{"location":"cimpl5Reference/#moving-the-slice-location","text":"If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Keywords Example slice at Members.Observation maps to related.target (slice at = related; slice on type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occuring at related.target . Instead, the slice at = related ensures that the slicing is occuring at the related element.","title":"Moving the Slice Location"},{"location":"cimpl5Reference/#slicing-strategies","text":"TODO: What does this do and when should it be used? Keywords Example slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) * TODO: What is the syntax? What are the allowable options? * TODO: find or create a less complex example","title":"Slicing Strategies"},{"location":"cimpl5Reference/#value-set-file","text":"The value set files are used to define custom value sets and codes when existing sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient.","title":"Value Set File"},{"location":"cimpl5Reference/#sample-value-set-file","text":"Grammar: ValueSet 5.0 Namespace: shr.base ValueSet: ValueAbsentReasonVS Description: \"Reasons that a value associated with a test or other finding is missing.\" Includes codes from DAR #missing_refused \"Human source was asked but declined to respond to the question, or an applicable question was left unanswered.\" #missing_noexplanation \"The reason the information is not present is not known.\" #missing_nonesuch \"The answer is missing because nothing of a type of thing is known to exists, e.g., the siblings of an only child. Also use this code to represent a 'none of the above' answer\" #missing_collection \"Missing due to a problem collecting, identifying, or locating the specimen, including patient refusal or unable to provide specimen\" #missing_specimen \"Missing due to a problem with the specimen, e.g. contamination, clotting, improper tube type, improper storage, too small, etc.\" #missing_malfunction \"Missing due to instrument malfunction.\"","title":"Sample Value Set File"},{"location":"cimpl5Reference/#value-set-declaration","text":"Defines the name of the value set. Keywords Example ValueSet ValueSet: ProposedStatusVS By convention, all value sets should be Pascal case and end with VS .","title":"Value Set Declaration"},{"location":"cimpl5Reference/#value-set-description","text":"Defines the name of the value set. Keywords Example Description Description: \"The status of a proposal.\"","title":"Value Set Description"},{"location":"cimpl5Reference/#code-value-declaration","text":"Define the code or value. Keywords Example #proposed \"The proposal has been proposed, but not accepted or rejected.\" CAP#29915 \"None/Negative\" Each value is prefaced by a hash symbol ( # ) and followed by a description enclosed in quotation marks. By convention, each value should use lowercase snake_case formatting . This can either be a new user defined code , or it can be individual codes from separate codesystems, such as the CAP#29915 example, in which 29915 is an existing code within the CAP codesystem.","title":"Code-Value Declaration"},{"location":"cimpl5Reference/#includes","text":"Extends a custom defined ValueSet to include codes from other codesystems. Keywords Example Includes Includes codes from MDR Includes and descending from Includes codes descending from SCT#105590001 Includes and descending from and and not descending from Includes codes descending from SCT#105590001 \"Substance\" and not descending from SCT#410942007 \"Drug or medicament\" You are allowed to include from either a codesystem or a specific code from a codesystem. TODO: explain what descending from and and not descending from actually do with some kind of example.","title":"Includes"},{"location":"cimpl5Reference/#fhir-examples-file","text":"To include examples in an IG, you must do the following: Create a fhir_examples folder in the same folder as your CIMPL text files Put the JSON examples inside the fhir_examples folder. For each file: name the file as you wish, but we recommend my_example_id.json (e.g., bc-presence.json in the example, ensure there is a value for the id (e.g., \"id\": \"PatientExample01\" ) Within the example, ensure the meta.profile is set to the profile for the example (e.g., \"meta\": { \"profile\": [ \"http://hl7.org/fhir/us/shr/StructureDefinition/shr-core-Patient\" ] } )","title":"FHIR Examples File"},{"location":"cimpl5Tutorial/","text":"CIMPL 5.0 Tutorial This is an extensive tutorial, meant to educate people about many different aspects of CIMPL. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL documentation . Table of Contents CIMPL 5.0 Tutorial Table of Contents Background Why use a modeling tool? Data Elements, Maps, and Value Sets Building Your First Data Model CIMPL Environment Setup Data Elements Header Create an Animal Value Sets Maps Command-Line Arguments Execution and Error Identification CIMPL Outputs FHIR Output Improving your First Data Model Inheritance and Constraints Element inheritance using Based on Constraints Managing Multiple Namespaces Concept Codes CodeSystem Declarations The includes Constraint Inherited Values Background This tutorial assumes that you are already comfortable with: Using a code editor (e.g., Visual Studio Code ) Using the command line on a unix-based OS (e.g., Linux, macOS) Data modeling (e.g., what separates a code from a value, what is a codeable concept) Data constraints (e.g., an element SHALL contain a specific code, another element MAY exist) Why use a modeling tool? It can be difficult for people to jump directly into resource modeling, especially for extensive, domain-specific implementations like FHIR. CIMPL is purpose-built to create clear, concise object models independent of their particular implementations. Abstraction between data models and implementations allows for cleaner code and a more repeatable and understandable process for building implementation code. Data Elements, Maps, and Value Sets CIMPL input files are either Data Elements, Maps, or Value Sets. Data Element files are the backbone of your input - they define individual data elements, whether those data elements are nested within other data elements, and the cardinalities of those data elements, among other things Map files dictate how the elements defined in your data model should be represented in a target implementation (for now, FHIR is the only output supported). Value Set files can be used to define custom codes and/or value sets for use in your data models. Building Your First Data Model Let's get started with a data model using an example. Say we've just purchased a zoo and we want to define a data model for the animal clinic at our new zoo, which could include things like: Animals Staff Facilities Medicines Food etc. CIMPL Environment Setup Before we develop any models, let's make sure our environment is set up. If you haven't already done so, follow the CIMPL Installation instructions and check that everything is working using the Hello World test. Create a directory that shares the same parent folder as your shr-cli installation and name it zoo : mkdir ~/cimpl/zoo Your directory structure should look like this: cimpl |- shr-cli |- zoo We'll need to copy some files from the SHR specification into the zoo directory to ensure that the shr-cli tool runs properly. Download the following files and place them in the zoo directory: base_map.txt base.txt core_map.txt core_vs.txt core.txt Your directory structure should now look like this: cimpl |- shr-cli |- zoo |- base_map.txt |- base.txt |- core_map.txt |- core_vs.txt |- core.txt Data Elements Header The core part of any data model is the definition of its data elements. Many modeling tools use diagrams or database tables to define their data elements, but CIMPL is defined using plain text. Create a file called zoo_animal.txt and open it. To give our zoo_animal.txt file some context, we need to include some header information. Let's start with a line that describes what the file is: Grammar: DataElement 5.0 Every CIMPL file starts by defining the Grammar . The common CIMPL files are DataElement , Map , and ValueSet . We'll get into Map and ValueSet later. This is a DataElement file that is using CIMPL version 5.0 . Next, add your file to a namespace : Grammar: DataElement 5.0 Namespace: zoo.animal The namespace allows you to define a scope for value sets, data elements, and data mappings. By convention, the namespace is period-delimited, with the project ( zoo ) preceding the specific data model that we are defining ( animal ). The filename ( zoo_animal.txt ) doesn't have to match, but it's good practice to keep the two consistent. Filenames should use underscores in place of periods to avoid confusion with file types. While we're at it, let's give this file a description: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Descriptions can include any characters (except quotation marks) and be as long as you need, but it is good practice to keep them short and simple. By default, we'll need to include some basic modeling building blocks with the uses keyword: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base Once our zoo gets more complicated, we will need to add more to the uses statement, but for now we're just including the basic building blocks that all CIMPL models would not want to redefine (e.g., Entry , Quantity , CodeSystem , etc.). Great! That's it for the DataElement file header. Create an Animal With the header information out of the way, we can start defining our first data element: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal Since we plan to map this element to some output (we'll get into mapping later), we're using the term EntryElement to describe our Animal . Eventually, this element will have data entered directly into it, thus EntryElement and not just Element . Let's add some attributes to our animal: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType We've added four separate attributes to this Animal : DateOfBirth , Name , AnimalType , and DeceasedStatus . Users familiar with traditional cardinality notation for data modeling will notice that the DateOfBirth and DeceasedStatus fields are required and can only appear once, while the AnimalType is optional and our Animal can have an arbitrary number of Name s. CIMPL doesn't know how to interpret these attributes yet, so let's define them as child Element s, starting with DateOfBirth : Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date We've defined DateOfBirth as an Element , added a short Description , and assigned a Value of date , which is one of the primitive data types that CIMPL accepts . CIMPL is whitespace-agnostic, so the indentation is not necessary, but it is good practice to indent child elements underneath their parents. Element s can get more complicated but let's leave it at that. Now that you know the basic structure of an Element , let's define Name and DeceasedStatus (as a string and boolean , respectively): Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Since we want AnimalType to be restricted to a certain set of values, we need to define a custom ValueSet file. Create a file called zoo_animal_vs.txt and open it. Value Sets Just like we did for the DataElement file, we need to define some header information for our ValueSet file: Grammar: ValueSet 5.0 Namespace: zoo.animal That's it! Since the ValueSet file is in the same namespace as our DataElement file, we don't need to add a Description or set up inheritance with a Uses statement. Start defining our AnimalType value set by giving it a name: Grammar: ValueSet 5.0 Namespace: zoo.animal ValueSet: AnimalTypeVS // These are the major classes of animal that we want to model. By convention, all value sets should be Pascal case and end with VS . You may notice that we've added a comment to the value set after the double-slash ( // ). CIMPL uses JavaScript comment syntax and you can add comments in your files to give extra context to certain items. They aren't required, but could be helpful later on when you are reviewing the file. With the value set named, let's go ahead and add some values: Grammar: ValueSet 5.0 Namespace: zoo.animal ValueSet: AnimalTypeVS // These are the major classes of animal that we want to model. #invertebrate \"Invertebrates are characterized by their lack of backbones and internal skeletons\" #fish \"Fish breathe using gills, and are equipped with 'lateral lines' that detect water currents and even electricity\" #amphibian \"Amphibians are characterized by their semi-aquatic lifestyles (they have to stay near bodies of water, both to maintain the moisture of their skin and to lay their eggs)\" #reptile \"Reptiles are characterized by their cold-blooded metabolisms, their scaly skin, and their leathery eggs, which, unlike amphibians, they can lay some distance away from bodies of water\" #bird \"Birds are characterized by their coats of feathers, their warm-blooded metabolisms, their memorable songs (at least in certain species), and their ability to adapt to a wide range of habitats\" #mammal \"Mammals are characterized by their hair or fur (which all species possess during some stage of their life cycles), the milk with which they suckle their young, and their warm-blooded metabolisms\" Each value is prefaced by a hash symbol ( # ) and followed by a description enclosed in quotation marks. By convention, each value should use lowercase snake_case formatting . We've defined our custom ValueSet but we still need to add it to our DataElement file, so open zoo_animal.txt and add the full definition for our AnimalType : Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS Now, AnimalType will be restricted to the values defined in our custom value set, thanks to the code from [ValueSet] syntax. That's it! We have defined our DataElement file and a custom ValueSet for AnimalType , so we can map our model to its output. Create a file called zoo_animal_map.txt and open it. Maps Our data model is fully defined, but we still need to map it to an output format. Currently, CIMPL only supports output to various versions of the FHIR specification . Let's create the file header for our map: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 In this case, we plan to map our data model to FHIR resources, so we are using FHIR_STU_3 as our target model. Next, we map our EntryElement to its FHIR counterpart: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: For our clinic, it makes sense to map animals as Patient resources in FHIR , since they will be the entities receiving care. In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your FHIR output. Let's map our animal attributes. The name and birthDate fields exist in the FHIR Patient resource , so it looks like they will be simple mappings from our Name and DateOfBirth attributes: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: Name maps to name DateOfBirth maps to birthDate The FHIR Patient resource represents the deceased status using the deceased[x] field. The [x] indicates that this field provides a choice of data types; in this case boolean or dateTime . Since our DeceasedStatus element is a boolean value, we can map it to deceased[x] and the CIMPL framework will properly identify it as mapping to the boolean choice: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: Name maps to name DateOfBirth maps to birthDate DeceasedStatus maps to deceased[x] That just leaves AnimalType , which...doesn't seem to fit nicely into any of the fields on the FHIR Patient resource. There are fields for animal.species , animal.breed , and animal.genderStatus , but there isn't anything that maps well to our custom animal class codes. That's okay! If we simply leave off a mapping for the AnimalType , it will be created as an extension on the FHIR Patient resource. More information about FHIR extensions is available in the FHIR documentation. With all of our data elements, custom value sets, and mapping defined for our Animal element, it's time to run the shr-cli tool. Command-Line Arguments Before we run the shr-cli tool, let's break down the syntax for calling it using the command line: node {location_of_shr_cli_tool} {location_of_cimpl_files} {optional_arguments} node : The shr-cli tool is written in node.js , so we start our statement by calling for that application. {location_of_shr_cli_tool} : Next, we need to tell node which code to run by giving it the directory where the shr-cli tool lives. If you're in the shr-cli directory, you can use a single period ( . ) as a shorthand for that directory. {location_of_cimpl_files} : Now that node has the code it needs to run, we need to give it the directory where our CIMPL files reside. {optional_arguments} : There are a few other options that you can pass to the shr-cli tool. Check the README for all of the possible arguments . Execution and Error Identification Run the shr-cli tool using the following commands: cd ~/cimpl/shr-cli node . ../zoo -o ../zoo/out Uh-oh. You should see the following output: [15:21:21.846Z] INFO shr: Starting CLI Import/Export [15:21:24.435Z] ERROR shr: Mismatched types. Cannot map zoo.animal.Name[Value: string] to [HumanName]. ERROR_CODE:13022 (module=shr-fhir-export, shrId=zoo.animal.Animal, target=Patient, mappingRule=\"Name maps to name\") [15:21:25.410Z] INFO shr: Compiling Documentation for 3 namespaces... (module=shr-json-javadoc) [15:21:25.492Z] INFO shr: Building documentation pages for 31 elements... (module=shr-json-javadoc) [15:21:25.669Z] INFO shr: Finished CLI Import/Export ------------------------------------------------------------ Elapsed time: 3.829s 1 errors (shr-fhir-export) 0 warnings ------------------------------------------------------------ Huh - it looks like we have an error. That's okay! This is pretty common in developing CIMPL files and the output from the shr-cli tool can help us troubleshoot. In, particular, this line tells us where we need to make changes: [15:21:24.435Z] ERROR shr: Mismatched types. Cannot map zoo.animal.Name[Value: string] to [HumanName]. ERROR_CODE:13022 (module=shr-fhir-export, shrId=zoo.animal.Animal, target=Patient, mappingRule=\"Name maps to name\") We defined our Name element as a string , but the name attribute on the FHIR Patient record has the type of HumanName . We have two options: 1. We can redefine the Name element as a HumanName , define the HumanName datatype, and redo the mapping so the Name element is properly mapped to FHIR fields 2. We can remove the mapping from Name to the name attribute on the FHIR patient and allow the Name to be created as an extension Note: for more information about possible errors, see the Error Message Documentation Let's take the easier path of removing the mapping for Name . Change your zoo_animal_map.txt file to: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: DateOfBirth maps to birthDate DeceasedStatus maps to deceased[x] With the Name field removed from the mapping, the shr-cli output should run without errors: computer:shr-cli username$ node . ../zoo -o ../zoo/out [18:06:56.010Z] INFO shr: Starting CLI Import/Export [18:07:00.775Z] INFO shr: Compiling Documentation for 3 namespaces... (module=shr-json-javadoc) [18:07:00.881Z] INFO shr: Building documentation pages for 31 elements... (module=shr-json-javadoc) [18:07:01.135Z] INFO shr: Finished CLI Import/Export ------------------------------------------------------------ Elapsed time: 5.136s 0 errors 0 warnings ------------------------------------------------------------ Excellent. You should find that the out directory in your zoo folder now contains quite a bit of material. We'll explore its contents in the next section. CIMPL Outputs By default, shr-cli takes CIMPL models and exports files into the following directories (under out/ ): * cimcore : The serialized, machine-readable CIMCORE (Clinical Information Modeling Computable Representation) files representing the CIMPL input. For more information, see the CIMCORE Documentation . * es6 : ES6 JavaScript classes that support interacting with instances of the SHR elements within JS code. Typically, a JavaScript application will load SHR data from a JSON or FHIR format and then represent the entries in memory using these ES6 classes. * fhir : HL7 FHIR ( Fast Healthcare Interoperability Resources ) is an open, international standard for electronic exchange of healthcare information that is governed by HL7. The files in this folder define FHIR profiles, extensions, logical models, value sets, code systems, and the source needed to generate an HL7 FHIR Implementation Guide. * json : A legacy serialization format used to generate parts of standardhealthrecord.org . This format has been deprecated in favor of CIMCORE . * json-schema : JSON schemas used to define and validate the structure of instance data. * modeldoc : Javadoc -style HTML documentation representing the CIMPL data elements. Casual users may find this documentation easier to review than the CIMPL text input files. Each of the generated files in these directories would take a considerable amount of time to create by hand, but CIMPL's concise syntax combined with the shr-cli generators allow for quick initial and subsequent drafts. FHIR Output For this tutorial, we will focus on the FHIR output. Open the following file: zoo/out/fhir/profiles/zoo-animal-Animal.json This is a JSON representation of a FHIR profile. It's a bit difficult to read in this form, but we can make it slightly more legible by creating a FHIR Implementation Guide. In the development of FHIR standards, an Implementation Guide is the document that most people review when writing software that includes a data standard. It is a human-readable webpage that can contain multiple profiles, extensions, value sets, code sets, etc. and gives context to how those items should be used in a software application. Let's add some project-specific context to our Implementation Guide. Open the following file: zoo/config.json It should look something like this: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } } Let's edit this file to make it more specific to our project: { \"projectName\": \"We bought a zoo\", \"projectShorthand\": \"ZOO\", \"projectURL\": \"http://thatzoowebought.com\", \"fhirURL\": \"http://thatzoowebought.com/fhir\", \"implementationGuide\": { \"npmName\": \"zoo\", \"version\": \"0.0.1\", \"indexContent\": \"zoo.html\" }, \"publisher\": \"Zoo Owner\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://thatzoowebought.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Zoe the Zoo Owner\", \"organization\": \"Zoo Owner\", \"email\": \"zoe@thatzoowebought.com\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) Zoo Owner <http://thatzoowebought.com>\" } } That's better. Note that we also added two new fields to the implementationGuide object: npmName and version . These are new requirements from the FHIR IG Publisher and haven't yet been integrated into the default config template -- but we need them to successfully run the IG Publisher. You'll also notice that the implementationGuide object's indexContent value references a file named zoo.html . This file contains the HTML content that will always show up on the homepage of your generated Implementation Guide. If you have a mission statement, a project timeline, or other general context for your project, this is a good place to include them. Note that this file will be embedded within the <body> tag of the IG home page, so you should not include <html> , <head> , or <body> tags yourself. Let's create the zoo/zoo.html file with the following contents: <h1>We Bought a Zoo!</h1> <p>In 2018, after coming into an absurd amount of money, we decided to buy a zoo! Now, we need to figure out how to care for all the animals. This Implementation Guide describes the data models for our new zoo clinic IT system.</p> After running the shr-cli tool again, we can generate the IG using HL7's FHIR IG Publishing tool . Run the following commands: cd ~/cimpl/shr-cli cp -r ../zoo/out . yarn run ig:publish Note: if this fails, see the shr-cli README for more detailed instructions on running the FHIR IG generator . Open the following file: ~/cimpl/shr-cli/out/fhir/guide/output/index.html It should look something like this: Let's take a look at the items that CIMPL generated. Click the 'Profiles' link and you should see this: Since we only have one profile, that screen isn't terribly helpful. Click on the 'Animal' link to see the profile we just generated: That's much more helpful. You can see a few of the things we defined in config.json , the Name and AnimalType extensions defined in our mapping, and other bindings and constraints created by the shr-cli tool. For a more compact view of the profiled resource, click on the Differential Table tab: This looks a lot more like the DataElement file. All four of our Animal attributes are present and the AnimalType is explicitly bound to our AnimalTypeVS value set. You may notice that the Type for birthDate is not listed here. That is because it is already explicitly defined on the FHIR Patient resource as a date . This 'Differential Table' view only shows the differences between the generated profile and the FHIR resources on which they are based. Improving your First Data Model Now that we've built a very simple model for our animals, we can expand it using other aspects of the CIMPL language. Inheritance and Constraints Let's start by making a few more animals in our zoo_animal.txt file: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS EntryElement: Lion Based on: Animal Description: \"The king of the jungle.\" AnimalType is #mammal EntryElement: Shark Based on: Animal Description: \"The king of the ocean.\" AnimalType is #fish EntryElement: Eagle Based on: Animal Description: \"The king of the sky.\" AnimalType is #bird Looks like this zoo has quite the display! We've added three animals to our model ( Lion , Shark , and Eagle ) to show additional CIMPL functionality: Element inheritance using Based on Since all three are animals, we can go ahead and make all three of them Based on on the Animal class we've already defined. This lets Lion , Shark , and Eagle inherit all of the properties of Animal (i.e., DateOfBirth , Name , etc.), so we don't have to redefine them on the more specific animals. This includes mapping inheritance, so if we don't add new fields, we don't have to create new mappings! Constraints We've constrained each of these animals' AnimalType using {element} is {value} to make the model more specific to our creatures. In our AnimalType definition, we established that its code must come from the custom AnimalTypeVS value set. From that value set, the #mammal , #fish , and #bird codes are relevant for those animals. Constraints (e.g., is ) are an important capability in CIMPL that lead to more accurate, specific models. We will keep coming back to this concept, but it will be helpful to refer to the CIMPL documentation . Managing Multiple Namespaces Now that our zoo is full of animals, where do we put them? We haven't defined any enclosures yet, and it wouldn't exactly make sense to put them in the zoo.animal namespace, so let's make a new zoo.facility namespace. Similarly to how we made the zoo.animal namespace, let's go ahead and make a new file called zoo_facility.txt and add header information: Grammar: DataElement 5.0 Namespace: zoo.facility Description: \"Enclosure environments of the zoo\" Uses: shr.core, shr.base Now let's add an Enclosure and some specific types of enclosures: Grammar: DataElement 5.0 Namespace: zoo.facility Description: \"Enclosure environments of the zoo\" Uses: shr.core, shr.base CodeSystem: MTH = http://ncimeta.nci.nih.gov EntryElement: Enclosure Concept: MTH#C2986715 Value: code from EnclosureVS 1..1 Dimensions Dimensions.DimensionComponent includes 1..1 Length includes 1..1 Width EntryElement: Jungle Based on: Enclosure Value is #tropical EntryElement: Aquarium Based on: Enclosure Value is #aquatic EntryElement: Aviary Based on: Enclosure Value is #sky In addition to this new namespace ( zoo.facility ), we've introduced a few new CIMPL concepts: Concept Codes Concept codes are numerical codes organized in hierarchies that identify clinical terms. They can be useful for correlating your element with a specific clinical concept but do not impact the structure of your elements or add any specific constraints about how they are used. For instance, the Enclosure can be described by the NCI Metathesaurus code MTH#C2986715 . In the FHIR output, this outputs as StructureDefinition.keyword . CodeSystem Declarations In order to use that concept code, we must first define the CodeSystem in the header of our file. This allows us to reference the NCI Metathesaurus with the MTH abbrevation. All abbrevations must be uppercase. The includes Constraint The Dimensions element includes DimensionComponent values for both a Length and a Width . We don't have to define those elements here, because they are already defined in shr.core . This includes structure is a constraint (specifically the includes type constraint) that allows you to specify members of a list. In this case, since both Length and Width are Based on DimensionComponent and the Dimensions element can include multiple DimensionComponent elements, we are specifying that Dimensions must include both Length and Width (though it may also contain other DimensionComponent elements). Inherited Value s In Jungle , Aquarium , and Aviary , we introduce the concept of constraining an inherited Value . While the Enclosure element's Value is constrained to a value set (using code from EnclosureVS ), we can further constrain the Value for Jungle , Aquarium , and Aviary to a specific code using the is keyword (e.g., Value is #sky ). We've used AnimalEnclosureVS but it isn't defined yet. Let's create a new ValueSet file named shr_facility_vs.txt and add that value set: Grammar: ValueSet 5.0 Namespace: zoo.facility ValueSet: EnclosureVS // These are the environments in which our animals live. #tropical \"An environment with average temperature of above 18 degrees Celsius and considerable precipitation during at least part of the year\" #aquatic \"An ecosystem in a body of water\" #sky \"An ecosystem in the sky\" Now, going back to our zoo_animal.txt file, let's add this information to our animals: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base, zoo.facility EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType 1..* Enclosure Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS EntryElement: Lion Based on: Animal Description: \"The king of the jungle.\" AnimalType is #mammal Enclosure is type Jungle EntryElement: Shark Based on: Animal Description: \"The king of the ocean.\" AnimalType is #fish Enclosure is type Aquarium EntryElement: Eagle Based on: Animal Description: \"The king of the sky.\" AnimalType is #bird Enclosure is type Aviary We've made two very important edits: 1. We added the zoo.facility namespace to the Uses statement in the file header, allowing our zoo.animal files to reference any item in the zoo.facility files. 2. We've added Enclosure as a child element of Animal and further constrained the types of enclosure allowed for each of our animals ( Lion , Shark , and Eagle ) using the is type .","title":"CIMPL 5.0 Tutorial"},{"location":"cimpl5Tutorial/#cimpl-50-tutorial","text":"This is an extensive tutorial, meant to educate people about many different aspects of CIMPL. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL documentation .","title":"CIMPL 5.0 Tutorial"},{"location":"cimpl5Tutorial/#table-of-contents","text":"CIMPL 5.0 Tutorial Table of Contents Background Why use a modeling tool? Data Elements, Maps, and Value Sets Building Your First Data Model CIMPL Environment Setup Data Elements Header Create an Animal Value Sets Maps Command-Line Arguments Execution and Error Identification CIMPL Outputs FHIR Output Improving your First Data Model Inheritance and Constraints Element inheritance using Based on Constraints Managing Multiple Namespaces Concept Codes CodeSystem Declarations The includes Constraint Inherited Values","title":"Table of Contents"},{"location":"cimpl5Tutorial/#background","text":"This tutorial assumes that you are already comfortable with: Using a code editor (e.g., Visual Studio Code ) Using the command line on a unix-based OS (e.g., Linux, macOS) Data modeling (e.g., what separates a code from a value, what is a codeable concept) Data constraints (e.g., an element SHALL contain a specific code, another element MAY exist)","title":"Background"},{"location":"cimpl5Tutorial/#why-use-a-modeling-tool","text":"It can be difficult for people to jump directly into resource modeling, especially for extensive, domain-specific implementations like FHIR. CIMPL is purpose-built to create clear, concise object models independent of their particular implementations. Abstraction between data models and implementations allows for cleaner code and a more repeatable and understandable process for building implementation code.","title":"Why use a modeling tool?"},{"location":"cimpl5Tutorial/#data-elements-maps-and-value-sets","text":"CIMPL input files are either Data Elements, Maps, or Value Sets. Data Element files are the backbone of your input - they define individual data elements, whether those data elements are nested within other data elements, and the cardinalities of those data elements, among other things Map files dictate how the elements defined in your data model should be represented in a target implementation (for now, FHIR is the only output supported). Value Set files can be used to define custom codes and/or value sets for use in your data models.","title":"Data Elements, Maps, and Value Sets"},{"location":"cimpl5Tutorial/#building-your-first-data-model","text":"Let's get started with a data model using an example. Say we've just purchased a zoo and we want to define a data model for the animal clinic at our new zoo, which could include things like: Animals Staff Facilities Medicines Food etc.","title":"Building Your First Data Model"},{"location":"cimpl5Tutorial/#cimpl-environment-setup","text":"Before we develop any models, let's make sure our environment is set up. If you haven't already done so, follow the CIMPL Installation instructions and check that everything is working using the Hello World test. Create a directory that shares the same parent folder as your shr-cli installation and name it zoo : mkdir ~/cimpl/zoo Your directory structure should look like this: cimpl |- shr-cli |- zoo We'll need to copy some files from the SHR specification into the zoo directory to ensure that the shr-cli tool runs properly. Download the following files and place them in the zoo directory: base_map.txt base.txt core_map.txt core_vs.txt core.txt Your directory structure should now look like this: cimpl |- shr-cli |- zoo |- base_map.txt |- base.txt |- core_map.txt |- core_vs.txt |- core.txt","title":"CIMPL Environment Setup"},{"location":"cimpl5Tutorial/#data-elements-header","text":"The core part of any data model is the definition of its data elements. Many modeling tools use diagrams or database tables to define their data elements, but CIMPL is defined using plain text. Create a file called zoo_animal.txt and open it. To give our zoo_animal.txt file some context, we need to include some header information. Let's start with a line that describes what the file is: Grammar: DataElement 5.0 Every CIMPL file starts by defining the Grammar . The common CIMPL files are DataElement , Map , and ValueSet . We'll get into Map and ValueSet later. This is a DataElement file that is using CIMPL version 5.0 . Next, add your file to a namespace : Grammar: DataElement 5.0 Namespace: zoo.animal The namespace allows you to define a scope for value sets, data elements, and data mappings. By convention, the namespace is period-delimited, with the project ( zoo ) preceding the specific data model that we are defining ( animal ). The filename ( zoo_animal.txt ) doesn't have to match, but it's good practice to keep the two consistent. Filenames should use underscores in place of periods to avoid confusion with file types. While we're at it, let's give this file a description: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Descriptions can include any characters (except quotation marks) and be as long as you need, but it is good practice to keep them short and simple. By default, we'll need to include some basic modeling building blocks with the uses keyword: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base Once our zoo gets more complicated, we will need to add more to the uses statement, but for now we're just including the basic building blocks that all CIMPL models would not want to redefine (e.g., Entry , Quantity , CodeSystem , etc.). Great! That's it for the DataElement file header.","title":"Data Elements Header"},{"location":"cimpl5Tutorial/#create-an-animal","text":"With the header information out of the way, we can start defining our first data element: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal Since we plan to map this element to some output (we'll get into mapping later), we're using the term EntryElement to describe our Animal . Eventually, this element will have data entered directly into it, thus EntryElement and not just Element . Let's add some attributes to our animal: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType We've added four separate attributes to this Animal : DateOfBirth , Name , AnimalType , and DeceasedStatus . Users familiar with traditional cardinality notation for data modeling will notice that the DateOfBirth and DeceasedStatus fields are required and can only appear once, while the AnimalType is optional and our Animal can have an arbitrary number of Name s. CIMPL doesn't know how to interpret these attributes yet, so let's define them as child Element s, starting with DateOfBirth : Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date We've defined DateOfBirth as an Element , added a short Description , and assigned a Value of date , which is one of the primitive data types that CIMPL accepts . CIMPL is whitespace-agnostic, so the indentation is not necessary, but it is good practice to indent child elements underneath their parents. Element s can get more complicated but let's leave it at that. Now that you know the basic structure of an Element , let's define Name and DeceasedStatus (as a string and boolean , respectively): Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Since we want AnimalType to be restricted to a certain set of values, we need to define a custom ValueSet file. Create a file called zoo_animal_vs.txt and open it.","title":"Create an Animal"},{"location":"cimpl5Tutorial/#value-sets","text":"Just like we did for the DataElement file, we need to define some header information for our ValueSet file: Grammar: ValueSet 5.0 Namespace: zoo.animal That's it! Since the ValueSet file is in the same namespace as our DataElement file, we don't need to add a Description or set up inheritance with a Uses statement. Start defining our AnimalType value set by giving it a name: Grammar: ValueSet 5.0 Namespace: zoo.animal ValueSet: AnimalTypeVS // These are the major classes of animal that we want to model. By convention, all value sets should be Pascal case and end with VS . You may notice that we've added a comment to the value set after the double-slash ( // ). CIMPL uses JavaScript comment syntax and you can add comments in your files to give extra context to certain items. They aren't required, but could be helpful later on when you are reviewing the file. With the value set named, let's go ahead and add some values: Grammar: ValueSet 5.0 Namespace: zoo.animal ValueSet: AnimalTypeVS // These are the major classes of animal that we want to model. #invertebrate \"Invertebrates are characterized by their lack of backbones and internal skeletons\" #fish \"Fish breathe using gills, and are equipped with 'lateral lines' that detect water currents and even electricity\" #amphibian \"Amphibians are characterized by their semi-aquatic lifestyles (they have to stay near bodies of water, both to maintain the moisture of their skin and to lay their eggs)\" #reptile \"Reptiles are characterized by their cold-blooded metabolisms, their scaly skin, and their leathery eggs, which, unlike amphibians, they can lay some distance away from bodies of water\" #bird \"Birds are characterized by their coats of feathers, their warm-blooded metabolisms, their memorable songs (at least in certain species), and their ability to adapt to a wide range of habitats\" #mammal \"Mammals are characterized by their hair or fur (which all species possess during some stage of their life cycles), the milk with which they suckle their young, and their warm-blooded metabolisms\" Each value is prefaced by a hash symbol ( # ) and followed by a description enclosed in quotation marks. By convention, each value should use lowercase snake_case formatting . We've defined our custom ValueSet but we still need to add it to our DataElement file, so open zoo_animal.txt and add the full definition for our AnimalType : Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS Now, AnimalType will be restricted to the values defined in our custom value set, thanks to the code from [ValueSet] syntax. That's it! We have defined our DataElement file and a custom ValueSet for AnimalType , so we can map our model to its output. Create a file called zoo_animal_map.txt and open it.","title":"Value Sets"},{"location":"cimpl5Tutorial/#maps","text":"Our data model is fully defined, but we still need to map it to an output format. Currently, CIMPL only supports output to various versions of the FHIR specification . Let's create the file header for our map: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 In this case, we plan to map our data model to FHIR resources, so we are using FHIR_STU_3 as our target model. Next, we map our EntryElement to its FHIR counterpart: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: For our clinic, it makes sense to map animals as Patient resources in FHIR , since they will be the entities receiving care. In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your FHIR output. Let's map our animal attributes. The name and birthDate fields exist in the FHIR Patient resource , so it looks like they will be simple mappings from our Name and DateOfBirth attributes: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: Name maps to name DateOfBirth maps to birthDate The FHIR Patient resource represents the deceased status using the deceased[x] field. The [x] indicates that this field provides a choice of data types; in this case boolean or dateTime . Since our DeceasedStatus element is a boolean value, we can map it to deceased[x] and the CIMPL framework will properly identify it as mapping to the boolean choice: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: Name maps to name DateOfBirth maps to birthDate DeceasedStatus maps to deceased[x] That just leaves AnimalType , which...doesn't seem to fit nicely into any of the fields on the FHIR Patient resource. There are fields for animal.species , animal.breed , and animal.genderStatus , but there isn't anything that maps well to our custom animal class codes. That's okay! If we simply leave off a mapping for the AnimalType , it will be created as an extension on the FHIR Patient resource. More information about FHIR extensions is available in the FHIR documentation. With all of our data elements, custom value sets, and mapping defined for our Animal element, it's time to run the shr-cli tool.","title":"Maps"},{"location":"cimpl5Tutorial/#command-line-arguments","text":"Before we run the shr-cli tool, let's break down the syntax for calling it using the command line: node {location_of_shr_cli_tool} {location_of_cimpl_files} {optional_arguments} node : The shr-cli tool is written in node.js , so we start our statement by calling for that application. {location_of_shr_cli_tool} : Next, we need to tell node which code to run by giving it the directory where the shr-cli tool lives. If you're in the shr-cli directory, you can use a single period ( . ) as a shorthand for that directory. {location_of_cimpl_files} : Now that node has the code it needs to run, we need to give it the directory where our CIMPL files reside. {optional_arguments} : There are a few other options that you can pass to the shr-cli tool. Check the README for all of the possible arguments .","title":"Command-Line Arguments"},{"location":"cimpl5Tutorial/#execution-and-error-identification","text":"Run the shr-cli tool using the following commands: cd ~/cimpl/shr-cli node . ../zoo -o ../zoo/out Uh-oh. You should see the following output: [15:21:21.846Z] INFO shr: Starting CLI Import/Export [15:21:24.435Z] ERROR shr: Mismatched types. Cannot map zoo.animal.Name[Value: string] to [HumanName]. ERROR_CODE:13022 (module=shr-fhir-export, shrId=zoo.animal.Animal, target=Patient, mappingRule=\"Name maps to name\") [15:21:25.410Z] INFO shr: Compiling Documentation for 3 namespaces... (module=shr-json-javadoc) [15:21:25.492Z] INFO shr: Building documentation pages for 31 elements... (module=shr-json-javadoc) [15:21:25.669Z] INFO shr: Finished CLI Import/Export ------------------------------------------------------------ Elapsed time: 3.829s 1 errors (shr-fhir-export) 0 warnings ------------------------------------------------------------ Huh - it looks like we have an error. That's okay! This is pretty common in developing CIMPL files and the output from the shr-cli tool can help us troubleshoot. In, particular, this line tells us where we need to make changes: [15:21:24.435Z] ERROR shr: Mismatched types. Cannot map zoo.animal.Name[Value: string] to [HumanName]. ERROR_CODE:13022 (module=shr-fhir-export, shrId=zoo.animal.Animal, target=Patient, mappingRule=\"Name maps to name\") We defined our Name element as a string , but the name attribute on the FHIR Patient record has the type of HumanName . We have two options: 1. We can redefine the Name element as a HumanName , define the HumanName datatype, and redo the mapping so the Name element is properly mapped to FHIR fields 2. We can remove the mapping from Name to the name attribute on the FHIR patient and allow the Name to be created as an extension Note: for more information about possible errors, see the Error Message Documentation Let's take the easier path of removing the mapping for Name . Change your zoo_animal_map.txt file to: Grammar: Map 5.0 Namespace: zoo.animal Target: FHIR_STU_3 Animal maps to Patient: DateOfBirth maps to birthDate DeceasedStatus maps to deceased[x] With the Name field removed from the mapping, the shr-cli output should run without errors: computer:shr-cli username$ node . ../zoo -o ../zoo/out [18:06:56.010Z] INFO shr: Starting CLI Import/Export [18:07:00.775Z] INFO shr: Compiling Documentation for 3 namespaces... (module=shr-json-javadoc) [18:07:00.881Z] INFO shr: Building documentation pages for 31 elements... (module=shr-json-javadoc) [18:07:01.135Z] INFO shr: Finished CLI Import/Export ------------------------------------------------------------ Elapsed time: 5.136s 0 errors 0 warnings ------------------------------------------------------------ Excellent. You should find that the out directory in your zoo folder now contains quite a bit of material. We'll explore its contents in the next section.","title":"Execution and Error Identification"},{"location":"cimpl5Tutorial/#cimpl-outputs","text":"By default, shr-cli takes CIMPL models and exports files into the following directories (under out/ ): * cimcore : The serialized, machine-readable CIMCORE (Clinical Information Modeling Computable Representation) files representing the CIMPL input. For more information, see the CIMCORE Documentation . * es6 : ES6 JavaScript classes that support interacting with instances of the SHR elements within JS code. Typically, a JavaScript application will load SHR data from a JSON or FHIR format and then represent the entries in memory using these ES6 classes. * fhir : HL7 FHIR ( Fast Healthcare Interoperability Resources ) is an open, international standard for electronic exchange of healthcare information that is governed by HL7. The files in this folder define FHIR profiles, extensions, logical models, value sets, code systems, and the source needed to generate an HL7 FHIR Implementation Guide. * json : A legacy serialization format used to generate parts of standardhealthrecord.org . This format has been deprecated in favor of CIMCORE . * json-schema : JSON schemas used to define and validate the structure of instance data. * modeldoc : Javadoc -style HTML documentation representing the CIMPL data elements. Casual users may find this documentation easier to review than the CIMPL text input files. Each of the generated files in these directories would take a considerable amount of time to create by hand, but CIMPL's concise syntax combined with the shr-cli generators allow for quick initial and subsequent drafts.","title":"CIMPL Outputs"},{"location":"cimpl5Tutorial/#fhir-output","text":"For this tutorial, we will focus on the FHIR output. Open the following file: zoo/out/fhir/profiles/zoo-animal-Animal.json This is a JSON representation of a FHIR profile. It's a bit difficult to read in this form, but we can make it slightly more legible by creating a FHIR Implementation Guide. In the development of FHIR standards, an Implementation Guide is the document that most people review when writing software that includes a data standard. It is a human-readable webpage that can contain multiple profiles, extensions, value sets, code sets, etc. and gives context to how those items should be used in a software application. Let's add some project-specific context to our Implementation Guide. Open the following file: zoo/config.json It should look something like this: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } } Let's edit this file to make it more specific to our project: { \"projectName\": \"We bought a zoo\", \"projectShorthand\": \"ZOO\", \"projectURL\": \"http://thatzoowebought.com\", \"fhirURL\": \"http://thatzoowebought.com/fhir\", \"implementationGuide\": { \"npmName\": \"zoo\", \"version\": \"0.0.1\", \"indexContent\": \"zoo.html\" }, \"publisher\": \"Zoo Owner\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://thatzoowebought.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Zoe the Zoo Owner\", \"organization\": \"Zoo Owner\", \"email\": \"zoe@thatzoowebought.com\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) Zoo Owner <http://thatzoowebought.com>\" } } That's better. Note that we also added two new fields to the implementationGuide object: npmName and version . These are new requirements from the FHIR IG Publisher and haven't yet been integrated into the default config template -- but we need them to successfully run the IG Publisher. You'll also notice that the implementationGuide object's indexContent value references a file named zoo.html . This file contains the HTML content that will always show up on the homepage of your generated Implementation Guide. If you have a mission statement, a project timeline, or other general context for your project, this is a good place to include them. Note that this file will be embedded within the <body> tag of the IG home page, so you should not include <html> , <head> , or <body> tags yourself. Let's create the zoo/zoo.html file with the following contents: <h1>We Bought a Zoo!</h1> <p>In 2018, after coming into an absurd amount of money, we decided to buy a zoo! Now, we need to figure out how to care for all the animals. This Implementation Guide describes the data models for our new zoo clinic IT system.</p> After running the shr-cli tool again, we can generate the IG using HL7's FHIR IG Publishing tool . Run the following commands: cd ~/cimpl/shr-cli cp -r ../zoo/out . yarn run ig:publish Note: if this fails, see the shr-cli README for more detailed instructions on running the FHIR IG generator . Open the following file: ~/cimpl/shr-cli/out/fhir/guide/output/index.html It should look something like this: Let's take a look at the items that CIMPL generated. Click the 'Profiles' link and you should see this: Since we only have one profile, that screen isn't terribly helpful. Click on the 'Animal' link to see the profile we just generated: That's much more helpful. You can see a few of the things we defined in config.json , the Name and AnimalType extensions defined in our mapping, and other bindings and constraints created by the shr-cli tool. For a more compact view of the profiled resource, click on the Differential Table tab: This looks a lot more like the DataElement file. All four of our Animal attributes are present and the AnimalType is explicitly bound to our AnimalTypeVS value set. You may notice that the Type for birthDate is not listed here. That is because it is already explicitly defined on the FHIR Patient resource as a date . This 'Differential Table' view only shows the differences between the generated profile and the FHIR resources on which they are based.","title":"FHIR Output"},{"location":"cimpl5Tutorial/#improving-your-first-data-model","text":"Now that we've built a very simple model for our animals, we can expand it using other aspects of the CIMPL language.","title":"Improving your First Data Model"},{"location":"cimpl5Tutorial/#inheritance-and-constraints","text":"Let's start by making a few more animals in our zoo_animal.txt file: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS EntryElement: Lion Based on: Animal Description: \"The king of the jungle.\" AnimalType is #mammal EntryElement: Shark Based on: Animal Description: \"The king of the ocean.\" AnimalType is #fish EntryElement: Eagle Based on: Animal Description: \"The king of the sky.\" AnimalType is #bird Looks like this zoo has quite the display! We've added three animals to our model ( Lion , Shark , and Eagle ) to show additional CIMPL functionality:","title":"Inheritance and Constraints"},{"location":"cimpl5Tutorial/#element-inheritance-using-based-on","text":"Since all three are animals, we can go ahead and make all three of them Based on on the Animal class we've already defined. This lets Lion , Shark , and Eagle inherit all of the properties of Animal (i.e., DateOfBirth , Name , etc.), so we don't have to redefine them on the more specific animals. This includes mapping inheritance, so if we don't add new fields, we don't have to create new mappings!","title":"Element inheritance using Based on"},{"location":"cimpl5Tutorial/#constraints","text":"We've constrained each of these animals' AnimalType using {element} is {value} to make the model more specific to our creatures. In our AnimalType definition, we established that its code must come from the custom AnimalTypeVS value set. From that value set, the #mammal , #fish , and #bird codes are relevant for those animals. Constraints (e.g., is ) are an important capability in CIMPL that lead to more accurate, specific models. We will keep coming back to this concept, but it will be helpful to refer to the CIMPL documentation .","title":"Constraints"},{"location":"cimpl5Tutorial/#managing-multiple-namespaces","text":"Now that our zoo is full of animals, where do we put them? We haven't defined any enclosures yet, and it wouldn't exactly make sense to put them in the zoo.animal namespace, so let's make a new zoo.facility namespace. Similarly to how we made the zoo.animal namespace, let's go ahead and make a new file called zoo_facility.txt and add header information: Grammar: DataElement 5.0 Namespace: zoo.facility Description: \"Enclosure environments of the zoo\" Uses: shr.core, shr.base Now let's add an Enclosure and some specific types of enclosures: Grammar: DataElement 5.0 Namespace: zoo.facility Description: \"Enclosure environments of the zoo\" Uses: shr.core, shr.base CodeSystem: MTH = http://ncimeta.nci.nih.gov EntryElement: Enclosure Concept: MTH#C2986715 Value: code from EnclosureVS 1..1 Dimensions Dimensions.DimensionComponent includes 1..1 Length includes 1..1 Width EntryElement: Jungle Based on: Enclosure Value is #tropical EntryElement: Aquarium Based on: Enclosure Value is #aquatic EntryElement: Aviary Based on: Enclosure Value is #sky In addition to this new namespace ( zoo.facility ), we've introduced a few new CIMPL concepts:","title":"Managing Multiple Namespaces"},{"location":"cimpl5Tutorial/#concept-codes","text":"Concept codes are numerical codes organized in hierarchies that identify clinical terms. They can be useful for correlating your element with a specific clinical concept but do not impact the structure of your elements or add any specific constraints about how they are used. For instance, the Enclosure can be described by the NCI Metathesaurus code MTH#C2986715 . In the FHIR output, this outputs as StructureDefinition.keyword .","title":"Concept Codes"},{"location":"cimpl5Tutorial/#codesystem-declarations","text":"In order to use that concept code, we must first define the CodeSystem in the header of our file. This allows us to reference the NCI Metathesaurus with the MTH abbrevation. All abbrevations must be uppercase.","title":"CodeSystem Declarations"},{"location":"cimpl5Tutorial/#the-includes-constraint","text":"The Dimensions element includes DimensionComponent values for both a Length and a Width . We don't have to define those elements here, because they are already defined in shr.core . This includes structure is a constraint (specifically the includes type constraint) that allows you to specify members of a list. In this case, since both Length and Width are Based on DimensionComponent and the Dimensions element can include multiple DimensionComponent elements, we are specifying that Dimensions must include both Length and Width (though it may also contain other DimensionComponent elements).","title":"The includes Constraint"},{"location":"cimpl5Tutorial/#inherited-values","text":"In Jungle , Aquarium , and Aviary , we introduce the concept of constraining an inherited Value . While the Enclosure element's Value is constrained to a value set (using code from EnclosureVS ), we can further constrain the Value for Jungle , Aquarium , and Aviary to a specific code using the is keyword (e.g., Value is #sky ). We've used AnimalEnclosureVS but it isn't defined yet. Let's create a new ValueSet file named shr_facility_vs.txt and add that value set: Grammar: ValueSet 5.0 Namespace: zoo.facility ValueSet: EnclosureVS // These are the environments in which our animals live. #tropical \"An environment with average temperature of above 18 degrees Celsius and considerable precipitation during at least part of the year\" #aquatic \"An ecosystem in a body of water\" #sky \"An ecosystem in the sky\" Now, going back to our zoo_animal.txt file, let's add this information to our animals: Grammar: DataElement 5.0 Namespace: zoo.animal Description: \"Animal residents of the zoo\" Uses: shr.core, shr.base, zoo.facility EntryElement: Animal 1..1 DateOfBirth 0..* Name 1..1 DeceasedStatus 0..1 AnimalType 1..* Enclosure Element: DateOfBirth Description: \"A date of birth\" Value: date Element: Name Description: \"A name used to refer to an animal\" Value: string Element: DeceasedStatus Description: \"An indication that the animal is no longer living, given by a boolean value which, when true, indicates the animal is deceased.\" Value: boolean Element: AnimalType Description: \"Classification code of an animal\" Value: code from AnimalTypeVS EntryElement: Lion Based on: Animal Description: \"The king of the jungle.\" AnimalType is #mammal Enclosure is type Jungle EntryElement: Shark Based on: Animal Description: \"The king of the ocean.\" AnimalType is #fish Enclosure is type Aquarium EntryElement: Eagle Based on: Animal Description: \"The king of the sky.\" AnimalType is #bird Enclosure is type Aviary We've made two very important edits: 1. We added the zoo.facility namespace to the Uses statement in the file header, allowing our zoo.animal files to reference any item in the zoo.facility files. 2. We've added Enclosure as a child element of Animal and further constrained the types of enclosure allowed for each of our animals ( Lion , Shark , and Eagle ) using the is type .","title":"Inherited Values"},{"location":"cimpl6Reference/","text":"CIMPL 6.0 Reference Documentation Note: This documentation is in the process of being further expanded and is an actively updating document. This is a comprehensive guide to CIMPL 6.0 syntax. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial . Table of Contents CIMPL 6.0 Reference Documentation General Overview CIMPL File Types Whitespace Naming Conventions File names Namespaces Elements Value Sets Code Sets Ordinality Naming Collisions Versioning Comments Header Grammar Namespace Declaration File Description Uses Url Shorthands Codesystems Data Element File Sample Data Element File Element Name Declaration Property Declaration Fully Qualified Names Concept Code Inheritance Description Fields Value Primitives Field Inherited Field Inherited Value References Field Constraints No Constraint Cardinality Fixed Value Substitute Only Value Set Value Set Binding Required Extensible Preferred Example Includes concept allowable entries Includes Type Array Population Value Set File Value Set Declaration Value Set Description Code-Value Declaration Includes Map File Sample Map File Element Mapping Field Mapping Fix Constrain Slicing Slicing Strategies Declaring a Discriminator** Moving the Slice Location Appendix A: Constraints Summary Cardinality Constraints Subclass Constraints Value Type Constraints Choice Selection Constraints Includes Constraints (Slicing) Fixed Boolean Constraints Fixed Code Constraints Appendix B: Summary of Changes in CIMPL 6.0 Appendix C: Future Architectural Considerations General Overview CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and compact, while coming with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles and implementation guides (IG). CIMPL File Types Whitespace Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 6.0 Namespace: myExampleNamespace ...is equivalent to this: Grammar: DataElement 6.0 Namespace: myExampleNamespace Naming Conventions File names Data Element files: namespace.txt Value Set files: namespace_vs.txt Mapping files: namespace_map.txt Note: \"Any periods in the namespace should be replaced by underscores\" For example: If there is a namespace called odh.occupation , the value set file name could be called odh_occupation_vs.txt . Namespaces A namespace conventionally is denominated by the authoring organization and the broad category of elements the namespace defines, delineated by a period. For example: Namespace: shr.oncology Note: \"The organization name is recommended but not required (e.g., Namespace: oncology is also allowed).\" Elements Elements are conventionally defined in PascalCase . For example: Element: GeologicalLocation Note: \"Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter.\" Value Sets Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: \"It is required that an Value Set name begins with an uppercase letter.\" Code Sets Within a custom value set, the individual codes are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or other radiation source\" #swimming_pool \"Swimming Pool\" Ordinality CIMPL does not enforce or require ordinality in any of its definitions, i.e. an element defined at the bottom of the file can be used as field on an element defined at the top. There is, however, a requirement for a file's header information to be at the top of the file, before any definitions. See: File Headers for more information Naming Collisions CIMPL does not support duplicate element names within a namespace. However, you are allowed to reuse an element name across different namespaces. In the case that you come across a collision due to an included namespace in Uses , you have to refer to the element by its Fully Qualified Name . Versioning CIMPL follows the Semantic Versioning convention (MAJOR.MINOR.PATCH). MAJOR: A breaking change. This is reserved for drastic grammar overhauls. Does not support backwards compatibility to other major version releases. MINOR: Feature updates. Allows for backwards compatability within the major version. PATCH: Minor updates and bug fixes. Allows for backwards compatability within the major version. CIMPL is currently on major version 6. For a full changelog, see the Release Notes . Comments CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */ Header Each CIMPL file contains header information that describes the file type, its scope and inheritance, and its purpose. It also allows developers to create aliases for urls and code systems. An example file type header for a CIMPL Data Element File is shown below: Grammar: DataElement 6.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication Codesystem: LNC = http://loinc.org Grammar The Grammar keyword is used to define the file type and the version of CIMPL used in development/parsing. This is required for all CIMPL files. Keywords Example Grammar Grammar: DataElement 6.0 Grammar Grammar: ValueSet 6.0 Grammar Grammar: Map 6.0 There are three possible options for file type: DataElement ValueSet Mapping The version details the MAJOR and MINOR version the file was written for. The language is backwards compatible within the MAJOR version number, i.e. DataElement 6.0 files will compile without problems on the 5.9.0 tooling. For more information, see Versioning . Namespace Declaration The Namespace keyword defines the scope of the file and serves as a broad grouping of DataElement , ValueSet and Map files within a domain. Keywords Example Namespace Namespace: shr.environment The namespace can be any number of lowercase period delimited words. Best practice is to follow the naming convention pattern of organization . domain (followed by subdomains if necessary). The tooling will not allow for duplicate namespaces. Note: \"While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens\" File Description The Description keyword provides the user the ability to define the purpose of the file, within the confines of a project. Keywords Example Description Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" The namespace description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. Note: \"While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.)\" Uses The Uses keyword provides a list of the namespaces used within the current namespace. Namespace inclusion allows you to use DataElement s and ValueSet s defined in other namespaces. Keywords Example Uses Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication In CIMPL version 6 and below, it is required that you import shr.core and shr.base for the tooling to run. (In the case of name collisions, you will have to indicidate DataElement s by their Fully Qualified Name ). The order of inclusion has no effect. Url Shorthands The Path keyword allows for abbreviations of long urls. Keywords Example Path Path: FHIR = http://hl7.org/fhir/ValueSet This functionality is completely optional, but it is provided to make authoring easier. The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter). Codesystems The Codesystem keyword allows for abbrevations of codesystems. In order to use code systems in a DataElement definition or constraint, it is necessary to first define them in the file header (this is largely due to the complexity of codesystems' direct code references). Keywords Example Codesystem Codesystem: LNC = http://loinc.org You must define each codesystem you use in separate definitions across multiple lines, e.g. Codesystem: LNC = http://loinc.org Codesystem: SCT = http://sct.org The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter) . Data Element File Sample Data Element File Grammar: DataElement 6.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication Codesystem: LNC = http://loinc.org Entry: FinancialSituation Concept: MTH#C0516918 Parent: Panel Description: \"Measures of the ability of the subject to obtain and pay for the necessities of life.\" Value: concept is MTH#C0516918 Property: AnnualIncome 0..1 Property: IncomeSource 0..* PanelCode is LNC#83335-0 Element Name Declaration The Element keyword allows users to define the name of the element and the lines following the Element keyword comprise the definition of that element. Keywords Example Element Element: Observation Entry Entry: FinancialSituation Abstract Abstract: Any Note the spacing discrepancy between Entry and Abstract . This has no semantic meaning but is inherent to the syntax. These keywords are used to define data elements with three different levels of expression in the target output: * Entry is used to define elements that will be used directly by the target output, i.e., data will be entered directly into this item by and end user once it has been mapped. For FHIR exports, these items will be created as 'Primary Profiles' * Element is used to define supporting data elements for Entry s. These data elements will be present in the target output as, but they are not the top-level items that are exported. For FHIR exports, these items will be created as 'Supporting Profiles'. * Abstract is used to define elements that are used only within the CIMPL mapping to create basic objects that will be leveraged by other data elements. They will not be present in the target mapping. Property Declaration The keyword Property is required to define properties for an Entry or Element. Entry: FinancialSituation Concept: MTH#C0516918 Parent: Panel Description: \"Measures of the ability of the subject to obtain and pay for the necessities of life.\" Value: concept is MTH#C0516918 Property: AnnualIncome 0..1 Property: IncomeSource 0..* PanelCode is LNC#83335-0 Fully Qualified Names In addition to its declared name, all elements also have a unique identifying Fully Qualified Name ( FQN ). The FQN is a combination of the element's namespace and its declared name (through concatention delimited by a period). For example, the element Observation in the namespace shr.finding has the following FQN: shr.finding.Observation Note: \"While rare and considered bad practice, naming collisions between elements across multiple namespaces is possible. In the case of a naming collision (such as when a namespace Uses multiple namespaces that define an element with the same declared name), you would have to refer to the specific unique FQN instead of the declared name in element, field, and value definitions.\" Concept Code The Concept keyword is used to define the concept code for the element. These are numerical codes that identify clinical terms, primitive or defined, organized in hierarchies. Keywords Example Concept Concept: MTH#C0516918 Concept codes for the meaning of the defined structure (SNOMED CT and LOINC codes, as an example). While optional, it is recommended you define the concept of an element. To see how it relates to FHIR output, see StructureDefinition.keyword . Inheritance Inheritance provides the parent element from which the properties are inherited. This is designated by the keyword Parent and declares that the class inherits the properties and constraints from another class. This keyword is optional. This works similar to class inheritance in object orientated programming. Additionally, mappings are inherited alongside properties. Keywords Example Parent Parent: Observation Parent Parent: Foo Multiple inheritance is currently removed from CIMPL support. Selective inheritance is achievable through 'zeroing out' inherited properties. See Cardinality Description The textual description of the element. Keywords Example Description Description: \"Measures of the ability of the...\" The element description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. To see how it relates to FHIR output, see StructureDefinition.description . Note: \"While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.)\" Fields Value Defines what the element is. Values can be declared as either a DataElement (e.g., CodeableConcept) or a primitive (e.g., string), as shown here. Keywords Example Value Value: concept Value: string Value is an optional special field on an element that correspond more heavily to what the element is . You are also allowed to constrain the value similar to other fields. On the mapping side, you are able to map the value like any other field. Value defaults to a cardinality of 1..1 , but this can be changed, e.g.: Value: Quantity 0..1 Primitives CIMPL allows users to define fields as the following primitive data types: boolean integer string decimal uri base64Binary instant date dateTime time code oid id markdown unsignedInt positiveInt xhtml Field Object properties on the element. Keywords Example AnnualIncome 0..1 In most cases, you refer to an element by its name. In the rare case of a naming collision, you must refer to it by its Fully Qualified Name . Inherited Field Object properties on the element inherited from the parent or other elements. Keywords Example PanelCode = LNC#83335-0 Inherited Value Object value on the element inherited from the parent or other elements. In CIMPL 6.0, Value shall only be used when referring to the value element inside an Element or Entry where that value is defined, or in mapping the value to a target. Keywords Example Value Value only concept Value from RadiationProtocolVS References CIMPL 6.0 \"References\" Grammar In order to refer to an element as a class (i.e. a pointer as opposed to an instance), you can encapsulate the element name using brackets, [] . This is helpful for defining complex objects with child elements that are already defined as parts of existing data elements. The [] syntax should only encapsulate the element name. All other fields should be applied normally to the group. Note: \"CIMPL 5.0 Grammar use of the keyword ref() is now obsolete and replaced with [] .\" CIMPL 5.0 Grammar CIMPL 6.0 Grammar Remarks SourceSpecimen value is type ref(BreastSpecimen) SourceSpecimen[Specimen] substitute BreastSpecimen DistanceFromLandmark.Distance.Units is UCUM#cm DistanceFromLandmark[Distance].Units = UCUM#cm In this example, Distance is designated as the Value of DistanceFromLandmark . Units is a property of Distance . MLT_TODO: How do we translate the following from CIMPL 5.0 to CIMPL 6.0 Keywords Example ref() 1..1 ref(Role) ref() 0..1 PartOf value is type ref(Organization) ref() Value: ref(Finding) ref() Value: 0..* ref(Observation) ref() can be used to specify that a reference is either the child element of a data element (e.g., 1..1 ref(Role) ) or the Value of an existing child element (e.g., 0..1 PartOf value is type ref(Organization) ). Field Constraints Fields can be constrained to further specify their acceptable values using cardinalities and keywords, e.g.: * = * substitute * from * includes * only No Constraint Fields can exist without any constraints. They can also be constrained to a data type (or set of data types) without further constraining the possible values within that data type. Keywords Example postalCode 0..1 Value: concept Value: unsignedInt or positiveInt Cardinality Cardinality defines the number of instances should exist for a value. The first digit indicates the minimum quantity, and additionally by setting it to 0 or to 1 , has the effect of making a field optional or required. The second digit expresses the upper bound. To express no upper bound, a * can be used in place of a number. When constraining an inherited field, you can only retain the previous cardinality, or constrain it to be narrower. Note : By constraining it to 0..0, you can remove an inherited field from an element. Keywords Example LanguageUsed 0..* GovernmentIssuedID 1..2 Fixed Value Fixed values are designated with an = operator. The is keyword limits the field to a specifc value (e.g., a code , a specific string , or a boolean value). Keywords Example ObservationCode = LNC#82810-3 Note: \"The = operator locks the code for all instances of the data element. If you only need to lock the code for one particular mapping, do so using the fix keyword in the mapping file.\" Substitute The substitute keywords constrains to a subclass of an element or the choices in a given value set. Keywords Example substitute SourceSpecimen[Specimen] substitute BreastSpecimen Use case: If we have an abstract element, and we are making a more specific version of that element, we also want to make its fields more specific. For instance, if we have a DataElement Person which has a field Pet , and we making a more specific person DogOwner and we want to further specify its pet. In this case, we could constrain by using the substitute keyword. For example, Pet substitute Dog . Only The keyword only binds only one logical choice to a property or value. Keywords Example only PlannedProtocol only Protocol _*> Note: \" only shall never be preceded by bracketed term, because intrinsically, it applies to all value choices.\" Value Set The from keyword limits the value of a field to be from a specific value set, with different levels of requirement. Value Set Binding Required ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (required) Indicates that the code must come from the specified value set. No other codes are allowed. Extensible ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (extensible) Indicates that the code must come from the specified value set if the value set contains a relevant code to represent the concept; otherwise a code outside the value set may be chosen. Preferred ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (preferred) Indicates that the code should ideally come from the specified value set, but codes outside the value set may also be chosen. Example ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (example) Indicates that the code may come from anywhere; the specified value set is for example purposes only. The binding strengths correspond to FHIR binding strengths and have the same meaning: Required : To be conformant, the concept in this element SHALL be from the specified value set Preferred : Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant. Example : Instances are not expected or even encouraged to draw from the specified value set. The value set merely provides examples of the types of concepts intended to be included. Extensible : To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated. If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead. Includes concept allowable entries For fields that are already defined with a data type of concept , the includes keyword expands the allowable entries for that field. TODO: Modify the examples below for CIMPL 6.0 Keywords Example includes Category includes LNC#54511-1 \"Behavior\" includes ProblemCategory includes #adverse_reaction The first example above expands Category to include 54511-1 from the LOINC codesystem. Additionally, it is given a brief textual description of \"Behavior\" . The second example above expands the allowable codes in ProblemCategory to include #adverse_reaction . Unlike the first example, the value set does not precede the code, because it has defined on ProblemCategory 's parent using a from statement. Additionally, there is no textual description, as that is optional. Includes Type Specifies the quantity of particular types of objects within the value. Keywords Example includes Foo includes PhysicalActivityLevel 1..1 This is useful in further specifying fields that are analagous to lists. In the above example, the field Foo is required to include 1 PhysicalActivityLevel . Note: \"As of CIMPL 6.0, the use of the Includes keyword for specifying inclusions subclasses or properties is now obsolete and discouraged for use.\" For example, the following statement block is no longer supported. CIMPL 5.0: (no longer supported) Element: VitalSign 1..* BloodPressurePanel includes 1..1 SystolicPressure includes 1..1 DiastolicPressure CIMPL 6.0: Element: VitalSign BloodPressurePanel 1..* SystolicPressure 1..1 DiastolicPressure 1..1 Note: \"The collective cardinality of all inclusions must fit within the field, i.e. if you are including 3 distinct elements, then the field must have a maximum cardinality greater than 3 (like * ).\" Array Population Category += OBSCAT#laboratory Indicates that Category , an element of multiple cardinality, must contain the specified code. The += operator works with any fixed value type. Value Set File The value set files are used to define custom value sets and codes when existing sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient. An example value set file is shown below: Grammar: ValueSet 6.0 Namespace: shr.base ValueSet: ValueAbsentReasonVS Description: \"Reasons that a value associated with a test or other finding is missing.\" Includes codes from DAR #missing_refused \"Human source was asked but declined to respond to the question, or an applicable question was left unanswered.\" #missing_noexplanation \"The reason the information is not present is not known.\" #missing_nonesuch \"The answer is missing because nothing of a type of thing is known to exists, e.g., the siblings of an only child. Also use this code to represent a 'none of the above' answer\" #missing_collection \"Missing due to a problem collecting, identifying, or locating the specimen, including patient refusal or unable to provide specimen\" #missing_specimen \"Missing due to a problem with the specimen, e.g. contamination, clotting, improper tube type, improper storage, too small, etc.\" #missing_malfunction \"Missing due to instrument malfunction.\" Value Set Declaration Defines the name of the value set. Keywords Example ValueSet ValueSet: ProposedStatusVS Note: \"By convention, all value sets should be Pascal case and end with VS .\" Value Set Description Defines the name of the value set. Keywords Example Description Description: \"The status of a proposal.\" Code-Value Declaration Define the code or value. Keywords Example #proposed \"The proposal has been proposed, but not accepted or rejected.\" CAP#29915 \"None/Negative\" Each value is prefaced by a hash symbol ( # ) and followed by a description enclosed in quotation marks. By convention, each value should use lowercase snake_case formatting . This can either be a new user defined code , or it can be individual codes from separate codesystems, such as the CAP#29915 example, in which 29915 is an existing code within the CAP codesystem. Includes Extends a custom defined ValueSet to include codes from other codesystems. Keywords Example Includes Includes codes from MDR Includes and descending from Includes codes descending from SCT#105590001 Includes and descending from and and not descending from Includes codes descending from SCT#105590001 \"Substance\" and not descending from SCT#410942007 \"Drug or medicament\" Map File By default, new elements will appear as FHIR extensions unless the element is mapped to an existing FHIR element. These mapping allow for simpler slicing and fixed values. Sample Map File Grammar: Map 6.0 Namespace: shr.allergy Target: FHIR_STU_3 Condition maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-condition: RelatedEncounter maps to context Informant maps to asserter Subject maps to subject Entry.CreationTime maps to assertedDate Value maps to code Category maps to category ClinicalStatus maps to clinicalStatus Onset[x] maps to onset[x] Abatement[x] maps to abatement[x] BodySiteOrCode[concept] maps to bodySite BodySiteOrCode[BodySite] maps to http://hl7.org/fhir/StructureDefinition/body-structure Severity maps to severity Stage maps to stage Stage.Value maps to stage.summary Evidence maps to evidence Element Mapping Maps a CIMPL element to a target element. Keywords Example maps to FinancialSituation maps to DiagnosticResult: In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. If no FHIR mapping is defined for an element and it inherits no mappings from its parents, it defaults to a mapping to the Basic resource . In general, this is not recommended because it has no inherent semantic meaning for implementers. To promote interoperability and reuse, CIMPL modelers are encouraged to find target models that already exist and use constraints or extensions to modify them according to project needs. Field Mapping Maps a CIMPL element field to a target field. Keywords Example maps to MaritalStatus maps to maritalStatus maps to Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity maps to MultipleBirth[x] maps to multipleBirth[x].boolean maps to Value.ActiveFlag maps to active maps to AdverseReaction.AllergenIrritant maps to reaction.substance maps to BodySiteOrCode[concept] maps to bodySite In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. With FHIR as the target output, the right-hand side of the map statement can point to any field on a FHIR resource, including: * Fields that are at the root of the resource (e.g., maritalStatus ) * Fields that are child elements of root elements on the resource (e.g., reaction.substance ) * Fields that have a choice of data types (e.g., multipleBirth[x].boolean ) * Fields that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity ) Fix Similar to the is keyword, the fix keyword allows for FHIR fields to be locked to a certain value. It is helpful for locking field values in specific mappings (instead of in the DataElement definition, which would be locked for all potential mappings). Keywords Example fix fix status to #completed Note about syntax: The element being fixed on left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any code or primitive value to be fixed. Constrain The constrain keyword allows users to constrain the cardinality of elements in output files. Keywords Example constrain constrain explanation to 0..1 Note about syntax: The element being fixed on the left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any cardinality . Slicing When fields are allowed to repeat on a target model (e.g., have cardinality with an upper bound greater than 1), it is common practice to specify which CIMPL elements are mapped to instances of that repeated field on the target model. This process is called slicing . For example, the FHIR Task resource allows for an arbitrary number of input fields to be added. To ensure that all each of the input fields is uniquely addressable by a parsing engine, those inputs need to be differentiated by a discriminator . See the FHIR documentation for more detail about slicing and discriminators Slicing Strategies Slicing is used when there is a variation of how an individual element is represented and a need to model it as a sub-list. An example of this is the FHIR Blood Pressure profile , which can be considered an observation with two components which are identical in structure other than their represented code. In CIMPL, slicing strategies are specified in the map file. Two keywords are used in conjunction to specify the slide: slice on slice strategy Examples of its usage in a statement are shown below: Keywords Example slice on / slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) slice on / slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) slice on Laterality maps to qualifier (slice on = concept) Declaring a Discriminator** To perform any slicing, a discriminator needs to be declared, using slice on followed by the discriminator. CIMPL supports the FHIR processing types for discriminators: Discriminator Definition value The slices have different values in the nominated element exists The slices are differentiated by the presence or absence of the nominated element pattern The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x] type The slices are differentiated by type of the nominated element to a specifed profile profile The slices are differentiated by conformance of the nominated element to a specifed profile Moving the Slice Location If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Keywords Example slice at Members.Observation maps to related.target (slice at = related; slice on type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occuring at related.target . Instead, the slice at = related ensures that the slicing is occuring at the related element. Appendix A: Constraints Summary Cardinality Constraints ReferenceRange 0..0 Narrows the cardinality of a field inherited from a base class. Common examples are making an optional field required ( 0..1 to 1..1 ) or prohibiting an optional field ( 0..1 to 0..0 ). Subclass Constraints Specimen substitute BreastSpecimen Indicates that the data type of an inherited field should be restricted to a certain subclass of the originally-declared data type. Value Type Constraints Stage.StageDetail[Observation] only CancerStage Indicates that an inherited field's value should be substituted with a more specific child type. Choice Selection Constraints FindingResult only IntegerQuantity Indicates that an inherited field's value , which is a choice of types, should be a specific type selected from the choices. Note that it is also possible to select a child type of one of the choice types. Includes Constraints (Slicing) BloodPressure.ObservationComponent 0..* includes SystolicPressure 0..1 includes DiastolicPressure 0..1 Indicates that a field with multiple cardinality should be populated with specific child types. Each child type can be assigned its own cardinality as long as the combined cardinalities still fit within the field's total cardinality. Fixed Boolean Constraints WasNotGiven = true Indicates that a boolean field must be a specific value (either true or false ). Fixed Code Constraints Vaccine = CVX#36 \"VZIG\" Value[Quantity].Units = UCUM#cm Indicates the named property must be given as the specified code. You are allowed to include from either a codesystem or a specific code from a codesystem. Appendix B: Summary of Changes in CIMPL 6.0 For those who have created detailed models using CIMPL 5.0, there have been significant grammar changes to CIMPL 6.0. The table below summarizes these changes: Change Type Change Description CIMPL 5.0 Example CIMPL 6.0 Example Section New keyword field constraint only binds only one data type to a property None FindingResult only concept Only New keyword Property is required to define properties for an Entry or Element. 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Declaration Replace EntryElement keyword replaced by Entry EntryElement: CourseOfTreatmentPerformed Entry: CourseOfTreatmentPerformed Element Name Declaration Replace Based on keyword replaced by Parent Based on: Observation Parent: Observation Inheritance Syntax change Cardinality is specified after the property or class name 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Cardinality Replace is constraint for fixed values replaced by = FindingTopicCode is LNC#48676-1 FindingTopicCode is LNC#48676-1 Field Constraints Replace substitution of a more specific element derived from a parent element using is type keyword replaced by substitute . None Specimen substitute BreastSpecimen Substitute Replace code , Coding , and CodeableConcept primitives are replaced by a new primitive concept Value: CodeableConcept from AttributionCategoryVS Value: concept from AttributionCategoryVS Primitives Replace must be , should be , could be , and if covered value set constraints are obsolete and replaced by (required) , (preferred) , (extensible) , and (example) Type from BreastSpecimenTypeVS if covered Type from BreastSpecimenTypeVS (required) Value Set Replace ref() is now obsolete and replaced with [] . SourceSpecimen value is type ref(BreastSpecimen) SourceSpecimen[Specimen] substitute BreastSpecimen References Note: \"As of CIMPL 6.0, must be , should be , could be , and if covered value set constraints are obsolete and replaced by (required) , (preferred) , (extensible) , and (example) \" CIMPL 5.0 Example CIMPL 6.0 Example Binding Strength from Substance from SubstanceOfAbuseVS Required Priority must be from http://hl7.org/fhir/ValueSet/request-priority Priority from http://hl7.org/fhir/ValueSet/request-priority (required) Required 1..1 Status should be from http://hl7.org/fhir/ValueSet/event-status 1..1 Status from http://hl7.org/fhir/ValueSet/event-status (preferred) Preferred CodeableConcept could be from http://hl7.org/fhir/ValueSet/medication-as-needed-reason concept from http://hl7.org/fhir/ValueSet/medication-as-needed-reason (example) Example Category from http://hl7.org/fhir/ValueSet/goal-category if covered Category from http://hl7.org/fhir/ValueSet/goal-category (extensible) Extensible Appendix C: Future Architectural Considerations To what extent is the shr-cli tool specific to SHR versus a general purpose modeling tool (e.g., for Death Reporting Are there any plans to support output of Open API Specification files? Inclusive output generation, for people that only care about generating FHIR profiles and don't want to wait for other docs to generate","title":"CIMPL 6.0 Reference Documentation"},{"location":"cimpl6Reference/#cimpl-60-reference-documentation","text":"Note: This documentation is in the process of being further expanded and is an actively updating document. This is a comprehensive guide to CIMPL 6.0 syntax. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for a more in-depth introduction, try the Tutorial . Table of Contents CIMPL 6.0 Reference Documentation General Overview CIMPL File Types Whitespace Naming Conventions File names Namespaces Elements Value Sets Code Sets Ordinality Naming Collisions Versioning Comments Header Grammar Namespace Declaration File Description Uses Url Shorthands Codesystems Data Element File Sample Data Element File Element Name Declaration Property Declaration Fully Qualified Names Concept Code Inheritance Description Fields Value Primitives Field Inherited Field Inherited Value References Field Constraints No Constraint Cardinality Fixed Value Substitute Only Value Set Value Set Binding Required Extensible Preferred Example Includes concept allowable entries Includes Type Array Population Value Set File Value Set Declaration Value Set Description Code-Value Declaration Includes Map File Sample Map File Element Mapping Field Mapping Fix Constrain Slicing Slicing Strategies Declaring a Discriminator** Moving the Slice Location Appendix A: Constraints Summary Cardinality Constraints Subclass Constraints Value Type Constraints Choice Selection Constraints Includes Constraints (Slicing) Fixed Boolean Constraints Fixed Code Constraints Appendix B: Summary of Changes in CIMPL 6.0 Appendix C: Future Architectural Considerations","title":"CIMPL 6.0 Reference Documentation"},{"location":"cimpl6Reference/#general-overview","text":"CIMPL ( C linical I nformation M odeling P rofiling L anguage) is a domain specific language for defining clinical information models. It was designed to be simple and compact, while coming with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles and implementation guides (IG).","title":"General Overview"},{"location":"cimpl6Reference/#cimpl-file-types","text":"","title":"CIMPL File Types"},{"location":"cimpl6Reference/#whitespace","text":"Repeated whitespace is generally not meaningful within CIMPL files. So this: Grammar: DataElement 6.0 Namespace: myExampleNamespace ...is equivalent to this: Grammar: DataElement 6.0 Namespace: myExampleNamespace","title":"Whitespace"},{"location":"cimpl6Reference/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"cimpl6Reference/#file-names","text":"Data Element files: namespace.txt Value Set files: namespace_vs.txt Mapping files: namespace_map.txt Note: \"Any periods in the namespace should be replaced by underscores\" For example: If there is a namespace called odh.occupation , the value set file name could be called odh_occupation_vs.txt .","title":"File names"},{"location":"cimpl6Reference/#namespaces","text":"A namespace conventionally is denominated by the authoring organization and the broad category of elements the namespace defines, delineated by a period. For example: Namespace: shr.oncology Note: \"The organization name is recommended but not required (e.g., Namespace: oncology is also allowed).\"","title":"Namespaces"},{"location":"cimpl6Reference/#elements","text":"Elements are conventionally defined in PascalCase . For example: Element: GeologicalLocation Note: \"Letters, numbers, and hyphens are allowed. However, it is required that an element name begins with an uppercase letter.\"","title":"Elements"},{"location":"cimpl6Reference/#value-sets","text":"Value Sets are conventionally defined in PascalCase , with an additional \"VS\" suffix. For example: ValueSet: HomeEnvironmentRiskVS Note: \"It is required that an Value Set name begins with an uppercase letter.\"","title":"Value Sets"},{"location":"cimpl6Reference/#code-sets","text":"Within a custom value set, the individual codes are conventionally written in lowercase snake_case . For example: ValueSet: HomeEnvironmentRiskVS #smoke_detectors \"No Smoke Detectors\" #radiation \"Radon or other radiation source\" #swimming_pool \"Swimming Pool\"","title":"Code Sets"},{"location":"cimpl6Reference/#ordinality","text":"CIMPL does not enforce or require ordinality in any of its definitions, i.e. an element defined at the bottom of the file can be used as field on an element defined at the top. There is, however, a requirement for a file's header information to be at the top of the file, before any definitions. See: File Headers for more information","title":"Ordinality"},{"location":"cimpl6Reference/#naming-collisions","text":"CIMPL does not support duplicate element names within a namespace. However, you are allowed to reuse an element name across different namespaces. In the case that you come across a collision due to an included namespace in Uses , you have to refer to the element by its Fully Qualified Name .","title":"Naming Collisions"},{"location":"cimpl6Reference/#versioning","text":"CIMPL follows the Semantic Versioning convention (MAJOR.MINOR.PATCH). MAJOR: A breaking change. This is reserved for drastic grammar overhauls. Does not support backwards compatibility to other major version releases. MINOR: Feature updates. Allows for backwards compatability within the major version. PATCH: Minor updates and bug fixes. Allows for backwards compatability within the major version. CIMPL is currently on major version 6. For a full changelog, see the Release Notes .","title":"Versioning"},{"location":"cimpl6Reference/#comments","text":"CIMPL follows JavaScript syntax for code comments: // Use a double-slash for comments on a single line /* Use slash-asterisk and asterisk-slash for larger block comments. These comments can take up multiple lines. */","title":"Comments"},{"location":"cimpl6Reference/#header","text":"Each CIMPL file contains header information that describes the file type, its scope and inheritance, and its purpose. It also allows developers to create aliases for urls and code systems. An example file type header for a CIMPL Data Element File is shown below: Grammar: DataElement 6.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication Codesystem: LNC = http://loinc.org","title":"Header"},{"location":"cimpl6Reference/#grammar","text":"The Grammar keyword is used to define the file type and the version of CIMPL used in development/parsing. This is required for all CIMPL files. Keywords Example Grammar Grammar: DataElement 6.0 Grammar Grammar: ValueSet 6.0 Grammar Grammar: Map 6.0 There are three possible options for file type: DataElement ValueSet Mapping The version details the MAJOR and MINOR version the file was written for. The language is backwards compatible within the MAJOR version number, i.e. DataElement 6.0 files will compile without problems on the 5.9.0 tooling. For more information, see Versioning .","title":"Grammar"},{"location":"cimpl6Reference/#namespace-declaration","text":"The Namespace keyword defines the scope of the file and serves as a broad grouping of DataElement , ValueSet and Map files within a domain. Keywords Example Namespace Namespace: shr.environment The namespace can be any number of lowercase period delimited words. Best practice is to follow the naming convention pattern of organization . domain (followed by subdomains if necessary). The tooling will not allow for duplicate namespaces. Note: \"While it is best practice to use only lower case letters, the strict requirements only require the word to begin with a lowercase letter. The rest of the namespace allows for mixed casing and hyphens\"","title":"Namespace Declaration"},{"location":"cimpl6Reference/#file-description","text":"The Description keyword provides the user the ability to define the purpose of the file, within the confines of a project. Keywords Example Description Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" The namespace description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. Note: \"While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.)\"","title":"File Description"},{"location":"cimpl6Reference/#uses","text":"The Uses keyword provides a list of the namespaces used within the current namespace. Namespace inclusion allows you to use DataElement s and ValueSet s defined in other namespaces. Keywords Example Uses Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication In CIMPL version 6 and below, it is required that you import shr.core and shr.base for the tooling to run. (In the case of name collisions, you will have to indicidate DataElement s by their Fully Qualified Name ). The order of inclusion has no effect.","title":"Uses"},{"location":"cimpl6Reference/#url-shorthands","text":"The Path keyword allows for abbreviations of long urls. Keywords Example Path Path: FHIR = http://hl7.org/fhir/ValueSet This functionality is completely optional, but it is provided to make authoring easier. The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter).","title":"Url Shorthands"},{"location":"cimpl6Reference/#codesystems","text":"The Codesystem keyword allows for abbrevations of codesystems. In order to use code systems in a DataElement definition or constraint, it is necessary to first define them in the file header (this is largely due to the complexity of codesystems' direct code references). Keywords Example Codesystem Codesystem: LNC = http://loinc.org You must define each codesystem you use in separate definitions across multiple lines, e.g. Codesystem: LNC = http://loinc.org Codesystem: SCT = http://sct.org The abbreviation by convention should be be an all UPPER CASE word. (Although, the tooling does allow for numbers and hyphens after the first letter) .","title":"Codesystems"},{"location":"cimpl6Reference/#data-element-file","text":"","title":"Data Element File"},{"location":"cimpl6Reference/#sample-data-element-file","text":"Grammar: DataElement 6.0 Namespace: shr.environment Description: \"The SHR Environment domain contains definitions related to surroundings experienced by the person of record.\" Uses: shr.core, shr.base, shr.allergy, shr.observation, shr.medication Codesystem: LNC = http://loinc.org Entry: FinancialSituation Concept: MTH#C0516918 Parent: Panel Description: \"Measures of the ability of the subject to obtain and pay for the necessities of life.\" Value: concept is MTH#C0516918 Property: AnnualIncome 0..1 Property: IncomeSource 0..* PanelCode is LNC#83335-0","title":"Sample Data Element File"},{"location":"cimpl6Reference/#element-name-declaration","text":"The Element keyword allows users to define the name of the element and the lines following the Element keyword comprise the definition of that element. Keywords Example Element Element: Observation Entry Entry: FinancialSituation Abstract Abstract: Any Note the spacing discrepancy between Entry and Abstract . This has no semantic meaning but is inherent to the syntax. These keywords are used to define data elements with three different levels of expression in the target output: * Entry is used to define elements that will be used directly by the target output, i.e., data will be entered directly into this item by and end user once it has been mapped. For FHIR exports, these items will be created as 'Primary Profiles' * Element is used to define supporting data elements for Entry s. These data elements will be present in the target output as, but they are not the top-level items that are exported. For FHIR exports, these items will be created as 'Supporting Profiles'. * Abstract is used to define elements that are used only within the CIMPL mapping to create basic objects that will be leveraged by other data elements. They will not be present in the target mapping.","title":"Element Name Declaration"},{"location":"cimpl6Reference/#property-declaration","text":"The keyword Property is required to define properties for an Entry or Element. Entry: FinancialSituation Concept: MTH#C0516918 Parent: Panel Description: \"Measures of the ability of the subject to obtain and pay for the necessities of life.\" Value: concept is MTH#C0516918 Property: AnnualIncome 0..1 Property: IncomeSource 0..* PanelCode is LNC#83335-0","title":"Property Declaration"},{"location":"cimpl6Reference/#fully-qualified-names","text":"In addition to its declared name, all elements also have a unique identifying Fully Qualified Name ( FQN ). The FQN is a combination of the element's namespace and its declared name (through concatention delimited by a period). For example, the element Observation in the namespace shr.finding has the following FQN: shr.finding.Observation Note: \"While rare and considered bad practice, naming collisions between elements across multiple namespaces is possible. In the case of a naming collision (such as when a namespace Uses multiple namespaces that define an element with the same declared name), you would have to refer to the specific unique FQN instead of the declared name in element, field, and value definitions.\"","title":"Fully Qualified Names"},{"location":"cimpl6Reference/#concept-code","text":"The Concept keyword is used to define the concept code for the element. These are numerical codes that identify clinical terms, primitive or defined, organized in hierarchies. Keywords Example Concept Concept: MTH#C0516918 Concept codes for the meaning of the defined structure (SNOMED CT and LOINC codes, as an example). While optional, it is recommended you define the concept of an element. To see how it relates to FHIR output, see StructureDefinition.keyword .","title":"Concept Code"},{"location":"cimpl6Reference/#inheritance","text":"Inheritance provides the parent element from which the properties are inherited. This is designated by the keyword Parent and declares that the class inherits the properties and constraints from another class. This keyword is optional. This works similar to class inheritance in object orientated programming. Additionally, mappings are inherited alongside properties. Keywords Example Parent Parent: Observation Parent Parent: Foo Multiple inheritance is currently removed from CIMPL support. Selective inheritance is achievable through 'zeroing out' inherited properties. See Cardinality","title":"Inheritance"},{"location":"cimpl6Reference/#description","text":"The textual description of the element. Keywords Example Description Description: \"Measures of the ability of the...\" The element description is optional, but recommended. Best practice is to write human readable text using the ASCII standard. There is no strict requirement for unique descriptions, and as such you will not run into description collisions. To see how it relates to FHIR output, see StructureDefinition.description . Note: \"While the CIMPL tooling will allow for any pattern of Unicode characters within enclosed double quotation marks ( \" ), certain exporters such as the FHIR exporter will object to non- ASCII text.)\"","title":"Description"},{"location":"cimpl6Reference/#fields","text":"","title":"Fields"},{"location":"cimpl6Reference/#value","text":"Defines what the element is. Values can be declared as either a DataElement (e.g., CodeableConcept) or a primitive (e.g., string), as shown here. Keywords Example Value Value: concept Value: string Value is an optional special field on an element that correspond more heavily to what the element is . You are also allowed to constrain the value similar to other fields. On the mapping side, you are able to map the value like any other field. Value defaults to a cardinality of 1..1 , but this can be changed, e.g.: Value: Quantity 0..1","title":"Value"},{"location":"cimpl6Reference/#primitives","text":"CIMPL allows users to define fields as the following primitive data types: boolean integer string decimal uri base64Binary instant date dateTime time code oid id markdown unsignedInt positiveInt xhtml","title":"Primitives"},{"location":"cimpl6Reference/#field","text":"Object properties on the element. Keywords Example AnnualIncome 0..1 In most cases, you refer to an element by its name. In the rare case of a naming collision, you must refer to it by its Fully Qualified Name .","title":"Field"},{"location":"cimpl6Reference/#inherited-field","text":"Object properties on the element inherited from the parent or other elements. Keywords Example PanelCode = LNC#83335-0","title":"Inherited Field"},{"location":"cimpl6Reference/#inherited-value","text":"Object value on the element inherited from the parent or other elements. In CIMPL 6.0, Value shall only be used when referring to the value element inside an Element or Entry where that value is defined, or in mapping the value to a target. Keywords Example Value Value only concept Value from RadiationProtocolVS","title":"Inherited Value"},{"location":"cimpl6Reference/#references","text":"CIMPL 6.0 \"References\" Grammar In order to refer to an element as a class (i.e. a pointer as opposed to an instance), you can encapsulate the element name using brackets, [] . This is helpful for defining complex objects with child elements that are already defined as parts of existing data elements. The [] syntax should only encapsulate the element name. All other fields should be applied normally to the group. Note: \"CIMPL 5.0 Grammar use of the keyword ref() is now obsolete and replaced with [] .\" CIMPL 5.0 Grammar CIMPL 6.0 Grammar Remarks SourceSpecimen value is type ref(BreastSpecimen) SourceSpecimen[Specimen] substitute BreastSpecimen DistanceFromLandmark.Distance.Units is UCUM#cm DistanceFromLandmark[Distance].Units = UCUM#cm In this example, Distance is designated as the Value of DistanceFromLandmark . Units is a property of Distance . MLT_TODO: How do we translate the following from CIMPL 5.0 to CIMPL 6.0 Keywords Example ref() 1..1 ref(Role) ref() 0..1 PartOf value is type ref(Organization) ref() Value: ref(Finding) ref() Value: 0..* ref(Observation) ref() can be used to specify that a reference is either the child element of a data element (e.g., 1..1 ref(Role) ) or the Value of an existing child element (e.g., 0..1 PartOf value is type ref(Organization) ).","title":"References"},{"location":"cimpl6Reference/#field-constraints","text":"Fields can be constrained to further specify their acceptable values using cardinalities and keywords, e.g.: * = * substitute * from * includes * only","title":"Field Constraints"},{"location":"cimpl6Reference/#no-constraint","text":"Fields can exist without any constraints. They can also be constrained to a data type (or set of data types) without further constraining the possible values within that data type. Keywords Example postalCode 0..1 Value: concept Value: unsignedInt or positiveInt","title":"No Constraint"},{"location":"cimpl6Reference/#cardinality","text":"Cardinality defines the number of instances should exist for a value. The first digit indicates the minimum quantity, and additionally by setting it to 0 or to 1 , has the effect of making a field optional or required. The second digit expresses the upper bound. To express no upper bound, a * can be used in place of a number. When constraining an inherited field, you can only retain the previous cardinality, or constrain it to be narrower. Note : By constraining it to 0..0, you can remove an inherited field from an element. Keywords Example LanguageUsed 0..* GovernmentIssuedID 1..2","title":"Cardinality"},{"location":"cimpl6Reference/#fixed-value","text":"Fixed values are designated with an = operator. The is keyword limits the field to a specifc value (e.g., a code , a specific string , or a boolean value). Keywords Example ObservationCode = LNC#82810-3 Note: \"The = operator locks the code for all instances of the data element. If you only need to lock the code for one particular mapping, do so using the fix keyword in the mapping file.\"","title":"Fixed Value"},{"location":"cimpl6Reference/#substitute","text":"The substitute keywords constrains to a subclass of an element or the choices in a given value set. Keywords Example substitute SourceSpecimen[Specimen] substitute BreastSpecimen Use case: If we have an abstract element, and we are making a more specific version of that element, we also want to make its fields more specific. For instance, if we have a DataElement Person which has a field Pet , and we making a more specific person DogOwner and we want to further specify its pet. In this case, we could constrain by using the substitute keyword. For example, Pet substitute Dog .","title":"Substitute"},{"location":"cimpl6Reference/#only","text":"The keyword only binds only one logical choice to a property or value. Keywords Example only PlannedProtocol only Protocol _*> Note: \" only shall never be preceded by bracketed term, because intrinsically, it applies to all value choices.\"","title":"Only"},{"location":"cimpl6Reference/#value-set","text":"The from keyword limits the value of a field to be from a specific value set, with different levels of requirement.","title":"Value Set"},{"location":"cimpl6Reference/#value-set-binding","text":"","title":"Value Set Binding"},{"location":"cimpl6Reference/#required","text":"ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (required) Indicates that the code must come from the specified value set. No other codes are allowed.","title":"Required"},{"location":"cimpl6Reference/#extensible","text":"ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (extensible) Indicates that the code must come from the specified value set if the value set contains a relevant code to represent the concept; otherwise a code outside the value set may be chosen.","title":"Extensible"},{"location":"cimpl6Reference/#preferred","text":"ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (preferred) Indicates that the code should ideally come from the specified value set, but codes outside the value set may also be chosen.","title":"Preferred"},{"location":"cimpl6Reference/#example","text":"ClinicalStatus from http://hl7.org/fhir/ValueSet/condition-clinical (example) Indicates that the code may come from anywhere; the specified value set is for example purposes only. The binding strengths correspond to FHIR binding strengths and have the same meaning: Required : To be conformant, the concept in this element SHALL be from the specified value set Preferred : Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant. Example : Instances are not expected or even encouraged to draw from the specified value set. The value set merely provides examples of the types of concepts intended to be included. Extensible : To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated. If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead.","title":"Example"},{"location":"cimpl6Reference/#includes-concept-allowable-entries","text":"For fields that are already defined with a data type of concept , the includes keyword expands the allowable entries for that field. TODO: Modify the examples below for CIMPL 6.0 Keywords Example includes Category includes LNC#54511-1 \"Behavior\" includes ProblemCategory includes #adverse_reaction The first example above expands Category to include 54511-1 from the LOINC codesystem. Additionally, it is given a brief textual description of \"Behavior\" . The second example above expands the allowable codes in ProblemCategory to include #adverse_reaction . Unlike the first example, the value set does not precede the code, because it has defined on ProblemCategory 's parent using a from statement. Additionally, there is no textual description, as that is optional.","title":"Includes concept allowable entries"},{"location":"cimpl6Reference/#includes-type","text":"Specifies the quantity of particular types of objects within the value. Keywords Example includes Foo includes PhysicalActivityLevel 1..1 This is useful in further specifying fields that are analagous to lists. In the above example, the field Foo is required to include 1 PhysicalActivityLevel . Note: \"As of CIMPL 6.0, the use of the Includes keyword for specifying inclusions subclasses or properties is now obsolete and discouraged for use.\" For example, the following statement block is no longer supported. CIMPL 5.0: (no longer supported) Element: VitalSign 1..* BloodPressurePanel includes 1..1 SystolicPressure includes 1..1 DiastolicPressure CIMPL 6.0: Element: VitalSign BloodPressurePanel 1..* SystolicPressure 1..1 DiastolicPressure 1..1 Note: \"The collective cardinality of all inclusions must fit within the field, i.e. if you are including 3 distinct elements, then the field must have a maximum cardinality greater than 3 (like * ).\"","title":"Includes Type"},{"location":"cimpl6Reference/#array-population","text":"Category += OBSCAT#laboratory Indicates that Category , an element of multiple cardinality, must contain the specified code. The += operator works with any fixed value type.","title":"Array Population"},{"location":"cimpl6Reference/#value-set-file","text":"The value set files are used to define custom value sets and codes when existing sources like HL7 v3 , FHIR , VSAC , or PHIN VADS are insufficient. An example value set file is shown below: Grammar: ValueSet 6.0 Namespace: shr.base ValueSet: ValueAbsentReasonVS Description: \"Reasons that a value associated with a test or other finding is missing.\" Includes codes from DAR #missing_refused \"Human source was asked but declined to respond to the question, or an applicable question was left unanswered.\" #missing_noexplanation \"The reason the information is not present is not known.\" #missing_nonesuch \"The answer is missing because nothing of a type of thing is known to exists, e.g., the siblings of an only child. Also use this code to represent a 'none of the above' answer\" #missing_collection \"Missing due to a problem collecting, identifying, or locating the specimen, including patient refusal or unable to provide specimen\" #missing_specimen \"Missing due to a problem with the specimen, e.g. contamination, clotting, improper tube type, improper storage, too small, etc.\" #missing_malfunction \"Missing due to instrument malfunction.\"","title":"Value Set File"},{"location":"cimpl6Reference/#value-set-declaration","text":"Defines the name of the value set. Keywords Example ValueSet ValueSet: ProposedStatusVS Note: \"By convention, all value sets should be Pascal case and end with VS .\"","title":"Value Set Declaration"},{"location":"cimpl6Reference/#value-set-description","text":"Defines the name of the value set. Keywords Example Description Description: \"The status of a proposal.\"","title":"Value Set Description"},{"location":"cimpl6Reference/#code-value-declaration","text":"Define the code or value. Keywords Example #proposed \"The proposal has been proposed, but not accepted or rejected.\" CAP#29915 \"None/Negative\" Each value is prefaced by a hash symbol ( # ) and followed by a description enclosed in quotation marks. By convention, each value should use lowercase snake_case formatting . This can either be a new user defined code , or it can be individual codes from separate codesystems, such as the CAP#29915 example, in which 29915 is an existing code within the CAP codesystem.","title":"Code-Value Declaration"},{"location":"cimpl6Reference/#includes","text":"Extends a custom defined ValueSet to include codes from other codesystems. Keywords Example Includes Includes codes from MDR Includes and descending from Includes codes descending from SCT#105590001 Includes and descending from and and not descending from Includes codes descending from SCT#105590001 \"Substance\" and not descending from SCT#410942007 \"Drug or medicament\"","title":"Includes"},{"location":"cimpl6Reference/#map-file","text":"By default, new elements will appear as FHIR extensions unless the element is mapped to an existing FHIR element. These mapping allow for simpler slicing and fixed values.","title":"Map File"},{"location":"cimpl6Reference/#sample-map-file","text":"Grammar: Map 6.0 Namespace: shr.allergy Target: FHIR_STU_3 Condition maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-condition: RelatedEncounter maps to context Informant maps to asserter Subject maps to subject Entry.CreationTime maps to assertedDate Value maps to code Category maps to category ClinicalStatus maps to clinicalStatus Onset[x] maps to onset[x] Abatement[x] maps to abatement[x] BodySiteOrCode[concept] maps to bodySite BodySiteOrCode[BodySite] maps to http://hl7.org/fhir/StructureDefinition/body-structure Severity maps to severity Stage maps to stage Stage.Value maps to stage.summary Evidence maps to evidence","title":"Sample Map File"},{"location":"cimpl6Reference/#element-mapping","text":"Maps a CIMPL element to a target element. Keywords Example maps to FinancialSituation maps to DiagnosticResult: In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. If no FHIR mapping is defined for an element and it inherits no mappings from its parents, it defaults to a mapping to the Basic resource . In general, this is not recommended because it has no inherent semantic meaning for implementers. To promote interoperability and reuse, CIMPL modelers are encouraged to find target models that already exist and use constraints or extensions to modify them according to project needs.","title":"Element Mapping"},{"location":"cimpl6Reference/#field-mapping","text":"Maps a CIMPL element field to a target field. Keywords Example maps to MaritalStatus maps to maritalStatus maps to Ethnicity maps to http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity maps to MultipleBirth[x] maps to multipleBirth[x].boolean maps to Value.ActiveFlag maps to active maps to AdverseReaction.AllergenIrritant maps to reaction.substance maps to BodySiteOrCode[concept] maps to bodySite In CIMPL map files, the item to the left of maps to comes from your CIMPL data model and the item to the right is an element in your target output. With FHIR as the target output, the right-hand side of the map statement can point to any field on a FHIR resource, including: * Fields that are at the root of the resource (e.g., maritalStatus ) * Fields that are child elements of root elements on the resource (e.g., reaction.substance ) * Fields that have a choice of data types (e.g., multipleBirth[x].boolean ) * Fields that have been defined in existing profiles or other StructureDefinition resources (e.g., http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity )","title":"Field Mapping"},{"location":"cimpl6Reference/#fix","text":"Similar to the is keyword, the fix keyword allows for FHIR fields to be locked to a certain value. It is helpful for locking field values in specific mappings (instead of in the DataElement definition, which would be locked for all potential mappings). Keywords Example fix fix status to #completed Note about syntax: The element being fixed on left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any code or primitive value to be fixed.","title":"Fix"},{"location":"cimpl6Reference/#constrain","text":"The constrain keyword allows users to constrain the cardinality of elements in output files. Keywords Example constrain constrain explanation to 0..1 Note about syntax: The element being fixed on the left hand side of this syntax is a FHIR element, not a CIMPL element. The right hand syntax allows for any cardinality .","title":"Constrain"},{"location":"cimpl6Reference/#slicing","text":"When fields are allowed to repeat on a target model (e.g., have cardinality with an upper bound greater than 1), it is common practice to specify which CIMPL elements are mapped to instances of that repeated field on the target model. This process is called slicing . For example, the FHIR Task resource allows for an arbitrary number of input fields to be added. To ensure that all each of the input fields is uniquely addressable by a parsing engine, those inputs need to be differentiated by a discriminator . See the FHIR documentation for more detail about slicing and discriminators","title":"Slicing"},{"location":"cimpl6Reference/#slicing-strategies","text":"Slicing is used when there is a variation of how an individual element is represented and a need to model it as a sub-list. An example of this is the FHIR Blood Pressure profile , which can be considered an observation with two components which are identical in structure other than their represented code. In CIMPL, slicing strategies are specified in the map file. Two keywords are used in conjunction to specify the slide: slice on slice strategy Examples of its usage in a statement are shown below: Keywords Example slice on / slice strategy Components.ObservationComponent maps to component (slice on = code.coding.code; slice strategy = includes) slice on / slice strategy Members.Observation maps to related.target (slice at = related; slice on = target.reference.resolve(); slice on type = profile; slice strategy = includes) slice on Laterality maps to qualifier (slice on = concept)","title":"Slicing Strategies"},{"location":"cimpl6Reference/#declaring-a-discriminator","text":"To perform any slicing, a discriminator needs to be declared, using slice on followed by the discriminator. CIMPL supports the FHIR processing types for discriminators: Discriminator Definition value The slices have different values in the nominated element exists The slices are differentiated by the presence or absence of the nominated element pattern The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x] type The slices are differentiated by type of the nominated element to a specifed profile profile The slices are differentiated by conformance of the nominated element to a specifed profile","title":"Declaring a Discriminator**"},{"location":"cimpl6Reference/#moving-the-slice-location","text":"If the discriminator used for slicing is not the actual field that is being mapped to, slice at can allow you to explicitly define the location of the slice. Keywords Example slice at Members.Observation maps to related.target (slice at = related; slice on type) In the above example, though the mapping is declared such that Members.Observation maps to related.target , the slicing is not occuring at related.target . Instead, the slice at = related ensures that the slicing is occuring at the related element.","title":"Moving the Slice Location"},{"location":"cimpl6Reference/#appendix-a-constraints-summary","text":"","title":"Appendix A: Constraints Summary"},{"location":"cimpl6Reference/#cardinality-constraints","text":"ReferenceRange 0..0 Narrows the cardinality of a field inherited from a base class. Common examples are making an optional field required ( 0..1 to 1..1 ) or prohibiting an optional field ( 0..1 to 0..0 ).","title":"Cardinality Constraints"},{"location":"cimpl6Reference/#subclass-constraints","text":"Specimen substitute BreastSpecimen Indicates that the data type of an inherited field should be restricted to a certain subclass of the originally-declared data type.","title":"Subclass Constraints"},{"location":"cimpl6Reference/#value-type-constraints","text":"Stage.StageDetail[Observation] only CancerStage Indicates that an inherited field's value should be substituted with a more specific child type.","title":"Value Type Constraints"},{"location":"cimpl6Reference/#choice-selection-constraints","text":"FindingResult only IntegerQuantity Indicates that an inherited field's value , which is a choice of types, should be a specific type selected from the choices. Note that it is also possible to select a child type of one of the choice types.","title":"Choice Selection Constraints"},{"location":"cimpl6Reference/#includes-constraints-slicing","text":"BloodPressure.ObservationComponent 0..* includes SystolicPressure 0..1 includes DiastolicPressure 0..1 Indicates that a field with multiple cardinality should be populated with specific child types. Each child type can be assigned its own cardinality as long as the combined cardinalities still fit within the field's total cardinality.","title":"Includes Constraints (Slicing)"},{"location":"cimpl6Reference/#fixed-boolean-constraints","text":"WasNotGiven = true Indicates that a boolean field must be a specific value (either true or false ).","title":"Fixed Boolean Constraints"},{"location":"cimpl6Reference/#fixed-code-constraints","text":"Vaccine = CVX#36 \"VZIG\" Value[Quantity].Units = UCUM#cm Indicates the named property must be given as the specified code. You are allowed to include from either a codesystem or a specific code from a codesystem.","title":"Fixed Code Constraints"},{"location":"cimpl6Reference/#appendix-b-summary-of-changes-in-cimpl-60","text":"For those who have created detailed models using CIMPL 5.0, there have been significant grammar changes to CIMPL 6.0. The table below summarizes these changes: Change Type Change Description CIMPL 5.0 Example CIMPL 6.0 Example Section New keyword field constraint only binds only one data type to a property None FindingResult only concept Only New keyword Property is required to define properties for an Entry or Element. 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Property Declaration Replace EntryElement keyword replaced by Entry EntryElement: CourseOfTreatmentPerformed Entry: CourseOfTreatmentPerformed Element Name Declaration Replace Based on keyword replaced by Parent Based on: Observation Parent: Observation Inheritance Syntax change Cardinality is specified after the property or class name 0..1 TreatmentIntent Property: TreatmentIntent 0..1 Cardinality Replace is constraint for fixed values replaced by = FindingTopicCode is LNC#48676-1 FindingTopicCode is LNC#48676-1 Field Constraints Replace substitution of a more specific element derived from a parent element using is type keyword replaced by substitute . None Specimen substitute BreastSpecimen Substitute Replace code , Coding , and CodeableConcept primitives are replaced by a new primitive concept Value: CodeableConcept from AttributionCategoryVS Value: concept from AttributionCategoryVS Primitives Replace must be , should be , could be , and if covered value set constraints are obsolete and replaced by (required) , (preferred) , (extensible) , and (example) Type from BreastSpecimenTypeVS if covered Type from BreastSpecimenTypeVS (required) Value Set Replace ref() is now obsolete and replaced with [] . SourceSpecimen value is type ref(BreastSpecimen) SourceSpecimen[Specimen] substitute BreastSpecimen References Note: \"As of CIMPL 6.0, must be , should be , could be , and if covered value set constraints are obsolete and replaced by (required) , (preferred) , (extensible) , and (example) \" CIMPL 5.0 Example CIMPL 6.0 Example Binding Strength from Substance from SubstanceOfAbuseVS Required Priority must be from http://hl7.org/fhir/ValueSet/request-priority Priority from http://hl7.org/fhir/ValueSet/request-priority (required) Required 1..1 Status should be from http://hl7.org/fhir/ValueSet/event-status 1..1 Status from http://hl7.org/fhir/ValueSet/event-status (preferred) Preferred CodeableConcept could be from http://hl7.org/fhir/ValueSet/medication-as-needed-reason concept from http://hl7.org/fhir/ValueSet/medication-as-needed-reason (example) Example Category from http://hl7.org/fhir/ValueSet/goal-category if covered Category from http://hl7.org/fhir/ValueSet/goal-category (extensible) Extensible","title":"Appendix B: Summary of Changes in CIMPL 6.0"},{"location":"cimpl6Reference/#appendix-c-future-architectural-considerations","text":"To what extent is the shr-cli tool specific to SHR versus a general purpose modeling tool (e.g., for Death Reporting Are there any plans to support output of Open API Specification files? Inclusive output generation, for people that only care about generating FHIR profiles and don't want to wait for other docs to generate","title":"Appendix C: Future Architectural Considerations"},{"location":"cimpl6Tutorial_detail/","text":"CIMPL 6.0 In-depth Tutorial This is an extensive tutorial, meant to educate people about many different aspects of CIMPL. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Reference documentation . TBD","title":"CIMPL 6.0 In-depth Tutorial"},{"location":"cimpl6Tutorial_detail/#cimpl-60-in-depth-tutorial","text":"This is an extensive tutorial, meant to educate people about many different aspects of CIMPL. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Reference documentation . TBD","title":"CIMPL 6.0 In-depth Tutorial"},{"location":"cimpl6Tutorial_helloWorld/","text":"CIMPL 6.0 'Hello World' Tutorial Let\u2019s do a \u201cHello, World\u201d using CIMPL v6! Note: Make sure you have completed the CIMPL Installation instructions before proceeding, and that shr-cli is installed in ~/cimpl/shr-cli . Start by creating a folder structure for our new project. Open up your favorite (Unix-based) command-line tool and enter the following: cd ~/cimpl mkdir hello_world Now, create a file called HelloWorld.txt in the ~/cimpl/hello_world folder and add the following data definitions: Grammar: DataElement 6.0 Namespace: hello Description: \"A simple example of CIMPL.\" EntryElement: HelloWorld Description: \"A silly profile.\" Property: SayHello 0..1 Element: SayHello Description: \"An extension indicating whether to say hello\" Value: boolean Next, create a file called HelloWorld_map.txt that defines the mapping to FHIR. Since this doesn\u2019t align with any particular resource, it will map to Basic . This file is even simpler: Grammar: Map 6.0 Namespace: hello Target: FHIR_STU_3 HelloWorld maps to Basic: We didn\u2019t map the SayHello data element to an existing element inside this resource, so it will automatically appear as an extension. Next, we need some simple HTML for the Implementation Guide pages, so create an exampleIndexContent.html file with the following content: HELLO HELLO HELLO Finally, we need a configuration file. Create an ig-hello_world-config.json file with these contents: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"npmName\": \"hello_world\", \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } } Now, go back to your shr-cli installation and run the hello world: cd ~/cimpl/shr-cli node . -c ig-hello_world-config.json ../hello_world When the program runs, it will output a warning message alerting you that mapping to Basic usually isn\u2019t the best choice, but in this case, it is intentional. After the program runs, the generated profile (a FHIR StructureDefinition ) will be found in ~/cimpl/shr-cli/out/fhir/profiles/ . StructureDefinition s are verbose, and this one clocks in at several hundred lines. A friendlier view is created when we create an implementation guide (IG). To do this, we use the existing FHIR implementation guide (IG) publisher . IG Generation with a Proxy Server Note: If your organization uses a proxy server, you'll need to explicitly declare a few options. If your organization does not use a proxy server, you can skip ahead to IG Generation . On Windows: java %JAVA_OPTS% -Xms4g -Xmx8g -jar out/fhir/guide/org.hl7.fhir.igpublisher.jar -ig out/fhir/guide/ig.json Note: users have reported issues with running the IG publisher on windows behind a proxy. Please try to run the IG publisher without connecting to a proxy On Linux/MacOS: java $JAVA_OPTS -Xms4g -Xmx8g -jar out/fhir/guide/org.hl7.fhir.igpublisher.jar -ig out/fhir/guide/ig.json IG Generation (without a Proxy Server) To generate the IG, run: cd ~/cimpl/shr-cli yarn run ig:publish Note: If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. The generated profile page will be located at ~/cimpl/shr-cli/out/fhir/guide/output/StructureDefinition-hello-HelloWorld.html . Open this page in your favorite web browser. Note : the IG is automatically branded as part of the Standard Health Record (SHR). We are working on \u201cde-branding\u201d the IG, so please ignore the SHR references for now. You should see a FHIR profile that looks like a traditional FHIR Implementation Guide . For a more comprehensive understanding of the CIMPL grammar and how to use it for your project, continue to the Tutorial .","title":"CIMPL 6.0 'Hello World' Tutorial"},{"location":"cimpl6Tutorial_helloWorld/#cimpl-60-hello-world-tutorial","text":"Let\u2019s do a \u201cHello, World\u201d using CIMPL v6! Note: Make sure you have completed the CIMPL Installation instructions before proceeding, and that shr-cli is installed in ~/cimpl/shr-cli . Start by creating a folder structure for our new project. Open up your favorite (Unix-based) command-line tool and enter the following: cd ~/cimpl mkdir hello_world Now, create a file called HelloWorld.txt in the ~/cimpl/hello_world folder and add the following data definitions: Grammar: DataElement 6.0 Namespace: hello Description: \"A simple example of CIMPL.\" EntryElement: HelloWorld Description: \"A silly profile.\" Property: SayHello 0..1 Element: SayHello Description: \"An extension indicating whether to say hello\" Value: boolean Next, create a file called HelloWorld_map.txt that defines the mapping to FHIR. Since this doesn\u2019t align with any particular resource, it will map to Basic . This file is even simpler: Grammar: Map 6.0 Namespace: hello Target: FHIR_STU_3 HelloWorld maps to Basic: We didn\u2019t map the SayHello data element to an existing element inside this resource, so it will automatically appear as an extension. Next, we need some simple HTML for the Implementation Guide pages, so create an exampleIndexContent.html file with the following content: HELLO HELLO HELLO Finally, we need a configuration file. Create an ig-hello_world-config.json file with these contents: { \"projectName\": \"Example Project\", \"projectShorthand\": \"EXAMPLE\", \"projectURL\": \"http://example.com\", \"fhirURL\": \"http://example.com/fhir\", \"implementationGuide\": { \"npmName\": \"hello_world\", \"indexContent\": \"exampleIndexContent.html\" }, \"publisher\": \"Example Publisher\", \"contact\": [ { \"telecom\": [ { \"system\": \"url\", \"value\": \"http://example.com\" } ] } ], \"provenanceInfo\": { \"leadAuthor\": { \"name\":\"Example Author\", \"organization\": \"Example Publisher\", \"email\": \"example@example.org\" }, \"license\": \"Creative Commons CC-BY <https://creativecommons.org/licenses/by/3.0/>\", \"copyright\": \"Copyright (c) The Example Organization <http://example.org>\" } } Now, go back to your shr-cli installation and run the hello world: cd ~/cimpl/shr-cli node . -c ig-hello_world-config.json ../hello_world When the program runs, it will output a warning message alerting you that mapping to Basic usually isn\u2019t the best choice, but in this case, it is intentional. After the program runs, the generated profile (a FHIR StructureDefinition ) will be found in ~/cimpl/shr-cli/out/fhir/profiles/ . StructureDefinition s are verbose, and this one clocks in at several hundred lines. A friendlier view is created when we create an implementation guide (IG). To do this, we use the existing FHIR implementation guide (IG) publisher .","title":"CIMPL 6.0 'Hello World' Tutorial"},{"location":"cimpl6Tutorial_helloWorld/#ig-generation-with-a-proxy-server","text":"Note: If your organization uses a proxy server, you'll need to explicitly declare a few options. If your organization does not use a proxy server, you can skip ahead to IG Generation . On Windows: java %JAVA_OPTS% -Xms4g -Xmx8g -jar out/fhir/guide/org.hl7.fhir.igpublisher.jar -ig out/fhir/guide/ig.json Note: users have reported issues with running the IG publisher on windows behind a proxy. Please try to run the IG publisher without connecting to a proxy On Linux/MacOS: java $JAVA_OPTS -Xms4g -Xmx8g -jar out/fhir/guide/org.hl7.fhir.igpublisher.jar -ig out/fhir/guide/ig.json","title":"IG Generation with a Proxy Server"},{"location":"cimpl6Tutorial_helloWorld/#ig-generation-without-a-proxy-server","text":"To generate the IG, run: cd ~/cimpl/shr-cli yarn run ig:publish Note: If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. The generated profile page will be located at ~/cimpl/shr-cli/out/fhir/guide/output/StructureDefinition-hello-HelloWorld.html . Open this page in your favorite web browser. Note : the IG is automatically branded as part of the Standard Health Record (SHR). We are working on \u201cde-branding\u201d the IG, so please ignore the SHR references for now. You should see a FHIR profile that looks like a traditional FHIR Implementation Guide . For a more comprehensive understanding of the CIMPL grammar and how to use it for your project, continue to the Tutorial .","title":"IG Generation (without a Proxy Server)"},{"location":"cimpl6UserGuide/","text":"CIMPL Authoring The purpose of this guide is to educate people about many different aspects of creating CIMPL models and its supporting utilities. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Reference documentation . Table Of Contents CIMPL Authoring Authoring Environment Setting up the VSCode Authoring Navigating a CIMPL Model within VSCode Support Authoring Environment Any text editor can be used to write CIMPL grammar. However, VSCode editor is recommended to take advantage of custom-developed to better navigate CIMPL constructs. Setting up the VSCode Authoring Note: VSCode UI screenshots in this section were taken from a MacOS enironment. While the overall functionality is the same across supported OS platforms, installation and configuration specifics might differ. Reference the VSCode documentation pertinent to your OS platform. Download the VSCode editor . Open VSCode and search for the extension vscode-lang-cimpl . The figure below shows where to find VSCode extensions. Navigating a CIMPL Model within VSCode Elements properties can be previewed in the following ways: hovering over the element. placing the cursor on the element text and right-clicking option Peek Definition placing the cursor on the element text and right-clicking option Go to Definition Hovering over the element: Using Peek Definition : Using Go to Definition : Support Questions on using CIMPL and its toolchain can be addressed email at cimpl-support@mitre.org . Bugs can be reported by entering an issue to one of the following GitHub repositories: Related to modeling of CIMPL constructs or its FHIR-based classes: https://github.com/standardhealth/shr_spec Related to running the CIMPL shr-cli compiler, CIMPL export configuration files, or generating the FHIR Implementation Guide (IG): https://github.com/standardhealth/shr-cli/releases","title":"CIMPL Authoring"},{"location":"cimpl6UserGuide/#cimpl-authoring","text":"The purpose of this guide is to educate people about many different aspects of creating CIMPL models and its supporting utilities. If you're looking for a quick introduction to CIMPL and shr-cli environment setup, try the Hello World . If you're looking for detailed guidance on CIMPL syntax, try the CIMPL6 Reference documentation . Table Of Contents CIMPL Authoring Authoring Environment Setting up the VSCode Authoring Navigating a CIMPL Model within VSCode Support","title":"CIMPL Authoring"},{"location":"cimpl6UserGuide/#authoring-environment","text":"Any text editor can be used to write CIMPL grammar. However, VSCode editor is recommended to take advantage of custom-developed to better navigate CIMPL constructs.","title":"Authoring Environment"},{"location":"cimpl6UserGuide/#setting-up-the-vscode-authoring","text":"Note: VSCode UI screenshots in this section were taken from a MacOS enironment. While the overall functionality is the same across supported OS platforms, installation and configuration specifics might differ. Reference the VSCode documentation pertinent to your OS platform. Download the VSCode editor . Open VSCode and search for the extension vscode-lang-cimpl . The figure below shows where to find VSCode extensions.","title":"Setting up the VSCode Authoring"},{"location":"cimpl6UserGuide/#navigating-a-cimpl-model-within-vscode","text":"Elements properties can be previewed in the following ways: hovering over the element. placing the cursor on the element text and right-clicking option Peek Definition placing the cursor on the element text and right-clicking option Go to Definition Hovering over the element: Using Peek Definition : Using Go to Definition :","title":"Navigating a CIMPL Model within VSCode"},{"location":"cimpl6UserGuide/#support","text":"Questions on using CIMPL and its toolchain can be addressed email at cimpl-support@mitre.org . Bugs can be reported by entering an issue to one of the following GitHub repositories: Related to modeling of CIMPL constructs or its FHIR-based classes: https://github.com/standardhealth/shr_spec Related to running the CIMPL shr-cli compiler, CIMPL export configuration files, or generating the FHIR Implementation Guide (IG): https://github.com/standardhealth/shr-cli/releases","title":"Support"},{"location":"cimplFHIRBasedClassOverview/","text":"CIMPL 6.0 FHIR-based Class Overview Note: this documentation is in the process of being further expanded and is an actively updating document. TBD","title":"CIMPL 6.0 FHIR-based Class Overview"},{"location":"cimplFHIRBasedClassOverview/#cimpl-60-fhir-based-class-overview","text":"Note: this documentation is in the process of being further expanded and is an actively updating document. TBD","title":"CIMPL 6.0 FHIR-based Class Overview"},{"location":"cimplInstall/","text":"CIMPL Setup and Installation Table of Contents CIMPL Setup and Installation Background Windows Installation Instructions Windows Proxy Setup Supporting Software Node.js for Windows Yarn for Windows Yarn Proxy Setup Git for Windows Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool Windows Java Installation Windows Jekyll Installation macOS Installation Instructions Terminal Proxy Setup Supporting Software Node.js for macOS Homebrew Yarn for macOS Git for macOS Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool MacOS Java Installation MacOS Jekyll Installation Background CIMPL (and, by extension, the shr-cli tool) is a text-based tool that requires its users to understand and use your operating system's command line . If you are uncomfortable with using the command line, try this short introduction . Windows Installation Instructions Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: Read the instructions thoroughly . Follow instructions in order , without skipping around. Pay attention to variables (like your organization's proxy) that you may need to replace. Windows Proxy Setup Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server, you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: setx HTTP_PROXY http://your.proxy.org setx HTTPS_PROXY https://your.proxy.org setx http_proxy http://your.proxy.org setx https_proxy https://your.proxy.org setx proxy http://your.proxy.org setx JAVA_OPTS \"-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80\" Open a windows command prompt Copy and paste the modified code block (with your organization's proxy server) into the command prompt Close and re-open your command prompt to make sure those settings take effect Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server. Supporting Software Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code . Node.js for Windows The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Yarn for Windows Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. It is recommended that CIMPL developers download and install the stable version of Yarn . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Yarn Proxy Setup Note: If your organization uses a proxy server, replace http://your.proxy.org with your organization's proxy server in the following code block: yarn config set proxy http://your.proxy.org yarn config set strict-ssl false ...then run the modified code block (with your organization's proxy server) in the command prompt Git for Windows Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the shr-cli tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . Download the installation package for Git for Windows and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete). This will install a few applications, but the most useful for CIMPL development will be the 'Git Bash' application. This opens a command-line prompt which emulates the use of git on a Unix-based system (e.g., Linux or macOS). Most CIMPL developers use Unix-based systems, so you may want to use 'Git Bash' for working with CIMPL instead of the standard Windows command line. There are many tutorials online about the use of git. Users that are new to Unix or bash may find this video introduction to Git Bash helpful. You should also set up git so that any changes you make to the codebase are properly identified (replacing the name and email placeholders with your name and email): git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\" Git Proxy Setup Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open a windows command prompt Copy and paste that code block (with your organization's proxy server) into the command prompt Learning Git If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/ Visual Studio Code Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . You can use the default options in the installer file, but some developers find it helpful to check these checkboxes during the installation wizard: * Add \"Open with Code\" action to Windows Explorer file context menu * Add \"Open with Code\" action to Windows Explorer directory context menu * Register Code as an editor for supported file types Proxy Setup Note: If your organization uses a proxy server, you'll need to set this up in the VSCode settings. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: * Open Visual Studio Code * Open the User Settings menu (File -> Preferences -> Settings in the menu bar or Ctrl + , ) * Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: * Save the changes (Using File -> Save in the menu bar or Ctrl + S ) * Exit and re-open Visual Studio Code to make sure the settings take effect CIMPL Extension Setup CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: * Open the extensions menu (Using View -> Extensions in the menu bar, Ctrl + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) * By default, the extensions are filtered by @sort:installs . Replace this with cimpl * Look for the vscode-language-cimpl extension and click the Install button * When the installation has completed, click the Reload button SHR-CLI Tool With the supporting software installed, you can move on to installing the actual shr-cli tool. Open 'Git Bash' (not the windows command prompt) and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the shr-cli tool and places it in the ~/cimpl/shr-cli directory. To set up the shr-cli tool, run: cd ~/cimpl/shr-cli yarn FHIR IG Generation Tool The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly. Windows Java Installation The IG publisher is primarily written in java and requires JRE version 8. To install JRE: * Go to the Java SE Runtime Environment 8 Downloads page * Click the 'Accept License Agreement' radio button * Download the most recent JRE 8 installer for your operating system Windows Jekyll Installation Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. Use the Windows Installation Instructions for Jekyll : * Download RubyInstaller and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) * After clicking 'Finish', a command prompt should open asking about an MSYS2 base installation . Press Enter to continue. * When that installation is complete, open a new command prompt from the Windows start menu and type: gem install jekyll bundler Check to see that Jekyll is installed using: jekyll -v You should see the following: jekyll X.X.X ...where X.X.X is the latest Jekyll version number. If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example. macOS Installation Instructions Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: * Read the instructions thoroughly * Follow instructions in order , without skipping around * Pay attention to variables (like your organization's proxy) that you may need to replace Terminal Proxy Setup Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server and you use the standard Terminal app for macOS , you will need to set up environment variables before proceeding. * Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: echo \"export http_proxy=http://your.proxy.org:80 export https_proxy=http://your.proxy.org:80 export HTTP_PROXY=http://your.proxy.org:80 export HTTPS_PROXY=http://your.proxy.org:80 export JAVA_OPTS='-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 \\ -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 \\ -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80'\" >> ~/.bash_profile;\\ source ~/.bash_profile Open Terminal Copy and paste the modified code block (with your organization's proxy server) into the terminal Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server. Supporting Software Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code . Node.js for macOS The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) Homebrew Homebrew is a package manager for macOS which will allow us to install several other applications. To install homebrew, enter the following in a terminal window: /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Note: During the installation, you may be asked if you want to install 'OSX Developer Tools'. If this occurs, answer 'yes'. Yarn for macOS Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. With homebrew installed, yarn can be installed by entering the following in a terminal window: brew install yarn Git for macOS Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the shr-cli tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . With homebrew installed, git can be installed by entering the following in a terminal window: brew install git You should also set up git so that any changes you make to the codebase are properly identified. Replace the name and email placeholders with your name and email : git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\" Git Proxy Setup Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open Terminal Copy and paste that code block (with your organization's proxy server) into the terminal Learning Git If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/ Visual Studio Code Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . Proxy Setup Note: If your organization uses a proxy server, you will need to add some proxy settings to Visual Studio Code. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: * Open Visual Studio Code * Open the User Settings menu (Code -> Preferences -> Settings in the menu bar or Command + , ) * Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: * Save the changes (Using File -> Save in the menu bar or Command + S ) * Exit and re-open Visual Studio Code to make sure the settings take effect CIMPL Extension Setup CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: * Open the extensions menu (Using View -> Extensions in the menu bar, Command + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) * By default, the extensions are filtered by @sort:installs . Replace this with cimpl * Look for the vscode-language-cimpl extension and click the Install button * When the installation has completed, click the Reload button SHR-CLI Tool With the supporting software installed, you can move on to installing the actual shr-cli tool. Open a terminal window and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the shr-cli tool and places it in the ~/cimpl/shr-cli directory. To set up the shr-cli tool, run: cd ~/cimpl/shr-cli yarn Note: If you encounter error unable to get local issuer certificate , run the following command in terminal: yarn config set strict-ssl false ...and then re-run yarn using: yarn FHIR IG Generation Tool The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly. MacOS Java Installation The IG publisher is primarily written in java and requires JRE version 8. To install JRE: * Go to the Java SE Runtime Environment 8 Downloads page * Click the 'Accept License Agreement' radio button * Download the most recent JRE 8 installer for your operating system MacOS Jekyll Installation Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. If you don't know if the xcode developer tools are installed, run the following command: xcode-select --install Install the latest version of Ruby: brew install ruby When ruby is finished installing, run the following: gem install bundler jekyll NOTE: If your system requires sudo to gem install bundler and jekyll, use the following command to preserve environment variables when using sudo : sudo -E gem install bundler jekyl If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example.","title":"CIMPL Setup and Installation"},{"location":"cimplInstall/#cimpl-setup-and-installation","text":"Table of Contents CIMPL Setup and Installation Background Windows Installation Instructions Windows Proxy Setup Supporting Software Node.js for Windows Yarn for Windows Yarn Proxy Setup Git for Windows Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool Windows Java Installation Windows Jekyll Installation macOS Installation Instructions Terminal Proxy Setup Supporting Software Node.js for macOS Homebrew Yarn for macOS Git for macOS Git Proxy Setup Learning Git Visual Studio Code Proxy Setup CIMPL Extension Setup SHR-CLI Tool FHIR IG Generation Tool MacOS Java Installation MacOS Jekyll Installation","title":"CIMPL Setup and Installation"},{"location":"cimplInstall/#background","text":"CIMPL (and, by extension, the shr-cli tool) is a text-based tool that requires its users to understand and use your operating system's command line . If you are uncomfortable with using the command line, try this short introduction .","title":"Background"},{"location":"cimplInstall/#windows-installation-instructions","text":"Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: Read the instructions thoroughly . Follow instructions in order , without skipping around. Pay attention to variables (like your organization's proxy) that you may need to replace.","title":"Windows Installation Instructions"},{"location":"cimplInstall/#windows-proxy-setup","text":"Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server, you will need to set up environment variables before proceeding. Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: setx HTTP_PROXY http://your.proxy.org setx HTTPS_PROXY https://your.proxy.org setx http_proxy http://your.proxy.org setx https_proxy https://your.proxy.org setx proxy http://your.proxy.org setx JAVA_OPTS \"-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80\" Open a windows command prompt Copy and paste the modified code block (with your organization's proxy server) into the command prompt Close and re-open your command prompt to make sure those settings take effect Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server.","title":"Windows Proxy Setup"},{"location":"cimplInstall/#supporting-software","text":"Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code .","title":"Supporting Software"},{"location":"cimplInstall/#nodejs-for-windows","text":"The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Node.js for Windows"},{"location":"cimplInstall/#yarn-for-windows","text":"Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. It is recommended that CIMPL developers download and install the stable version of Yarn . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Yarn for Windows"},{"location":"cimplInstall/#yarn-proxy-setup","text":"Note: If your organization uses a proxy server, replace http://your.proxy.org with your organization's proxy server in the following code block: yarn config set proxy http://your.proxy.org yarn config set strict-ssl false ...then run the modified code block (with your organization's proxy server) in the command prompt","title":"Yarn Proxy Setup"},{"location":"cimplInstall/#git-for-windows","text":"Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the shr-cli tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . Download the installation package for Git for Windows and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete). This will install a few applications, but the most useful for CIMPL development will be the 'Git Bash' application. This opens a command-line prompt which emulates the use of git on a Unix-based system (e.g., Linux or macOS). Most CIMPL developers use Unix-based systems, so you may want to use 'Git Bash' for working with CIMPL instead of the standard Windows command line. There are many tutorials online about the use of git. Users that are new to Unix or bash may find this video introduction to Git Bash helpful. You should also set up git so that any changes you make to the codebase are properly identified (replacing the name and email placeholders with your name and email): git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\"","title":"Git for Windows"},{"location":"cimplInstall/#git-proxy-setup","text":"Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open a windows command prompt Copy and paste that code block (with your organization's proxy server) into the command prompt","title":"Git Proxy Setup"},{"location":"cimplInstall/#learning-git","text":"If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/","title":"Learning Git"},{"location":"cimplInstall/#visual-studio-code","text":"Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage . You can use the default options in the installer file, but some developers find it helpful to check these checkboxes during the installation wizard: * Add \"Open with Code\" action to Windows Explorer file context menu * Add \"Open with Code\" action to Windows Explorer directory context menu * Register Code as an editor for supported file types","title":"Visual Studio Code"},{"location":"cimplInstall/#proxy-setup","text":"Note: If your organization uses a proxy server, you'll need to set this up in the VSCode settings. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: * Open Visual Studio Code * Open the User Settings menu (File -> Preferences -> Settings in the menu bar or Ctrl + , ) * Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: * Save the changes (Using File -> Save in the menu bar or Ctrl + S ) * Exit and re-open Visual Studio Code to make sure the settings take effect","title":"Proxy Setup"},{"location":"cimplInstall/#cimpl-extension-setup","text":"CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: * Open the extensions menu (Using View -> Extensions in the menu bar, Ctrl + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) * By default, the extensions are filtered by @sort:installs . Replace this with cimpl * Look for the vscode-language-cimpl extension and click the Install button * When the installation has completed, click the Reload button","title":"CIMPL Extension Setup"},{"location":"cimplInstall/#shr-cli-tool","text":"With the supporting software installed, you can move on to installing the actual shr-cli tool. Open 'Git Bash' (not the windows command prompt) and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the shr-cli tool and places it in the ~/cimpl/shr-cli directory. To set up the shr-cli tool, run: cd ~/cimpl/shr-cli yarn","title":"SHR-CLI Tool"},{"location":"cimplInstall/#fhir-ig-generation-tool","text":"The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly.","title":"FHIR IG Generation Tool"},{"location":"cimplInstall/#windows-java-installation","text":"The IG publisher is primarily written in java and requires JRE version 8. To install JRE: * Go to the Java SE Runtime Environment 8 Downloads page * Click the 'Accept License Agreement' radio button * Download the most recent JRE 8 installer for your operating system","title":"Windows Java Installation"},{"location":"cimplInstall/#windows-jekyll-installation","text":"Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. Use the Windows Installation Instructions for Jekyll : * Download RubyInstaller and run it, using the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete) * After clicking 'Finish', a command prompt should open asking about an MSYS2 base installation . Press Enter to continue. * When that installation is complete, open a new command prompt from the Windows start menu and type: gem install jekyll bundler Check to see that Jekyll is installed using: jekyll -v You should see the following: jekyll X.X.X ...where X.X.X is the latest Jekyll version number. If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example.","title":"Windows Jekyll Installation"},{"location":"cimplInstall/#macos-installation-instructions","text":"Note: These installation instructions assume that you are installing applications using an account that has administrator-level access. If you do not have administrator rights on your machine, some of the installations will fail or the applications will refuse to install. For a successful installation, it is critical that you: * Read the instructions thoroughly * Follow instructions in order , without skipping around * Pay attention to variables (like your organization's proxy) that you may need to replace","title":"macOS Installation Instructions"},{"location":"cimplInstall/#terminal-proxy-setup","text":"Warning: Many professional organizations use proxy servers to filter incoming internet content (e.g., antivirus checks, adult material, etc.). Many of the applications that support CIMPL require that these proxy servers be explicitly declared before they will function properly. If your organization does not use a proxy server, you can skip ahead to installing the Supporting Software . If your organization uses a proxy server and you use the standard Terminal app for macOS , you will need to set up environment variables before proceeding. * Copy the following code block into a text editor and replace your.proxy.org with your organization's proxy server and 80 with the port used by your organization's proxy server: echo \"export http_proxy=http://your.proxy.org:80 export https_proxy=http://your.proxy.org:80 export HTTP_PROXY=http://your.proxy.org:80 export HTTPS_PROXY=http://your.proxy.org:80 export JAVA_OPTS='-Dhttp.proxyHost=your.proxy.org -Dhttp.proxyPort=80 \\ -Dhttps.proxyHost=your.proxy.org -Dhttps.proxyPort=80 \\ -DsocksProxyHost=your.proxy.org -DsocksProxyPort=80'\" >> ~/.bash_profile;\\ source ~/.bash_profile Open Terminal Copy and paste the modified code block (with your organization's proxy server) into the terminal Some of the following installation steps will also include specific setups for running the CIMPL tooling from behind a proxy server.","title":"Terminal Proxy Setup"},{"location":"cimplInstall/#supporting-software_1","text":"Unlike most applications that include a standalone installation file that you can click on to install, CIMPL is dependent on the installation of other applications, like Node.js , Yarn , Git , and Visual Studio Code .","title":"Supporting Software"},{"location":"cimplInstall/#nodejs-for-macos","text":"The CIMPL command-line utilities are built using the Node.js runtime environment . It is recommended that CIMPL developers download and install the LTS (long-term support) version of Node.js . Use the default options in the installer file (i.e., just keep clicking 'Next' until the installation is complete)","title":"Node.js for macOS"},{"location":"cimplInstall/#homebrew","text":"Homebrew is a package manager for macOS which will allow us to install several other applications. To install homebrew, enter the following in a terminal window: /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Note: During the installation, you may be asked if you want to install 'OSX Developer Tools'. If this occurs, answer 'yes'.","title":"Homebrew"},{"location":"cimplInstall/#yarn-for-macos","text":"Yarn is a dependency manager that ensures that all the prerequisite code libraries on which CIMPL depends are properly installed. With homebrew installed, yarn can be installed by entering the following in a terminal window: brew install yarn","title":"Yarn for macOS"},{"location":"cimplInstall/#git-for-macos","text":"Git is a free and open source distributed version control system that allows developers working simultaneously on a single project to manage various updates to their code. Git is not a strict dependency (i.e., you can run the shr-cli tool without git), but it is recommended for CIMPL model developers to use git, along with a hosted git solution like GitHub or GitLab . With homebrew installed, git can be installed by entering the following in a terminal window: brew install git You should also set up git so that any changes you make to the codebase are properly identified. Replace the name and email placeholders with your name and email : git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@work.org\"","title":"Git for macOS"},{"location":"cimplInstall/#git-proxy-setup_1","text":"Note: If your organization uses a proxy server, you will need to add some proxy settings to git. If your organization does not use a proxy server, you can skip ahead to installing Visual Studio Code . Replace your.proxy.org:port with your actual proxy server in the following code block: git config --global http.proxy http://your.proxy.org:port git config --global url.\"https://\".insteadOf git:// Open Terminal Copy and paste that code block (with your organization's proxy server) into the terminal","title":"Git Proxy Setup"},{"location":"cimplInstall/#learning-git_1","text":"If you're totally new to Git, github has a great introduction where you can learn buy reading or playing with some helpful visualizations: http://try.github.io/","title":"Learning Git"},{"location":"cimplInstall/#visual-studio-code_1","text":"Visual Studio Code (occasionally referred to as 'VSCode', or simply 'Code') is not a strict dependency (i.e., you can author CIMPL files using any text editor), but it is recommended that you use it for CIMPL development. An extension for VSCode has been developed that offers syntax highlighting, autocomplete, and other things that make life easier. To get started, download and install the latest stable build from the VSCode homepage .","title":"Visual Studio Code"},{"location":"cimplInstall/#proxy-setup_1","text":"Note: If your organization uses a proxy server, you will need to add some proxy settings to Visual Studio Code. If your organization does not use a proxy server, you can skip ahead to the CIMPL Extension Setup . To ensure that Visual Studio Code can download extensions, a couple lines of code need to be added to the user settings file. Code's user settings are a bit different than you may be used to - they are all stored in a JSON file that can be edited from within VSCode (for more information, check out the user settings documentation ). To add the proxy settings: * Open Visual Studio Code * Open the User Settings menu (Code -> Preferences -> Settings in the menu bar or Command + , ) * Replace http://your.proxy.org with your actual proxy server in the following code block: \"http.proxy\": \"http://your.proxy.org\", \"http.proxyStrictSSL\": false Copy and paste those lines between the curly brackets in the panel on the right side Your User Settings should now look like this: * Save the changes (Using File -> Save in the menu bar or Command + S ) * Exit and re-open Visual Studio Code to make sure the settings take effect","title":"Proxy Setup"},{"location":"cimplInstall/#cimpl-extension-setup_1","text":"CIMPL authors have created tools for VSCode that offer syntax highlighting, autocomplete, and other things that make life easier. These tools are known as 'extensions' in VSCode (for more information, watch this video about working with extensions ). To enable CIMPL syntax highlighting in VSCode: * Open the extensions menu (Using View -> Extensions in the menu bar, Command + Shift + X , or the icon on the bottom of the left toolbar that looks like a box inside of a box) * By default, the extensions are filtered by @sort:installs . Replace this with cimpl * Look for the vscode-language-cimpl extension and click the Install button * When the installation has completed, click the Reload button","title":"CIMPL Extension Setup"},{"location":"cimplInstall/#shr-cli-tool_1","text":"With the supporting software installed, you can move on to installing the actual shr-cli tool. Open a terminal window and enter the following commands: cd ~ mkdir cimpl cd cimpl git clone https://github.com/standardhealth/shr-cli.git This grabs the latest version of the shr-cli tool and places it in the ~/cimpl/shr-cli directory. To set up the shr-cli tool, run: cd ~/cimpl/shr-cli yarn Note: If you encounter error unable to get local issuer certificate , run the following command in terminal: yarn config set strict-ssl false ...and then re-run yarn using: yarn","title":"SHR-CLI Tool"},{"location":"cimplInstall/#fhir-ig-generation-tool_1","text":"The FHIR implementation guide (IG) publisher is a Java-based tool that is owned and operated by the HL7 FHIR team. It requires that Java and Jekyll (a Ruby gem) be installed in order to run properly.","title":"FHIR IG Generation Tool"},{"location":"cimplInstall/#macos-java-installation","text":"The IG publisher is primarily written in java and requires JRE version 8. To install JRE: * Go to the Java SE Runtime Environment 8 Downloads page * Click the 'Accept License Agreement' radio button * Download the most recent JRE 8 installer for your operating system","title":"MacOS Java Installation"},{"location":"cimplInstall/#macos-jekyll-installation","text":"Jekyll is a ruby library that takes code and turns it into webpages. That is especially helpful for generating static websites like the FHIR Implementation Guides. If you don't know if the xcode developer tools are installed, run the following command: xcode-select --install Install the latest version of Ruby: brew install ruby When ruby is finished installing, run the following: gem install bundler jekyll NOTE: If your system requires sudo to gem install bundler and jekyll, use the following command to preserve environment variables when using sudo : sudo -E gem install bundler jekyl If you're running the IG Generation tool behind a proxy, you may need to explicitly declare the proxy at runtime , since the process tries to access external terminology servers. That's it! To test whether your CIMPL environment has been properly set up, try the Hello World example.","title":"MacOS Jekyll Installation"},{"location":"cimplReleaseNotes/","text":"CIMPL Release Notes Note: \"This documentation is in the process of being further expanded and is an actively updating document.\" CIMPL Release Notes CIMPL 6.0 CIMPL 5.0 CIMPL 6.0 Release Date : June 2019 CIMPL 6.0 contains a number of significant changes to both syntax and its base classes which support translation to FHIR. CIMPL 5.0 Release Date: 2017","title":"CIMPL Release Notes"},{"location":"cimplReleaseNotes/#cimpl-release-notes","text":"Note: \"This documentation is in the process of being further expanded and is an actively updating document.\" CIMPL Release Notes CIMPL 6.0 CIMPL 5.0","title":"CIMPL Release Notes"},{"location":"cimplReleaseNotes/#cimpl-60","text":"Release Date : June 2019 CIMPL 6.0 contains a number of significant changes to both syntax and its base classes which support translation to FHIR.","title":"CIMPL 6.0"},{"location":"cimplReleaseNotes/#cimpl-50","text":"Release Date: 2017","title":"CIMPL 5.0"}]}